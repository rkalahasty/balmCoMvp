{"ast":null,"code":"\"use strict\";\n/**\n * Implementation of atob() according to the HTML and Infra specs, except that\n * instead of throwing INVALID_CHARACTER_ERR we return null.\n */\n\nfunction atob(data) {\n  if (arguments.length === 0) {\n    throw new TypeError(\"1 argument required, but only 0 present.\");\n  } // Web IDL requires DOMStrings to just be converted using ECMAScript\n  // ToString, which in our case amounts to using a template literal.\n\n\n  data = `${data}`; // \"Remove all ASCII whitespace from data.\"\n\n  data = data.replace(/[ \\t\\n\\f\\r]/g, \"\"); // \"If data's length divides by 4 leaving no remainder, then: if data ends\n  // with one or two U+003D (=) code points, then remove them from data.\"\n\n  if (data.length % 4 === 0) {\n    data = data.replace(/==?$/, \"\");\n  } // \"If data's length divides by 4 leaving a remainder of 1, then return\n  // failure.\"\n  //\n  // \"If data contains a code point that is not one of\n  //\n  // U+002B (+)\n  // U+002F (/)\n  // ASCII alphanumeric\n  //\n  // then return failure.\"\n\n\n  if (data.length % 4 === 1 || /[^+/0-9A-Za-z]/.test(data)) {\n    return null;\n  } // \"Let output be an empty byte sequence.\"\n\n\n  let output = \"\"; // \"Let buffer be an empty buffer that can have bits appended to it.\"\n  //\n  // We append bits via left-shift and or.  accumulatedBits is used to track\n  // when we've gotten to 24 bits.\n\n  let buffer = 0;\n  let accumulatedBits = 0; // \"Let position be a position variable for data, initially pointing at the\n  // start of data.\"\n  //\n  // \"While position does not point past the end of data:\"\n\n  for (let i = 0; i < data.length; i++) {\n    // \"Find the code point pointed to by position in the second column of\n    // Table 1: The Base 64 Alphabet of RFC 4648. Let n be the number given in\n    // the first cell of the same row.\n    //\n    // \"Append to buffer the six bits corresponding to n, most significant bit\n    // first.\"\n    //\n    // atobLookup() implements the table from RFC 4648.\n    buffer <<= 6;\n    buffer |= atobLookup(data[i]);\n    accumulatedBits += 6; // \"If buffer has accumulated 24 bits, interpret them as three 8-bit\n    // big-endian numbers. Append three bytes with values equal to those\n    // numbers to output, in the same order, and then empty buffer.\"\n\n    if (accumulatedBits === 24) {\n      output += String.fromCharCode((buffer & 0xff0000) >> 16);\n      output += String.fromCharCode((buffer & 0xff00) >> 8);\n      output += String.fromCharCode(buffer & 0xff);\n      buffer = accumulatedBits = 0;\n    } // \"Advance position by 1.\"\n\n  } // \"If buffer is not empty, it contains either 12 or 18 bits. If it contains\n  // 12 bits, then discard the last four and interpret the remaining eight as\n  // an 8-bit big-endian number. If it contains 18 bits, then discard the last\n  // two and interpret the remaining 16 as two 8-bit big-endian numbers. Append\n  // the one or two bytes with values equal to those one or two numbers to\n  // output, in the same order.\"\n\n\n  if (accumulatedBits === 12) {\n    buffer >>= 4;\n    output += String.fromCharCode(buffer);\n  } else if (accumulatedBits === 18) {\n    buffer >>= 2;\n    output += String.fromCharCode((buffer & 0xff00) >> 8);\n    output += String.fromCharCode(buffer & 0xff);\n  } // \"Return output.\"\n\n\n  return output;\n}\n/**\n * A lookup table for atob(), which converts an ASCII character to the\n * corresponding six-bit number.\n */\n\n\nconst keystr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nfunction atobLookup(chr) {\n  const index = keystr.indexOf(chr); // Throw exception if character is not in the lookup string; should not be hit in tests\n\n  return index < 0 ? undefined : index;\n}\n\nmodule.exports = atob;","map":{"version":3,"names":["atob","data","arguments","length","TypeError","replace","test","output","buffer","accumulatedBits","i","atobLookup","String","fromCharCode","keystr","chr","index","indexOf","undefined","module","exports"],"sources":["C:/Users/17033/balmco/node_modules/abab/lib/atob.js"],"sourcesContent":["\"use strict\";\n\n/**\n * Implementation of atob() according to the HTML and Infra specs, except that\n * instead of throwing INVALID_CHARACTER_ERR we return null.\n */\nfunction atob(data) {\n  if (arguments.length === 0) {\n    throw new TypeError(\"1 argument required, but only 0 present.\");\n  }\n\n  // Web IDL requires DOMStrings to just be converted using ECMAScript\n  // ToString, which in our case amounts to using a template literal.\n  data = `${data}`;\n  // \"Remove all ASCII whitespace from data.\"\n  data = data.replace(/[ \\t\\n\\f\\r]/g, \"\");\n  // \"If data's length divides by 4 leaving no remainder, then: if data ends\n  // with one or two U+003D (=) code points, then remove them from data.\"\n  if (data.length % 4 === 0) {\n    data = data.replace(/==?$/, \"\");\n  }\n  // \"If data's length divides by 4 leaving a remainder of 1, then return\n  // failure.\"\n  //\n  // \"If data contains a code point that is not one of\n  //\n  // U+002B (+)\n  // U+002F (/)\n  // ASCII alphanumeric\n  //\n  // then return failure.\"\n  if (data.length % 4 === 1 || /[^+/0-9A-Za-z]/.test(data)) {\n    return null;\n  }\n  // \"Let output be an empty byte sequence.\"\n  let output = \"\";\n  // \"Let buffer be an empty buffer that can have bits appended to it.\"\n  //\n  // We append bits via left-shift and or.  accumulatedBits is used to track\n  // when we've gotten to 24 bits.\n  let buffer = 0;\n  let accumulatedBits = 0;\n  // \"Let position be a position variable for data, initially pointing at the\n  // start of data.\"\n  //\n  // \"While position does not point past the end of data:\"\n  for (let i = 0; i < data.length; i++) {\n    // \"Find the code point pointed to by position in the second column of\n    // Table 1: The Base 64 Alphabet of RFC 4648. Let n be the number given in\n    // the first cell of the same row.\n    //\n    // \"Append to buffer the six bits corresponding to n, most significant bit\n    // first.\"\n    //\n    // atobLookup() implements the table from RFC 4648.\n    buffer <<= 6;\n    buffer |= atobLookup(data[i]);\n    accumulatedBits += 6;\n    // \"If buffer has accumulated 24 bits, interpret them as three 8-bit\n    // big-endian numbers. Append three bytes with values equal to those\n    // numbers to output, in the same order, and then empty buffer.\"\n    if (accumulatedBits === 24) {\n      output += String.fromCharCode((buffer & 0xff0000) >> 16);\n      output += String.fromCharCode((buffer & 0xff00) >> 8);\n      output += String.fromCharCode(buffer & 0xff);\n      buffer = accumulatedBits = 0;\n    }\n    // \"Advance position by 1.\"\n  }\n  // \"If buffer is not empty, it contains either 12 or 18 bits. If it contains\n  // 12 bits, then discard the last four and interpret the remaining eight as\n  // an 8-bit big-endian number. If it contains 18 bits, then discard the last\n  // two and interpret the remaining 16 as two 8-bit big-endian numbers. Append\n  // the one or two bytes with values equal to those one or two numbers to\n  // output, in the same order.\"\n  if (accumulatedBits === 12) {\n    buffer >>= 4;\n    output += String.fromCharCode(buffer);\n  } else if (accumulatedBits === 18) {\n    buffer >>= 2;\n    output += String.fromCharCode((buffer & 0xff00) >> 8);\n    output += String.fromCharCode(buffer & 0xff);\n  }\n  // \"Return output.\"\n  return output;\n}\n/**\n * A lookup table for atob(), which converts an ASCII character to the\n * corresponding six-bit number.\n */\n\nconst keystr =\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nfunction atobLookup(chr) {\n  const index = keystr.indexOf(chr);\n  // Throw exception if character is not in the lookup string; should not be hit in tests\n  return index < 0 ? undefined : index;\n}\n\nmodule.exports = atob;\n"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;;AACA,SAASA,IAAT,CAAcC,IAAd,EAAoB;EAClB,IAAIC,SAAS,CAACC,MAAV,KAAqB,CAAzB,EAA4B;IAC1B,MAAM,IAAIC,SAAJ,CAAc,0CAAd,CAAN;EACD,CAHiB,CAKlB;EACA;;;EACAH,IAAI,GAAI,GAAEA,IAAK,EAAf,CAPkB,CAQlB;;EACAA,IAAI,GAAGA,IAAI,CAACI,OAAL,CAAa,cAAb,EAA6B,EAA7B,CAAP,CATkB,CAUlB;EACA;;EACA,IAAIJ,IAAI,CAACE,MAAL,GAAc,CAAd,KAAoB,CAAxB,EAA2B;IACzBF,IAAI,GAAGA,IAAI,CAACI,OAAL,CAAa,MAAb,EAAqB,EAArB,CAAP;EACD,CAdiB,CAelB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EACA,IAAIJ,IAAI,CAACE,MAAL,GAAc,CAAd,KAAoB,CAApB,IAAyB,iBAAiBG,IAAjB,CAAsBL,IAAtB,CAA7B,EAA0D;IACxD,OAAO,IAAP;EACD,CA3BiB,CA4BlB;;;EACA,IAAIM,MAAM,GAAG,EAAb,CA7BkB,CA8BlB;EACA;EACA;EACA;;EACA,IAAIC,MAAM,GAAG,CAAb;EACA,IAAIC,eAAe,GAAG,CAAtB,CAnCkB,CAoClB;EACA;EACA;EACA;;EACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,IAAI,CAACE,MAAzB,EAAiCO,CAAC,EAAlC,EAAsC;IACpC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACAF,MAAM,KAAK,CAAX;IACAA,MAAM,IAAIG,UAAU,CAACV,IAAI,CAACS,CAAD,CAAL,CAApB;IACAD,eAAe,IAAI,CAAnB,CAXoC,CAYpC;IACA;IACA;;IACA,IAAIA,eAAe,KAAK,EAAxB,EAA4B;MAC1BF,MAAM,IAAIK,MAAM,CAACC,YAAP,CAAoB,CAACL,MAAM,GAAG,QAAV,KAAuB,EAA3C,CAAV;MACAD,MAAM,IAAIK,MAAM,CAACC,YAAP,CAAoB,CAACL,MAAM,GAAG,MAAV,KAAqB,CAAzC,CAAV;MACAD,MAAM,IAAIK,MAAM,CAACC,YAAP,CAAoBL,MAAM,GAAG,IAA7B,CAAV;MACAA,MAAM,GAAGC,eAAe,GAAG,CAA3B;IACD,CApBmC,CAqBpC;;EACD,CA9DiB,CA+DlB;EACA;EACA;EACA;EACA;EACA;;;EACA,IAAIA,eAAe,KAAK,EAAxB,EAA4B;IAC1BD,MAAM,KAAK,CAAX;IACAD,MAAM,IAAIK,MAAM,CAACC,YAAP,CAAoBL,MAApB,CAAV;EACD,CAHD,MAGO,IAAIC,eAAe,KAAK,EAAxB,EAA4B;IACjCD,MAAM,KAAK,CAAX;IACAD,MAAM,IAAIK,MAAM,CAACC,YAAP,CAAoB,CAACL,MAAM,GAAG,MAAV,KAAqB,CAAzC,CAAV;IACAD,MAAM,IAAIK,MAAM,CAACC,YAAP,CAAoBL,MAAM,GAAG,IAA7B,CAAV;EACD,CA5EiB,CA6ElB;;;EACA,OAAOD,MAAP;AACD;AACD;AACA;AACA;AACA;;;AAEA,MAAMO,MAAM,GACV,kEADF;;AAGA,SAASH,UAAT,CAAoBI,GAApB,EAAyB;EACvB,MAAMC,KAAK,GAAGF,MAAM,CAACG,OAAP,CAAeF,GAAf,CAAd,CADuB,CAEvB;;EACA,OAAOC,KAAK,GAAG,CAAR,GAAYE,SAAZ,GAAwBF,KAA/B;AACD;;AAEDG,MAAM,CAACC,OAAP,GAAiBpB,IAAjB"},"metadata":{},"sourceType":"script"}