{"ast":null,"code":"/*\n  Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2015 Ingvar Stepanyan <me@rreverser.com>\n  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>\n  Copyright (C) 2012-2013 Michael Ficarra <escodegen.copyright@michael.ficarra.me>\n  Copyright (C) 2012-2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2013 Irakli Gozalishvili <rfobic@gmail.com>\n  Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>\n  Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>\n  Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*global exports:true, require:true, global:true*/\n(function () {\n  'use strict';\n\n  var Syntax, Precedence, BinaryPrecedence, SourceNode, estraverse, esutils, base, indent, json, renumber, hexadecimal, quotes, escapeless, newline, space, parentheses, semicolons, safeConcatenation, directive, extra, parse, sourceMap, sourceCode, preserveBlankLines, FORMAT_MINIFY, FORMAT_DEFAULTS;\n  estraverse = require('estraverse');\n  esutils = require('esutils');\n  Syntax = estraverse.Syntax; // Generation is done by generateExpression.\n\n  function isExpression(node) {\n    return CodeGenerator.Expression.hasOwnProperty(node.type);\n  } // Generation is done by generateStatement.\n\n\n  function isStatement(node) {\n    return CodeGenerator.Statement.hasOwnProperty(node.type);\n  }\n\n  Precedence = {\n    Sequence: 0,\n    Yield: 1,\n    Assignment: 1,\n    Conditional: 2,\n    ArrowFunction: 2,\n    LogicalOR: 3,\n    LogicalAND: 4,\n    BitwiseOR: 5,\n    BitwiseXOR: 6,\n    BitwiseAND: 7,\n    Equality: 8,\n    Relational: 9,\n    BitwiseSHIFT: 10,\n    Additive: 11,\n    Multiplicative: 12,\n    Exponentiation: 13,\n    Await: 14,\n    Unary: 14,\n    Postfix: 15,\n    OptionalChaining: 16,\n    Call: 17,\n    New: 18,\n    TaggedTemplate: 19,\n    Member: 20,\n    Primary: 21\n  };\n  BinaryPrecedence = {\n    '||': Precedence.LogicalOR,\n    '&&': Precedence.LogicalAND,\n    '|': Precedence.BitwiseOR,\n    '^': Precedence.BitwiseXOR,\n    '&': Precedence.BitwiseAND,\n    '==': Precedence.Equality,\n    '!=': Precedence.Equality,\n    '===': Precedence.Equality,\n    '!==': Precedence.Equality,\n    'is': Precedence.Equality,\n    'isnt': Precedence.Equality,\n    '<': Precedence.Relational,\n    '>': Precedence.Relational,\n    '<=': Precedence.Relational,\n    '>=': Precedence.Relational,\n    'in': Precedence.Relational,\n    'instanceof': Precedence.Relational,\n    '<<': Precedence.BitwiseSHIFT,\n    '>>': Precedence.BitwiseSHIFT,\n    '>>>': Precedence.BitwiseSHIFT,\n    '+': Precedence.Additive,\n    '-': Precedence.Additive,\n    '*': Precedence.Multiplicative,\n    '%': Precedence.Multiplicative,\n    '/': Precedence.Multiplicative,\n    '**': Precedence.Exponentiation\n  }; //Flags\n\n  var F_ALLOW_IN = 1,\n      F_ALLOW_CALL = 1 << 1,\n      F_ALLOW_UNPARATH_NEW = 1 << 2,\n      F_FUNC_BODY = 1 << 3,\n      F_DIRECTIVE_CTX = 1 << 4,\n      F_SEMICOLON_OPT = 1 << 5; //Expression flag sets\n  //NOTE: Flag order:\n  // F_ALLOW_IN\n  // F_ALLOW_CALL\n  // F_ALLOW_UNPARATH_NEW\n\n  var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,\n      E_TTF = F_ALLOW_IN | F_ALLOW_CALL,\n      E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,\n      E_TFF = F_ALLOW_IN,\n      E_FFT = F_ALLOW_UNPARATH_NEW,\n      E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW; //Statement flag sets\n  //NOTE: Flag order:\n  // F_ALLOW_IN\n  // F_FUNC_BODY\n  // F_DIRECTIVE_CTX\n  // F_SEMICOLON_OPT\n\n  var S_TFFF = F_ALLOW_IN,\n      S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT,\n      S_FFFF = 0x00,\n      S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX,\n      S_TTFF = F_ALLOW_IN | F_FUNC_BODY;\n\n  function getDefaultOptions() {\n    // default options\n    return {\n      indent: null,\n      base: null,\n      parse: null,\n      comment: false,\n      format: {\n        indent: {\n          style: '    ',\n          base: 0,\n          adjustMultilineComment: false\n        },\n        newline: '\\n',\n        space: ' ',\n        json: false,\n        renumber: false,\n        hexadecimal: false,\n        quotes: 'single',\n        escapeless: false,\n        compact: false,\n        parentheses: true,\n        semicolons: true,\n        safeConcatenation: false,\n        preserveBlankLines: false\n      },\n      moz: {\n        comprehensionExpressionStartsWithAssignment: false,\n        starlessGenerator: false\n      },\n      sourceMap: null,\n      sourceMapRoot: null,\n      sourceMapWithCode: false,\n      directive: false,\n      raw: true,\n      verbatim: null,\n      sourceCode: null\n    };\n  }\n\n  function stringRepeat(str, num) {\n    var result = '';\n\n    for (num |= 0; num > 0; num >>>= 1, str += str) {\n      if (num & 1) {\n        result += str;\n      }\n    }\n\n    return result;\n  }\n\n  function hasLineTerminator(str) {\n    return /[\\r\\n]/g.test(str);\n  }\n\n  function endsWithLineTerminator(str) {\n    var len = str.length;\n    return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));\n  }\n\n  function merge(target, override) {\n    var key;\n\n    for (key in override) {\n      if (override.hasOwnProperty(key)) {\n        target[key] = override[key];\n      }\n    }\n\n    return target;\n  }\n\n  function updateDeeply(target, override) {\n    var key, val;\n\n    function isHashObject(target) {\n      return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);\n    }\n\n    for (key in override) {\n      if (override.hasOwnProperty(key)) {\n        val = override[key];\n\n        if (isHashObject(val)) {\n          if (isHashObject(target[key])) {\n            updateDeeply(target[key], val);\n          } else {\n            target[key] = updateDeeply({}, val);\n          }\n        } else {\n          target[key] = val;\n        }\n      }\n    }\n\n    return target;\n  }\n\n  function generateNumber(value) {\n    var result, point, temp, exponent, pos;\n\n    if (value !== value) {\n      throw new Error('Numeric literal whose value is NaN');\n    }\n\n    if (value < 0 || value === 0 && 1 / value < 0) {\n      throw new Error('Numeric literal whose value is negative');\n    }\n\n    if (value === 1 / 0) {\n      return json ? 'null' : renumber ? '1e400' : '1e+400';\n    }\n\n    result = '' + value;\n\n    if (!renumber || result.length < 3) {\n      return result;\n    }\n\n    point = result.indexOf('.');\n\n    if (!json && result.charCodeAt(0) === 0x30\n    /* 0 */\n    && point === 1) {\n      point = 0;\n      result = result.slice(1);\n    }\n\n    temp = result;\n    result = result.replace('e+', 'e');\n    exponent = 0;\n\n    if ((pos = temp.indexOf('e')) > 0) {\n      exponent = +temp.slice(pos + 1);\n      temp = temp.slice(0, pos);\n    }\n\n    if (point >= 0) {\n      exponent -= temp.length - point - 1;\n      temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';\n    }\n\n    pos = 0;\n\n    while (temp.charCodeAt(temp.length + pos - 1) === 0x30\n    /* 0 */\n    ) {\n      --pos;\n    }\n\n    if (pos !== 0) {\n      exponent -= pos;\n      temp = temp.slice(0, pos);\n    }\n\n    if (exponent !== 0) {\n      temp += 'e' + exponent;\n    }\n\n    if ((temp.length < result.length || hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length) && +temp === value) {\n      result = temp;\n    }\n\n    return result;\n  } // Generate valid RegExp expression.\n  // This function is based on https://github.com/Constellation/iv Engine\n\n\n  function escapeRegExpCharacter(ch, previousIsBackslash) {\n    // not handling '\\' and handling \\u2028 or \\u2029 to unicode escape sequence\n    if ((ch & ~1) === 0x2028) {\n      return (previousIsBackslash ? 'u' : '\\\\u') + (ch === 0x2028 ? '2028' : '2029');\n    } else if (ch === 10 || ch === 13) {\n      // \\n, \\r\n      return (previousIsBackslash ? '' : '\\\\') + (ch === 10 ? 'n' : 'r');\n    }\n\n    return String.fromCharCode(ch);\n  }\n\n  function generateRegExp(reg) {\n    var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;\n    result = reg.toString();\n\n    if (reg.source) {\n      // extract flag from toString result\n      match = result.match(/\\/([^/]*)$/);\n\n      if (!match) {\n        return result;\n      }\n\n      flags = match[1];\n      result = '';\n      characterInBrack = false;\n      previousIsBackslash = false;\n\n      for (i = 0, iz = reg.source.length; i < iz; ++i) {\n        ch = reg.source.charCodeAt(i);\n\n        if (!previousIsBackslash) {\n          if (characterInBrack) {\n            if (ch === 93) {\n              // ]\n              characterInBrack = false;\n            }\n          } else {\n            if (ch === 47) {\n              // /\n              result += '\\\\';\n            } else if (ch === 91) {\n              // [\n              characterInBrack = true;\n            }\n          }\n\n          result += escapeRegExpCharacter(ch, previousIsBackslash);\n          previousIsBackslash = ch === 92; // \\\n        } else {\n          // if new RegExp(\"\\\\\\n') is provided, create /\\n/\n          result += escapeRegExpCharacter(ch, previousIsBackslash); // prevent like /\\\\[/]/\n\n          previousIsBackslash = false;\n        }\n      }\n\n      return '/' + result + '/' + flags;\n    }\n\n    return result;\n  }\n\n  function escapeAllowedCharacter(code, next) {\n    var hex;\n\n    if (code === 0x08\n    /* \\b */\n    ) {\n      return '\\\\b';\n    }\n\n    if (code === 0x0C\n    /* \\f */\n    ) {\n      return '\\\\f';\n    }\n\n    if (code === 0x09\n    /* \\t */\n    ) {\n      return '\\\\t';\n    }\n\n    hex = code.toString(16).toUpperCase();\n\n    if (json || code > 0xFF) {\n      return '\\\\u' + '0000'.slice(hex.length) + hex;\n    } else if (code === 0x0000 && !esutils.code.isDecimalDigit(next)) {\n      return '\\\\0';\n    } else if (code === 0x000B\n    /* \\v */\n    ) {\n      // '\\v'\n      return '\\\\x0B';\n    } else {\n      return '\\\\x' + '00'.slice(hex.length) + hex;\n    }\n  }\n\n  function escapeDisallowedCharacter(code) {\n    if (code === 0x5C\n    /* \\ */\n    ) {\n      return '\\\\\\\\';\n    }\n\n    if (code === 0x0A\n    /* \\n */\n    ) {\n      return '\\\\n';\n    }\n\n    if (code === 0x0D\n    /* \\r */\n    ) {\n      return '\\\\r';\n    }\n\n    if (code === 0x2028) {\n      return '\\\\u2028';\n    }\n\n    if (code === 0x2029) {\n      return '\\\\u2029';\n    }\n\n    throw new Error('Incorrectly classified character');\n  }\n\n  function escapeDirective(str) {\n    var i, iz, code, quote;\n    quote = quotes === 'double' ? '\"' : '\\'';\n\n    for (i = 0, iz = str.length; i < iz; ++i) {\n      code = str.charCodeAt(i);\n\n      if (code === 0x27\n      /* ' */\n      ) {\n        quote = '\"';\n        break;\n      } else if (code === 0x22\n      /* \" */\n      ) {\n        quote = '\\'';\n        break;\n      } else if (code === 0x5C\n      /* \\ */\n      ) {\n        ++i;\n      }\n    }\n\n    return quote + str + quote;\n  }\n\n  function escapeString(str) {\n    var result = '',\n        i,\n        len,\n        code,\n        singleQuotes = 0,\n        doubleQuotes = 0,\n        single,\n        quote;\n\n    for (i = 0, len = str.length; i < len; ++i) {\n      code = str.charCodeAt(i);\n\n      if (code === 0x27\n      /* ' */\n      ) {\n        ++singleQuotes;\n      } else if (code === 0x22\n      /* \" */\n      ) {\n        ++doubleQuotes;\n      } else if (code === 0x2F\n      /* / */\n      && json) {\n        result += '\\\\';\n      } else if (esutils.code.isLineTerminator(code) || code === 0x5C\n      /* \\ */\n      ) {\n        result += escapeDisallowedCharacter(code);\n        continue;\n      } else if (!esutils.code.isIdentifierPartES5(code) && (json && code < 0x20\n      /* SP */\n      || !json && !escapeless && (code < 0x20\n      /* SP */\n      || code > 0x7E\n      /* ~ */\n      ))) {\n        result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));\n        continue;\n      }\n\n      result += String.fromCharCode(code);\n    }\n\n    single = !(quotes === 'double' || quotes === 'auto' && doubleQuotes < singleQuotes);\n    quote = single ? '\\'' : '\"';\n\n    if (!(single ? singleQuotes : doubleQuotes)) {\n      return quote + result + quote;\n    }\n\n    str = result;\n    result = quote;\n\n    for (i = 0, len = str.length; i < len; ++i) {\n      code = str.charCodeAt(i);\n\n      if (code === 0x27\n      /* ' */\n      && single || code === 0x22\n      /* \" */\n      && !single) {\n        result += '\\\\';\n      }\n\n      result += String.fromCharCode(code);\n    }\n\n    return result + quote;\n  }\n  /**\n   * flatten an array to a string, where the array can contain\n   * either strings or nested arrays\n   */\n\n\n  function flattenToString(arr) {\n    var i,\n        iz,\n        elem,\n        result = '';\n\n    for (i = 0, iz = arr.length; i < iz; ++i) {\n      elem = arr[i];\n      result += Array.isArray(elem) ? flattenToString(elem) : elem;\n    }\n\n    return result;\n  }\n  /**\n   * convert generated to a SourceNode when source maps are enabled.\n   */\n\n\n  function toSourceNodeWhenNeeded(generated, node) {\n    if (!sourceMap) {\n      // with no source maps, generated is either an\n      // array or a string.  if an array, flatten it.\n      // if a string, just return it\n      if (Array.isArray(generated)) {\n        return flattenToString(generated);\n      } else {\n        return generated;\n      }\n    }\n\n    if (node == null) {\n      if (generated instanceof SourceNode) {\n        return generated;\n      } else {\n        node = {};\n      }\n    }\n\n    if (node.loc == null) {\n      return new SourceNode(null, null, sourceMap, generated, node.name || null);\n    }\n\n    return new SourceNode(node.loc.start.line, node.loc.start.column, sourceMap === true ? node.loc.source || null : sourceMap, generated, node.name || null);\n  }\n\n  function noEmptySpace() {\n    return space ? space : ' ';\n  }\n\n  function join(left, right) {\n    var leftSource, rightSource, leftCharCode, rightCharCode;\n    leftSource = toSourceNodeWhenNeeded(left).toString();\n\n    if (leftSource.length === 0) {\n      return [right];\n    }\n\n    rightSource = toSourceNodeWhenNeeded(right).toString();\n\n    if (rightSource.length === 0) {\n      return [left];\n    }\n\n    leftCharCode = leftSource.charCodeAt(leftSource.length - 1);\n    rightCharCode = rightSource.charCodeAt(0);\n\n    if ((leftCharCode === 0x2B\n    /* + */\n    || leftCharCode === 0x2D\n    /* - */\n    ) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode) || leftCharCode === 0x2F\n    /* / */\n    && rightCharCode === 0x69\n    /* i */\n    ) {\n      // infix word operators all start with `i`\n      return [left, noEmptySpace(), right];\n    } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) || esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {\n      return [left, right];\n    }\n\n    return [left, space, right];\n  }\n\n  function addIndent(stmt) {\n    return [base, stmt];\n  }\n\n  function withIndent(fn) {\n    var previousBase;\n    previousBase = base;\n    base += indent;\n    fn(base);\n    base = previousBase;\n  }\n\n  function calculateSpaces(str) {\n    var i;\n\n    for (i = str.length - 1; i >= 0; --i) {\n      if (esutils.code.isLineTerminator(str.charCodeAt(i))) {\n        break;\n      }\n    }\n\n    return str.length - 1 - i;\n  }\n\n  function adjustMultilineComment(value, specialBase) {\n    var array, i, len, line, j, spaces, previousBase, sn;\n    array = value.split(/\\r\\n|[\\r\\n]/);\n    spaces = Number.MAX_VALUE; // first line doesn't have indentation\n\n    for (i = 1, len = array.length; i < len; ++i) {\n      line = array[i];\n      j = 0;\n\n      while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {\n        ++j;\n      }\n\n      if (spaces > j) {\n        spaces = j;\n      }\n    }\n\n    if (typeof specialBase !== 'undefined') {\n      // pattern like\n      // {\n      //   var t = 20;  /*\n      //                 * this is comment\n      //                 */\n      // }\n      previousBase = base;\n\n      if (array[1][spaces] === '*') {\n        specialBase += ' ';\n      }\n\n      base = specialBase;\n    } else {\n      if (spaces & 1) {\n        // /*\n        //  *\n        //  */\n        // If spaces are odd number, above pattern is considered.\n        // We waste 1 space.\n        --spaces;\n      }\n\n      previousBase = base;\n    }\n\n    for (i = 1, len = array.length; i < len; ++i) {\n      sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));\n      array[i] = sourceMap ? sn.join('') : sn;\n    }\n\n    base = previousBase;\n    return array.join('\\n');\n  }\n\n  function generateComment(comment, specialBase) {\n    if (comment.type === 'Line') {\n      if (endsWithLineTerminator(comment.value)) {\n        return '//' + comment.value;\n      } else {\n        // Always use LineTerminator\n        var result = '//' + comment.value;\n\n        if (!preserveBlankLines) {\n          result += '\\n';\n        }\n\n        return result;\n      }\n    }\n\n    if (extra.format.indent.adjustMultilineComment && /[\\n\\r]/.test(comment.value)) {\n      return adjustMultilineComment('/*' + comment.value + '*/', specialBase);\n    }\n\n    return '/*' + comment.value + '*/';\n  }\n\n  function addComments(stmt, result) {\n    var i, len, comment, save, tailingToStatement, specialBase, fragment, extRange, range, prevRange, prefix, infix, suffix, count;\n\n    if (stmt.leadingComments && stmt.leadingComments.length > 0) {\n      save = result;\n\n      if (preserveBlankLines) {\n        comment = stmt.leadingComments[0];\n        result = [];\n        extRange = comment.extendedRange;\n        range = comment.range;\n        prefix = sourceCode.substring(extRange[0], range[0]);\n        count = (prefix.match(/\\n/g) || []).length;\n\n        if (count > 0) {\n          result.push(stringRepeat('\\n', count));\n          result.push(addIndent(generateComment(comment)));\n        } else {\n          result.push(prefix);\n          result.push(generateComment(comment));\n        }\n\n        prevRange = range;\n\n        for (i = 1, len = stmt.leadingComments.length; i < len; i++) {\n          comment = stmt.leadingComments[i];\n          range = comment.range;\n          infix = sourceCode.substring(prevRange[1], range[0]);\n          count = (infix.match(/\\n/g) || []).length;\n          result.push(stringRepeat('\\n', count));\n          result.push(addIndent(generateComment(comment)));\n          prevRange = range;\n        }\n\n        suffix = sourceCode.substring(range[1], extRange[1]);\n        count = (suffix.match(/\\n/g) || []).length;\n        result.push(stringRepeat('\\n', count));\n      } else {\n        comment = stmt.leadingComments[0];\n        result = [];\n\n        if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {\n          result.push('\\n');\n        }\n\n        result.push(generateComment(comment));\n\n        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n          result.push('\\n');\n        }\n\n        for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {\n          comment = stmt.leadingComments[i];\n          fragment = [generateComment(comment)];\n\n          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n            fragment.push('\\n');\n          }\n\n          result.push(addIndent(fragment));\n        }\n      }\n\n      result.push(addIndent(save));\n    }\n\n    if (stmt.trailingComments) {\n      if (preserveBlankLines) {\n        comment = stmt.trailingComments[0];\n        extRange = comment.extendedRange;\n        range = comment.range;\n        prefix = sourceCode.substring(extRange[0], range[0]);\n        count = (prefix.match(/\\n/g) || []).length;\n\n        if (count > 0) {\n          result.push(stringRepeat('\\n', count));\n          result.push(addIndent(generateComment(comment)));\n        } else {\n          result.push(prefix);\n          result.push(generateComment(comment));\n        }\n      } else {\n        tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());\n        specialBase = stringRepeat(' ', calculateSpaces(toSourceNodeWhenNeeded([base, result, indent]).toString()));\n\n        for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {\n          comment = stmt.trailingComments[i];\n\n          if (tailingToStatement) {\n            // We assume target like following script\n            //\n            // var t = 20;  /**\n            //               * This is comment of t\n            //               */\n            if (i === 0) {\n              // first case\n              result = [result, indent];\n            } else {\n              result = [result, specialBase];\n            }\n\n            result.push(generateComment(comment, specialBase));\n          } else {\n            result = [result, addIndent(generateComment(comment))];\n          }\n\n          if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n            result = [result, '\\n'];\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n\n  function generateBlankLines(start, end, result) {\n    var j,\n        newlineCount = 0;\n\n    for (j = start; j < end; j++) {\n      if (sourceCode[j] === '\\n') {\n        newlineCount++;\n      }\n    }\n\n    for (j = 1; j < newlineCount; j++) {\n      result.push(newline);\n    }\n  }\n\n  function parenthesize(text, current, should) {\n    if (current < should) {\n      return ['(', text, ')'];\n    }\n\n    return text;\n  }\n\n  function generateVerbatimString(string) {\n    var i, iz, result;\n    result = string.split(/\\r\\n|\\n/);\n\n    for (i = 1, iz = result.length; i < iz; i++) {\n      result[i] = newline + base + result[i];\n    }\n\n    return result;\n  }\n\n  function generateVerbatim(expr, precedence) {\n    var verbatim, result, prec;\n    verbatim = expr[extra.verbatim];\n\n    if (typeof verbatim === 'string') {\n      result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);\n    } else {\n      // verbatim is object\n      result = generateVerbatimString(verbatim.content);\n      prec = verbatim.precedence != null ? verbatim.precedence : Precedence.Sequence;\n      result = parenthesize(result, prec, precedence);\n    }\n\n    return toSourceNodeWhenNeeded(result, expr);\n  }\n\n  function CodeGenerator() {} // Helpers.\n\n\n  CodeGenerator.prototype.maybeBlock = function (stmt, flags) {\n    var result,\n        noLeadingComment,\n        that = this;\n    noLeadingComment = !extra.comment || !stmt.leadingComments;\n\n    if (stmt.type === Syntax.BlockStatement && noLeadingComment) {\n      return [space, this.generateStatement(stmt, flags)];\n    }\n\n    if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {\n      return ';';\n    }\n\n    withIndent(function () {\n      result = [newline, addIndent(that.generateStatement(stmt, flags))];\n    });\n    return result;\n  };\n\n  CodeGenerator.prototype.maybeBlockSuffix = function (stmt, result) {\n    var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());\n\n    if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {\n      return [result, space];\n    }\n\n    if (ends) {\n      return [result, base];\n    }\n\n    return [result, newline, base];\n  };\n\n  function generateIdentifier(node) {\n    return toSourceNodeWhenNeeded(node.name, node);\n  }\n\n  function generateAsyncPrefix(node, spaceRequired) {\n    return node.async ? 'async' + (spaceRequired ? noEmptySpace() : space) : '';\n  }\n\n  function generateStarSuffix(node) {\n    var isGenerator = node.generator && !extra.moz.starlessGenerator;\n    return isGenerator ? '*' + space : '';\n  }\n\n  function generateMethodPrefix(prop) {\n    var func = prop.value,\n        prefix = '';\n\n    if (func.async) {\n      prefix += generateAsyncPrefix(func, !prop.computed);\n    }\n\n    if (func.generator) {\n      // avoid space before method name\n      prefix += generateStarSuffix(func) ? '*' : '';\n    }\n\n    return prefix;\n  }\n\n  CodeGenerator.prototype.generatePattern = function (node, precedence, flags) {\n    if (node.type === Syntax.Identifier) {\n      return generateIdentifier(node);\n    }\n\n    return this.generateExpression(node, precedence, flags);\n  };\n\n  CodeGenerator.prototype.generateFunctionParams = function (node) {\n    var i, iz, result, hasDefault;\n    hasDefault = false;\n\n    if (node.type === Syntax.ArrowFunctionExpression && !node.rest && (!node.defaults || node.defaults.length === 0) && node.params.length === 1 && node.params[0].type === Syntax.Identifier) {\n      // arg => { } case\n      result = [generateAsyncPrefix(node, true), generateIdentifier(node.params[0])];\n    } else {\n      result = node.type === Syntax.ArrowFunctionExpression ? [generateAsyncPrefix(node, false)] : [];\n      result.push('(');\n\n      if (node.defaults) {\n        hasDefault = true;\n      }\n\n      for (i = 0, iz = node.params.length; i < iz; ++i) {\n        if (hasDefault && node.defaults[i]) {\n          // Handle default values.\n          result.push(this.generateAssignment(node.params[i], node.defaults[i], '=', Precedence.Assignment, E_TTT));\n        } else {\n          result.push(this.generatePattern(node.params[i], Precedence.Assignment, E_TTT));\n        }\n\n        if (i + 1 < iz) {\n          result.push(',' + space);\n        }\n      }\n\n      if (node.rest) {\n        if (node.params.length) {\n          result.push(',' + space);\n        }\n\n        result.push('...');\n        result.push(generateIdentifier(node.rest));\n      }\n\n      result.push(')');\n    }\n\n    return result;\n  };\n\n  CodeGenerator.prototype.generateFunctionBody = function (node) {\n    var result, expr;\n    result = this.generateFunctionParams(node);\n\n    if (node.type === Syntax.ArrowFunctionExpression) {\n      result.push(space);\n      result.push('=>');\n    }\n\n    if (node.expression) {\n      result.push(space);\n      expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);\n\n      if (expr.toString().charAt(0) === '{') {\n        expr = ['(', expr, ')'];\n      }\n\n      result.push(expr);\n    } else {\n      result.push(this.maybeBlock(node.body, S_TTFF));\n    }\n\n    return result;\n  };\n\n  CodeGenerator.prototype.generateIterationForStatement = function (operator, stmt, flags) {\n    var result = ['for' + (stmt.await ? noEmptySpace() + 'await' : '') + space + '('],\n        that = this;\n    withIndent(function () {\n      if (stmt.left.type === Syntax.VariableDeclaration) {\n        withIndent(function () {\n          result.push(stmt.left.kind + noEmptySpace());\n          result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));\n        });\n      } else {\n        result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));\n      }\n\n      result = join(result, operator);\n      result = [join(result, that.generateExpression(stmt.right, Precedence.Assignment, E_TTT)), ')'];\n    });\n    result.push(this.maybeBlock(stmt.body, flags));\n    return result;\n  };\n\n  CodeGenerator.prototype.generatePropertyKey = function (expr, computed) {\n    var result = [];\n\n    if (computed) {\n      result.push('[');\n    }\n\n    result.push(this.generateExpression(expr, Precedence.Assignment, E_TTT));\n\n    if (computed) {\n      result.push(']');\n    }\n\n    return result;\n  };\n\n  CodeGenerator.prototype.generateAssignment = function (left, right, operator, precedence, flags) {\n    if (Precedence.Assignment < precedence) {\n      flags |= F_ALLOW_IN;\n    }\n\n    return parenthesize([this.generateExpression(left, Precedence.Call, flags), space + operator + space, this.generateExpression(right, Precedence.Assignment, flags)], Precedence.Assignment, precedence);\n  };\n\n  CodeGenerator.prototype.semicolon = function (flags) {\n    if (!semicolons && flags & F_SEMICOLON_OPT) {\n      return '';\n    }\n\n    return ';';\n  }; // Statements.\n\n\n  CodeGenerator.Statement = {\n    BlockStatement: function (stmt, flags) {\n      var range,\n          content,\n          result = ['{', newline],\n          that = this;\n      withIndent(function () {\n        // handle functions without any code\n        if (stmt.body.length === 0 && preserveBlankLines) {\n          range = stmt.range;\n\n          if (range[1] - range[0] > 2) {\n            content = sourceCode.substring(range[0] + 1, range[1] - 1);\n\n            if (content[0] === '\\n') {\n              result = ['{'];\n            }\n\n            result.push(content);\n          }\n        }\n\n        var i, iz, fragment, bodyFlags;\n        bodyFlags = S_TFFF;\n\n        if (flags & F_FUNC_BODY) {\n          bodyFlags |= F_DIRECTIVE_CTX;\n        }\n\n        for (i = 0, iz = stmt.body.length; i < iz; ++i) {\n          if (preserveBlankLines) {\n            // handle spaces before the first line\n            if (i === 0) {\n              if (stmt.body[0].leadingComments) {\n                range = stmt.body[0].leadingComments[0].extendedRange;\n                content = sourceCode.substring(range[0], range[1]);\n\n                if (content[0] === '\\n') {\n                  result = ['{'];\n                }\n              }\n\n              if (!stmt.body[0].leadingComments) {\n                generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);\n              }\n            } // handle spaces between lines\n\n\n            if (i > 0) {\n              if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {\n                generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);\n              }\n            }\n          }\n\n          if (i === iz - 1) {\n            bodyFlags |= F_SEMICOLON_OPT;\n          }\n\n          if (stmt.body[i].leadingComments && preserveBlankLines) {\n            fragment = that.generateStatement(stmt.body[i], bodyFlags);\n          } else {\n            fragment = addIndent(that.generateStatement(stmt.body[i], bodyFlags));\n          }\n\n          result.push(fragment);\n\n          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n            if (preserveBlankLines && i < iz - 1) {\n              // don't add a new line if there are leading coments\n              // in the next statement\n              if (!stmt.body[i + 1].leadingComments) {\n                result.push(newline);\n              }\n            } else {\n              result.push(newline);\n            }\n          }\n\n          if (preserveBlankLines) {\n            // handle spaces after the last line\n            if (i === iz - 1) {\n              if (!stmt.body[i].trailingComments) {\n                generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);\n              }\n            }\n          }\n        }\n      });\n      result.push(addIndent('}'));\n      return result;\n    },\n    BreakStatement: function (stmt, flags) {\n      if (stmt.label) {\n        return 'break ' + stmt.label.name + this.semicolon(flags);\n      }\n\n      return 'break' + this.semicolon(flags);\n    },\n    ContinueStatement: function (stmt, flags) {\n      if (stmt.label) {\n        return 'continue ' + stmt.label.name + this.semicolon(flags);\n      }\n\n      return 'continue' + this.semicolon(flags);\n    },\n    ClassBody: function (stmt, flags) {\n      var result = ['{', newline],\n          that = this;\n      withIndent(function (indent) {\n        var i, iz;\n\n        for (i = 0, iz = stmt.body.length; i < iz; ++i) {\n          result.push(indent);\n          result.push(that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT));\n\n          if (i + 1 < iz) {\n            result.push(newline);\n          }\n        }\n      });\n\n      if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n        result.push(newline);\n      }\n\n      result.push(base);\n      result.push('}');\n      return result;\n    },\n    ClassDeclaration: function (stmt, flags) {\n      var result, fragment;\n      result = ['class'];\n\n      if (stmt.id) {\n        result = join(result, this.generateExpression(stmt.id, Precedence.Sequence, E_TTT));\n      }\n\n      if (stmt.superClass) {\n        fragment = join('extends', this.generateExpression(stmt.superClass, Precedence.Unary, E_TTT));\n        result = join(result, fragment);\n      }\n\n      result.push(space);\n      result.push(this.generateStatement(stmt.body, S_TFFT));\n      return result;\n    },\n    DirectiveStatement: function (stmt, flags) {\n      if (extra.raw && stmt.raw) {\n        return stmt.raw + this.semicolon(flags);\n      }\n\n      return escapeDirective(stmt.directive) + this.semicolon(flags);\n    },\n    DoWhileStatement: function (stmt, flags) {\n      // Because `do 42 while (cond)` is Syntax Error. We need semicolon.\n      var result = join('do', this.maybeBlock(stmt.body, S_TFFF));\n      result = this.maybeBlockSuffix(stmt.body, result);\n      return join(result, ['while' + space + '(', this.generateExpression(stmt.test, Precedence.Sequence, E_TTT), ')' + this.semicolon(flags)]);\n    },\n    CatchClause: function (stmt, flags) {\n      var result,\n          that = this;\n      withIndent(function () {\n        var guard;\n\n        if (stmt.param) {\n          result = ['catch' + space + '(', that.generateExpression(stmt.param, Precedence.Sequence, E_TTT), ')'];\n\n          if (stmt.guard) {\n            guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);\n            result.splice(2, 0, ' if ', guard);\n          }\n        } else {\n          result = ['catch'];\n        }\n      });\n      result.push(this.maybeBlock(stmt.body, S_TFFF));\n      return result;\n    },\n    DebuggerStatement: function (stmt, flags) {\n      return 'debugger' + this.semicolon(flags);\n    },\n    EmptyStatement: function (stmt, flags) {\n      return ';';\n    },\n    ExportDefaultDeclaration: function (stmt, flags) {\n      var result = ['export'],\n          bodyFlags;\n      bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF; // export default HoistableDeclaration[Default]\n      // export default AssignmentExpression[In] ;\n\n      result = join(result, 'default');\n\n      if (isStatement(stmt.declaration)) {\n        result = join(result, this.generateStatement(stmt.declaration, bodyFlags));\n      } else {\n        result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));\n      }\n\n      return result;\n    },\n    ExportNamedDeclaration: function (stmt, flags) {\n      var result = ['export'],\n          bodyFlags,\n          that = this;\n      bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF; // export VariableStatement\n      // export Declaration[Default]\n\n      if (stmt.declaration) {\n        return join(result, this.generateStatement(stmt.declaration, bodyFlags));\n      } // export ExportClause[NoReference] FromClause ;\n      // export ExportClause ;\n\n\n      if (stmt.specifiers) {\n        if (stmt.specifiers.length === 0) {\n          result = join(result, '{' + space + '}');\n        } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {\n          result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));\n        } else {\n          result = join(result, '{');\n          withIndent(function (indent) {\n            var i, iz;\n            result.push(newline);\n\n            for (i = 0, iz = stmt.specifiers.length; i < iz; ++i) {\n              result.push(indent);\n              result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));\n\n              if (i + 1 < iz) {\n                result.push(',' + newline);\n              }\n            }\n          });\n\n          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n            result.push(newline);\n          }\n\n          result.push(base + '}');\n        }\n\n        if (stmt.source) {\n          result = join(result, ['from' + space, // ModuleSpecifier\n          this.generateExpression(stmt.source, Precedence.Sequence, E_TTT), this.semicolon(flags)]);\n        } else {\n          result.push(this.semicolon(flags));\n        }\n      }\n\n      return result;\n    },\n    ExportAllDeclaration: function (stmt, flags) {\n      // export * FromClause ;\n      return ['export' + space, '*' + space, 'from' + space, // ModuleSpecifier\n      this.generateExpression(stmt.source, Precedence.Sequence, E_TTT), this.semicolon(flags)];\n    },\n    ExpressionStatement: function (stmt, flags) {\n      var result, fragment;\n\n      function isClassPrefixed(fragment) {\n        var code;\n\n        if (fragment.slice(0, 5) !== 'class') {\n          return false;\n        }\n\n        code = fragment.charCodeAt(5);\n        return code === 0x7B\n        /* '{' */\n        || esutils.code.isWhiteSpace(code) || esutils.code.isLineTerminator(code);\n      }\n\n      function isFunctionPrefixed(fragment) {\n        var code;\n\n        if (fragment.slice(0, 8) !== 'function') {\n          return false;\n        }\n\n        code = fragment.charCodeAt(8);\n        return code === 0x28\n        /* '(' */\n        || esutils.code.isWhiteSpace(code) || code === 0x2A\n        /* '*' */\n        || esutils.code.isLineTerminator(code);\n      }\n\n      function isAsyncPrefixed(fragment) {\n        var code, i, iz;\n\n        if (fragment.slice(0, 5) !== 'async') {\n          return false;\n        }\n\n        if (!esutils.code.isWhiteSpace(fragment.charCodeAt(5))) {\n          return false;\n        }\n\n        for (i = 6, iz = fragment.length; i < iz; ++i) {\n          if (!esutils.code.isWhiteSpace(fragment.charCodeAt(i))) {\n            break;\n          }\n        }\n\n        if (i === iz) {\n          return false;\n        }\n\n        if (fragment.slice(i, i + 8) !== 'function') {\n          return false;\n        }\n\n        code = fragment.charCodeAt(i + 8);\n        return code === 0x28\n        /* '(' */\n        || esutils.code.isWhiteSpace(code) || code === 0x2A\n        /* '*' */\n        || esutils.code.isLineTerminator(code);\n      }\n\n      result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)]; // 12.4 '{', 'function', 'class' is not allowed in this position.\n      // wrap expression with parentheses\n\n      fragment = toSourceNodeWhenNeeded(result).toString();\n\n      if (fragment.charCodeAt(0) === 0x7B\n      /* '{' */\n      || // ObjectExpression\n      isClassPrefixed(fragment) || isFunctionPrefixed(fragment) || isAsyncPrefixed(fragment) || directive && flags & F_DIRECTIVE_CTX && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string') {\n        result = ['(', result, ')' + this.semicolon(flags)];\n      } else {\n        result.push(this.semicolon(flags));\n      }\n\n      return result;\n    },\n    ImportDeclaration: function (stmt, flags) {\n      // ES6: 15.2.1 valid import declarations:\n      //     - import ImportClause FromClause ;\n      //     - import ModuleSpecifier ;\n      var result,\n          cursor,\n          that = this; // If no ImportClause is present,\n      // this should be `import ModuleSpecifier` so skip `from`\n      // ModuleSpecifier is StringLiteral.\n\n      if (stmt.specifiers.length === 0) {\n        // import ModuleSpecifier ;\n        return ['import', space, // ModuleSpecifier\n        this.generateExpression(stmt.source, Precedence.Sequence, E_TTT), this.semicolon(flags)];\n      } // import ImportClause FromClause ;\n\n\n      result = ['import'];\n      cursor = 0; // ImportedBinding\n\n      if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {\n        result = join(result, [this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)]);\n        ++cursor;\n      }\n\n      if (stmt.specifiers[cursor]) {\n        if (cursor !== 0) {\n          result.push(',');\n        }\n\n        if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {\n          // NameSpaceImport\n          result = join(result, [space, this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)]);\n        } else {\n          // NamedImports\n          result.push(space + '{');\n\n          if (stmt.specifiers.length - cursor === 1) {\n            // import { ... } from \"...\";\n            result.push(space);\n            result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));\n            result.push(space + '}' + space);\n          } else {\n            // import {\n            //    ...,\n            //    ...,\n            // } from \"...\";\n            withIndent(function (indent) {\n              var i, iz;\n              result.push(newline);\n\n              for (i = cursor, iz = stmt.specifiers.length; i < iz; ++i) {\n                result.push(indent);\n                result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));\n\n                if (i + 1 < iz) {\n                  result.push(',' + newline);\n                }\n              }\n            });\n\n            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n              result.push(newline);\n            }\n\n            result.push(base + '}' + space);\n          }\n        }\n      }\n\n      result = join(result, ['from' + space, // ModuleSpecifier\n      this.generateExpression(stmt.source, Precedence.Sequence, E_TTT), this.semicolon(flags)]);\n      return result;\n    },\n    VariableDeclarator: function (stmt, flags) {\n      var itemFlags = flags & F_ALLOW_IN ? E_TTT : E_FTT;\n\n      if (stmt.init) {\n        return [this.generateExpression(stmt.id, Precedence.Assignment, itemFlags), space, '=', space, this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)];\n      }\n\n      return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);\n    },\n    VariableDeclaration: function (stmt, flags) {\n      // VariableDeclarator is typed as Statement,\n      // but joined with comma (not LineTerminator).\n      // So if comment is attached to target node, we should specialize.\n      var result,\n          i,\n          iz,\n          node,\n          bodyFlags,\n          that = this;\n      result = [stmt.kind];\n      bodyFlags = flags & F_ALLOW_IN ? S_TFFF : S_FFFF;\n\n      function block() {\n        node = stmt.declarations[0];\n\n        if (extra.comment && node.leadingComments) {\n          result.push('\\n');\n          result.push(addIndent(that.generateStatement(node, bodyFlags)));\n        } else {\n          result.push(noEmptySpace());\n          result.push(that.generateStatement(node, bodyFlags));\n        }\n\n        for (i = 1, iz = stmt.declarations.length; i < iz; ++i) {\n          node = stmt.declarations[i];\n\n          if (extra.comment && node.leadingComments) {\n            result.push(',' + newline);\n            result.push(addIndent(that.generateStatement(node, bodyFlags)));\n          } else {\n            result.push(',' + space);\n            result.push(that.generateStatement(node, bodyFlags));\n          }\n        }\n      }\n\n      if (stmt.declarations.length > 1) {\n        withIndent(block);\n      } else {\n        block();\n      }\n\n      result.push(this.semicolon(flags));\n      return result;\n    },\n    ThrowStatement: function (stmt, flags) {\n      return [join('throw', this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)), this.semicolon(flags)];\n    },\n    TryStatement: function (stmt, flags) {\n      var result, i, iz, guardedHandlers;\n      result = ['try', this.maybeBlock(stmt.block, S_TFFF)];\n      result = this.maybeBlockSuffix(stmt.block, result);\n\n      if (stmt.handlers) {\n        // old interface\n        for (i = 0, iz = stmt.handlers.length; i < iz; ++i) {\n          result = join(result, this.generateStatement(stmt.handlers[i], S_TFFF));\n\n          if (stmt.finalizer || i + 1 !== iz) {\n            result = this.maybeBlockSuffix(stmt.handlers[i].body, result);\n          }\n        }\n      } else {\n        guardedHandlers = stmt.guardedHandlers || [];\n\n        for (i = 0, iz = guardedHandlers.length; i < iz; ++i) {\n          result = join(result, this.generateStatement(guardedHandlers[i], S_TFFF));\n\n          if (stmt.finalizer || i + 1 !== iz) {\n            result = this.maybeBlockSuffix(guardedHandlers[i].body, result);\n          }\n        } // new interface\n\n\n        if (stmt.handler) {\n          if (Array.isArray(stmt.handler)) {\n            for (i = 0, iz = stmt.handler.length; i < iz; ++i) {\n              result = join(result, this.generateStatement(stmt.handler[i], S_TFFF));\n\n              if (stmt.finalizer || i + 1 !== iz) {\n                result = this.maybeBlockSuffix(stmt.handler[i].body, result);\n              }\n            }\n          } else {\n            result = join(result, this.generateStatement(stmt.handler, S_TFFF));\n\n            if (stmt.finalizer) {\n              result = this.maybeBlockSuffix(stmt.handler.body, result);\n            }\n          }\n        }\n      }\n\n      if (stmt.finalizer) {\n        result = join(result, ['finally', this.maybeBlock(stmt.finalizer, S_TFFF)]);\n      }\n\n      return result;\n    },\n    SwitchStatement: function (stmt, flags) {\n      var result,\n          fragment,\n          i,\n          iz,\n          bodyFlags,\n          that = this;\n      withIndent(function () {\n        result = ['switch' + space + '(', that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT), ')' + space + '{' + newline];\n      });\n\n      if (stmt.cases) {\n        bodyFlags = S_TFFF;\n\n        for (i = 0, iz = stmt.cases.length; i < iz; ++i) {\n          if (i === iz - 1) {\n            bodyFlags |= F_SEMICOLON_OPT;\n          }\n\n          fragment = addIndent(this.generateStatement(stmt.cases[i], bodyFlags));\n          result.push(fragment);\n\n          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n            result.push(newline);\n          }\n        }\n      }\n\n      result.push(addIndent('}'));\n      return result;\n    },\n    SwitchCase: function (stmt, flags) {\n      var result,\n          fragment,\n          i,\n          iz,\n          bodyFlags,\n          that = this;\n      withIndent(function () {\n        if (stmt.test) {\n          result = [join('case', that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)), ':'];\n        } else {\n          result = ['default:'];\n        }\n\n        i = 0;\n        iz = stmt.consequent.length;\n\n        if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {\n          fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);\n          result.push(fragment);\n          i = 1;\n        }\n\n        if (i !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n          result.push(newline);\n        }\n\n        bodyFlags = S_TFFF;\n\n        for (; i < iz; ++i) {\n          if (i === iz - 1 && flags & F_SEMICOLON_OPT) {\n            bodyFlags |= F_SEMICOLON_OPT;\n          }\n\n          fragment = addIndent(that.generateStatement(stmt.consequent[i], bodyFlags));\n          result.push(fragment);\n\n          if (i + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n            result.push(newline);\n          }\n        }\n      });\n      return result;\n    },\n    IfStatement: function (stmt, flags) {\n      var result,\n          bodyFlags,\n          semicolonOptional,\n          that = this;\n      withIndent(function () {\n        result = ['if' + space + '(', that.generateExpression(stmt.test, Precedence.Sequence, E_TTT), ')'];\n      });\n      semicolonOptional = flags & F_SEMICOLON_OPT;\n      bodyFlags = S_TFFF;\n\n      if (semicolonOptional) {\n        bodyFlags |= F_SEMICOLON_OPT;\n      }\n\n      if (stmt.alternate) {\n        result.push(this.maybeBlock(stmt.consequent, S_TFFF));\n        result = this.maybeBlockSuffix(stmt.consequent, result);\n\n        if (stmt.alternate.type === Syntax.IfStatement) {\n          result = join(result, ['else ', this.generateStatement(stmt.alternate, bodyFlags)]);\n        } else {\n          result = join(result, join('else', this.maybeBlock(stmt.alternate, bodyFlags)));\n        }\n      } else {\n        result.push(this.maybeBlock(stmt.consequent, bodyFlags));\n      }\n\n      return result;\n    },\n    ForStatement: function (stmt, flags) {\n      var result,\n          that = this;\n      withIndent(function () {\n        result = ['for' + space + '('];\n\n        if (stmt.init) {\n          if (stmt.init.type === Syntax.VariableDeclaration) {\n            result.push(that.generateStatement(stmt.init, S_FFFF));\n          } else {\n            // F_ALLOW_IN becomes false.\n            result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));\n            result.push(';');\n          }\n        } else {\n          result.push(';');\n        }\n\n        if (stmt.test) {\n          result.push(space);\n          result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));\n          result.push(';');\n        } else {\n          result.push(';');\n        }\n\n        if (stmt.update) {\n          result.push(space);\n          result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));\n          result.push(')');\n        } else {\n          result.push(')');\n        }\n      });\n      result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\n      return result;\n    },\n    ForInStatement: function (stmt, flags) {\n      return this.generateIterationForStatement('in', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);\n    },\n    ForOfStatement: function (stmt, flags) {\n      return this.generateIterationForStatement('of', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);\n    },\n    LabeledStatement: function (stmt, flags) {\n      return [stmt.label.name + ':', this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)];\n    },\n    Program: function (stmt, flags) {\n      var result, fragment, i, iz, bodyFlags;\n      iz = stmt.body.length;\n      result = [safeConcatenation && iz > 0 ? '\\n' : ''];\n      bodyFlags = S_TFTF;\n\n      for (i = 0; i < iz; ++i) {\n        if (!safeConcatenation && i === iz - 1) {\n          bodyFlags |= F_SEMICOLON_OPT;\n        }\n\n        if (preserveBlankLines) {\n          // handle spaces before the first line\n          if (i === 0) {\n            if (!stmt.body[0].leadingComments) {\n              generateBlankLines(stmt.range[0], stmt.body[i].range[0], result);\n            }\n          } // handle spaces between lines\n\n\n          if (i > 0) {\n            if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {\n              generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);\n            }\n          }\n        }\n\n        fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));\n        result.push(fragment);\n\n        if (i + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n          if (preserveBlankLines) {\n            if (!stmt.body[i + 1].leadingComments) {\n              result.push(newline);\n            }\n          } else {\n            result.push(newline);\n          }\n        }\n\n        if (preserveBlankLines) {\n          // handle spaces after the last line\n          if (i === iz - 1) {\n            if (!stmt.body[i].trailingComments) {\n              generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);\n            }\n          }\n        }\n      }\n\n      return result;\n    },\n    FunctionDeclaration: function (stmt, flags) {\n      return [generateAsyncPrefix(stmt, true), 'function', generateStarSuffix(stmt) || noEmptySpace(), stmt.id ? generateIdentifier(stmt.id) : '', this.generateFunctionBody(stmt)];\n    },\n    ReturnStatement: function (stmt, flags) {\n      if (stmt.argument) {\n        return [join('return', this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)), this.semicolon(flags)];\n      }\n\n      return ['return' + this.semicolon(flags)];\n    },\n    WhileStatement: function (stmt, flags) {\n      var result,\n          that = this;\n      withIndent(function () {\n        result = ['while' + space + '(', that.generateExpression(stmt.test, Precedence.Sequence, E_TTT), ')'];\n      });\n      result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\n      return result;\n    },\n    WithStatement: function (stmt, flags) {\n      var result,\n          that = this;\n      withIndent(function () {\n        result = ['with' + space + '(', that.generateExpression(stmt.object, Precedence.Sequence, E_TTT), ')'];\n      });\n      result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\n      return result;\n    }\n  };\n  merge(CodeGenerator.prototype, CodeGenerator.Statement); // Expressions.\n\n  CodeGenerator.Expression = {\n    SequenceExpression: function (expr, precedence, flags) {\n      var result, i, iz;\n\n      if (Precedence.Sequence < precedence) {\n        flags |= F_ALLOW_IN;\n      }\n\n      result = [];\n\n      for (i = 0, iz = expr.expressions.length; i < iz; ++i) {\n        result.push(this.generateExpression(expr.expressions[i], Precedence.Assignment, flags));\n\n        if (i + 1 < iz) {\n          result.push(',' + space);\n        }\n      }\n\n      return parenthesize(result, Precedence.Sequence, precedence);\n    },\n    AssignmentExpression: function (expr, precedence, flags) {\n      return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);\n    },\n    ArrowFunctionExpression: function (expr, precedence, flags) {\n      return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);\n    },\n    ConditionalExpression: function (expr, precedence, flags) {\n      if (Precedence.Conditional < precedence) {\n        flags |= F_ALLOW_IN;\n      }\n\n      return parenthesize([this.generateExpression(expr.test, Precedence.LogicalOR, flags), space + '?' + space, this.generateExpression(expr.consequent, Precedence.Assignment, flags), space + ':' + space, this.generateExpression(expr.alternate, Precedence.Assignment, flags)], Precedence.Conditional, precedence);\n    },\n    LogicalExpression: function (expr, precedence, flags) {\n      return this.BinaryExpression(expr, precedence, flags);\n    },\n    BinaryExpression: function (expr, precedence, flags) {\n      var result, leftPrecedence, rightPrecedence, currentPrecedence, fragment, leftSource;\n      currentPrecedence = BinaryPrecedence[expr.operator];\n      leftPrecedence = expr.operator === '**' ? Precedence.Postfix : currentPrecedence;\n      rightPrecedence = expr.operator === '**' ? currentPrecedence : currentPrecedence + 1;\n\n      if (currentPrecedence < precedence) {\n        flags |= F_ALLOW_IN;\n      }\n\n      fragment = this.generateExpression(expr.left, leftPrecedence, flags);\n      leftSource = fragment.toString();\n\n      if (leftSource.charCodeAt(leftSource.length - 1) === 0x2F\n      /* / */\n      && esutils.code.isIdentifierPartES5(expr.operator.charCodeAt(0))) {\n        result = [fragment, noEmptySpace(), expr.operator];\n      } else {\n        result = join(fragment, expr.operator);\n      }\n\n      fragment = this.generateExpression(expr.right, rightPrecedence, flags);\n\n      if (expr.operator === '/' && fragment.toString().charAt(0) === '/' || expr.operator.slice(-1) === '<' && fragment.toString().slice(0, 3) === '!--') {\n        // If '/' concats with '/' or `<` concats with `!--`, it is interpreted as comment start\n        result.push(noEmptySpace());\n        result.push(fragment);\n      } else {\n        result = join(result, fragment);\n      }\n\n      if (expr.operator === 'in' && !(flags & F_ALLOW_IN)) {\n        return ['(', result, ')'];\n      }\n\n      return parenthesize(result, currentPrecedence, precedence);\n    },\n    CallExpression: function (expr, precedence, flags) {\n      var result, i, iz; // F_ALLOW_UNPARATH_NEW becomes false.\n\n      result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];\n\n      if (expr.optional) {\n        result.push('?.');\n      }\n\n      result.push('(');\n\n      for (i = 0, iz = expr['arguments'].length; i < iz; ++i) {\n        result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));\n\n        if (i + 1 < iz) {\n          result.push(',' + space);\n        }\n      }\n\n      result.push(')');\n\n      if (!(flags & F_ALLOW_CALL)) {\n        return ['(', result, ')'];\n      }\n\n      return parenthesize(result, Precedence.Call, precedence);\n    },\n    ChainExpression: function (expr, precedence, flags) {\n      if (Precedence.OptionalChaining < precedence) {\n        flags |= F_ALLOW_CALL;\n      }\n\n      var result = this.generateExpression(expr.expression, Precedence.OptionalChaining, flags);\n      return parenthesize(result, Precedence.OptionalChaining, precedence);\n    },\n    NewExpression: function (expr, precedence, flags) {\n      var result, length, i, iz, itemFlags;\n      length = expr['arguments'].length; // F_ALLOW_CALL becomes false.\n      // F_ALLOW_UNPARATH_NEW may become false.\n\n      itemFlags = flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0 ? E_TFT : E_TFF;\n      result = join('new', this.generateExpression(expr.callee, Precedence.New, itemFlags));\n\n      if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {\n        result.push('(');\n\n        for (i = 0, iz = length; i < iz; ++i) {\n          result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));\n\n          if (i + 1 < iz) {\n            result.push(',' + space);\n          }\n        }\n\n        result.push(')');\n      }\n\n      return parenthesize(result, Precedence.New, precedence);\n    },\n    MemberExpression: function (expr, precedence, flags) {\n      var result, fragment; // F_ALLOW_UNPARATH_NEW becomes false.\n\n      result = [this.generateExpression(expr.object, Precedence.Call, flags & F_ALLOW_CALL ? E_TTF : E_TFF)];\n\n      if (expr.computed) {\n        if (expr.optional) {\n          result.push('?.');\n        }\n\n        result.push('[');\n        result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));\n        result.push(']');\n      } else {\n        if (!expr.optional && expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {\n          fragment = toSourceNodeWhenNeeded(result).toString(); // When the following conditions are all true,\n          //   1. No floating point\n          //   2. Don't have exponents\n          //   3. The last character is a decimal digit\n          //   4. Not hexadecimal OR octal number literal\n          // we should add a floating point.\n\n          if (fragment.indexOf('.') < 0 && !/[eExX]/.test(fragment) && esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) && !(fragment.length >= 2 && fragment.charCodeAt(0) === 48) // '0'\n          ) {\n            result.push(' ');\n          }\n        }\n\n        result.push(expr.optional ? '?.' : '.');\n        result.push(generateIdentifier(expr.property));\n      }\n\n      return parenthesize(result, Precedence.Member, precedence);\n    },\n    MetaProperty: function (expr, precedence, flags) {\n      var result;\n      result = [];\n      result.push(typeof expr.meta === \"string\" ? expr.meta : generateIdentifier(expr.meta));\n      result.push('.');\n      result.push(typeof expr.property === \"string\" ? expr.property : generateIdentifier(expr.property));\n      return parenthesize(result, Precedence.Member, precedence);\n    },\n    UnaryExpression: function (expr, precedence, flags) {\n      var result, fragment, rightCharCode, leftSource, leftCharCode;\n      fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);\n\n      if (space === '') {\n        result = join(expr.operator, fragment);\n      } else {\n        result = [expr.operator];\n\n        if (expr.operator.length > 2) {\n          // delete, void, typeof\n          // get `typeof []`, not `typeof[]`\n          result = join(result, fragment);\n        } else {\n          // Prevent inserting spaces between operator and argument if it is unnecessary\n          // like, `!cond`\n          leftSource = toSourceNodeWhenNeeded(result).toString();\n          leftCharCode = leftSource.charCodeAt(leftSource.length - 1);\n          rightCharCode = fragment.toString().charCodeAt(0);\n\n          if ((leftCharCode === 0x2B\n          /* + */\n          || leftCharCode === 0x2D\n          /* - */\n          ) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode)) {\n            result.push(noEmptySpace());\n            result.push(fragment);\n          } else {\n            result.push(fragment);\n          }\n        }\n      }\n\n      return parenthesize(result, Precedence.Unary, precedence);\n    },\n    YieldExpression: function (expr, precedence, flags) {\n      var result;\n\n      if (expr.delegate) {\n        result = 'yield*';\n      } else {\n        result = 'yield';\n      }\n\n      if (expr.argument) {\n        result = join(result, this.generateExpression(expr.argument, Precedence.Yield, E_TTT));\n      }\n\n      return parenthesize(result, Precedence.Yield, precedence);\n    },\n    AwaitExpression: function (expr, precedence, flags) {\n      var result = join(expr.all ? 'await*' : 'await', this.generateExpression(expr.argument, Precedence.Await, E_TTT));\n      return parenthesize(result, Precedence.Await, precedence);\n    },\n    UpdateExpression: function (expr, precedence, flags) {\n      if (expr.prefix) {\n        return parenthesize([expr.operator, this.generateExpression(expr.argument, Precedence.Unary, E_TTT)], Precedence.Unary, precedence);\n      }\n\n      return parenthesize([this.generateExpression(expr.argument, Precedence.Postfix, E_TTT), expr.operator], Precedence.Postfix, precedence);\n    },\n    FunctionExpression: function (expr, precedence, flags) {\n      var result = [generateAsyncPrefix(expr, true), 'function'];\n\n      if (expr.id) {\n        result.push(generateStarSuffix(expr) || noEmptySpace());\n        result.push(generateIdentifier(expr.id));\n      } else {\n        result.push(generateStarSuffix(expr) || space);\n      }\n\n      result.push(this.generateFunctionBody(expr));\n      return result;\n    },\n    ArrayPattern: function (expr, precedence, flags) {\n      return this.ArrayExpression(expr, precedence, flags, true);\n    },\n    ArrayExpression: function (expr, precedence, flags, isPattern) {\n      var result,\n          multiline,\n          that = this;\n\n      if (!expr.elements.length) {\n        return '[]';\n      }\n\n      multiline = isPattern ? false : expr.elements.length > 1;\n      result = ['[', multiline ? newline : ''];\n      withIndent(function (indent) {\n        var i, iz;\n\n        for (i = 0, iz = expr.elements.length; i < iz; ++i) {\n          if (!expr.elements[i]) {\n            if (multiline) {\n              result.push(indent);\n            }\n\n            if (i + 1 === iz) {\n              result.push(',');\n            }\n          } else {\n            result.push(multiline ? indent : '');\n            result.push(that.generateExpression(expr.elements[i], Precedence.Assignment, E_TTT));\n          }\n\n          if (i + 1 < iz) {\n            result.push(',' + (multiline ? newline : space));\n          }\n        }\n      });\n\n      if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n        result.push(newline);\n      }\n\n      result.push(multiline ? base : '');\n      result.push(']');\n      return result;\n    },\n    RestElement: function (expr, precedence, flags) {\n      return '...' + this.generatePattern(expr.argument);\n    },\n    ClassExpression: function (expr, precedence, flags) {\n      var result, fragment;\n      result = ['class'];\n\n      if (expr.id) {\n        result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));\n      }\n\n      if (expr.superClass) {\n        fragment = join('extends', this.generateExpression(expr.superClass, Precedence.Unary, E_TTT));\n        result = join(result, fragment);\n      }\n\n      result.push(space);\n      result.push(this.generateStatement(expr.body, S_TFFT));\n      return result;\n    },\n    MethodDefinition: function (expr, precedence, flags) {\n      var result, fragment;\n\n      if (expr['static']) {\n        result = ['static' + space];\n      } else {\n        result = [];\n      }\n\n      if (expr.kind === 'get' || expr.kind === 'set') {\n        fragment = [join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)), this.generateFunctionBody(expr.value)];\n      } else {\n        fragment = [generateMethodPrefix(expr), this.generatePropertyKey(expr.key, expr.computed), this.generateFunctionBody(expr.value)];\n      }\n\n      return join(result, fragment);\n    },\n    Property: function (expr, precedence, flags) {\n      if (expr.kind === 'get' || expr.kind === 'set') {\n        return [expr.kind, noEmptySpace(), this.generatePropertyKey(expr.key, expr.computed), this.generateFunctionBody(expr.value)];\n      }\n\n      if (expr.shorthand) {\n        if (expr.value.type === \"AssignmentPattern\") {\n          return this.AssignmentPattern(expr.value, Precedence.Sequence, E_TTT);\n        }\n\n        return this.generatePropertyKey(expr.key, expr.computed);\n      }\n\n      if (expr.method) {\n        return [generateMethodPrefix(expr), this.generatePropertyKey(expr.key, expr.computed), this.generateFunctionBody(expr.value)];\n      }\n\n      return [this.generatePropertyKey(expr.key, expr.computed), ':' + space, this.generateExpression(expr.value, Precedence.Assignment, E_TTT)];\n    },\n    ObjectExpression: function (expr, precedence, flags) {\n      var multiline,\n          result,\n          fragment,\n          that = this;\n\n      if (!expr.properties.length) {\n        return '{}';\n      }\n\n      multiline = expr.properties.length > 1;\n      withIndent(function () {\n        fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);\n      });\n\n      if (!multiline) {\n        // issues 4\n        // Do not transform from\n        //   dejavu.Class.declare({\n        //       method2: function () {}\n        //   });\n        // to\n        //   dejavu.Class.declare({method2: function () {\n        //       }});\n        if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n          return ['{', space, fragment, space, '}'];\n        }\n      }\n\n      withIndent(function (indent) {\n        var i, iz;\n        result = ['{', newline, indent, fragment];\n\n        if (multiline) {\n          result.push(',' + newline);\n\n          for (i = 1, iz = expr.properties.length; i < iz; ++i) {\n            result.push(indent);\n            result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));\n\n            if (i + 1 < iz) {\n              result.push(',' + newline);\n            }\n          }\n        }\n      });\n\n      if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n        result.push(newline);\n      }\n\n      result.push(base);\n      result.push('}');\n      return result;\n    },\n    AssignmentPattern: function (expr, precedence, flags) {\n      return this.generateAssignment(expr.left, expr.right, '=', precedence, flags);\n    },\n    ObjectPattern: function (expr, precedence, flags) {\n      var result,\n          i,\n          iz,\n          multiline,\n          property,\n          that = this;\n\n      if (!expr.properties.length) {\n        return '{}';\n      }\n\n      multiline = false;\n\n      if (expr.properties.length === 1) {\n        property = expr.properties[0];\n\n        if (property.type === Syntax.Property && property.value.type !== Syntax.Identifier) {\n          multiline = true;\n        }\n      } else {\n        for (i = 0, iz = expr.properties.length; i < iz; ++i) {\n          property = expr.properties[i];\n\n          if (property.type === Syntax.Property && !property.shorthand) {\n            multiline = true;\n            break;\n          }\n        }\n      }\n\n      result = ['{', multiline ? newline : ''];\n      withIndent(function (indent) {\n        var i, iz;\n\n        for (i = 0, iz = expr.properties.length; i < iz; ++i) {\n          result.push(multiline ? indent : '');\n          result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));\n\n          if (i + 1 < iz) {\n            result.push(',' + (multiline ? newline : space));\n          }\n        }\n      });\n\n      if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n        result.push(newline);\n      }\n\n      result.push(multiline ? base : '');\n      result.push('}');\n      return result;\n    },\n    ThisExpression: function (expr, precedence, flags) {\n      return 'this';\n    },\n    Super: function (expr, precedence, flags) {\n      return 'super';\n    },\n    Identifier: function (expr, precedence, flags) {\n      return generateIdentifier(expr);\n    },\n    ImportDefaultSpecifier: function (expr, precedence, flags) {\n      return generateIdentifier(expr.id || expr.local);\n    },\n    ImportNamespaceSpecifier: function (expr, precedence, flags) {\n      var result = ['*'];\n      var id = expr.id || expr.local;\n\n      if (id) {\n        result.push(space + 'as' + noEmptySpace() + generateIdentifier(id));\n      }\n\n      return result;\n    },\n    ImportSpecifier: function (expr, precedence, flags) {\n      var imported = expr.imported;\n      var result = [imported.name];\n      var local = expr.local;\n\n      if (local && local.name !== imported.name) {\n        result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(local));\n      }\n\n      return result;\n    },\n    ExportSpecifier: function (expr, precedence, flags) {\n      var local = expr.local;\n      var result = [local.name];\n      var exported = expr.exported;\n\n      if (exported && exported.name !== local.name) {\n        result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(exported));\n      }\n\n      return result;\n    },\n    Literal: function (expr, precedence, flags) {\n      var raw;\n\n      if (expr.hasOwnProperty('raw') && parse && extra.raw) {\n        try {\n          raw = parse(expr.raw).body[0].expression;\n\n          if (raw.type === Syntax.Literal) {\n            if (raw.value === expr.value) {\n              return expr.raw;\n            }\n          }\n        } catch (e) {// not use raw property\n        }\n      }\n\n      if (expr.regex) {\n        return '/' + expr.regex.pattern + '/' + expr.regex.flags;\n      }\n\n      if (expr.value === null) {\n        return 'null';\n      }\n\n      if (typeof expr.value === 'string') {\n        return escapeString(expr.value);\n      }\n\n      if (typeof expr.value === 'number') {\n        return generateNumber(expr.value);\n      }\n\n      if (typeof expr.value === 'boolean') {\n        return expr.value ? 'true' : 'false';\n      }\n\n      return generateRegExp(expr.value);\n    },\n    GeneratorExpression: function (expr, precedence, flags) {\n      return this.ComprehensionExpression(expr, precedence, flags);\n    },\n    ComprehensionExpression: function (expr, precedence, flags) {\n      // GeneratorExpression should be parenthesized with (...), ComprehensionExpression with [...]\n      // Due to https://bugzilla.mozilla.org/show_bug.cgi?id=883468 position of expr.body can differ in Spidermonkey and ES6\n      var result,\n          i,\n          iz,\n          fragment,\n          that = this;\n      result = expr.type === Syntax.GeneratorExpression ? ['('] : ['['];\n\n      if (extra.moz.comprehensionExpressionStartsWithAssignment) {\n        fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);\n        result.push(fragment);\n      }\n\n      if (expr.blocks) {\n        withIndent(function () {\n          for (i = 0, iz = expr.blocks.length; i < iz; ++i) {\n            fragment = that.generateExpression(expr.blocks[i], Precedence.Sequence, E_TTT);\n\n            if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {\n              result = join(result, fragment);\n            } else {\n              result.push(fragment);\n            }\n          }\n        });\n      }\n\n      if (expr.filter) {\n        result = join(result, 'if' + space);\n        fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);\n        result = join(result, ['(', fragment, ')']);\n      }\n\n      if (!extra.moz.comprehensionExpressionStartsWithAssignment) {\n        fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);\n        result = join(result, fragment);\n      }\n\n      result.push(expr.type === Syntax.GeneratorExpression ? ')' : ']');\n      return result;\n    },\n    ComprehensionBlock: function (expr, precedence, flags) {\n      var fragment;\n\n      if (expr.left.type === Syntax.VariableDeclaration) {\n        fragment = [expr.left.kind, noEmptySpace(), this.generateStatement(expr.left.declarations[0], S_FFFF)];\n      } else {\n        fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);\n      }\n\n      fragment = join(fragment, expr.of ? 'of' : 'in');\n      fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));\n      return ['for' + space + '(', fragment, ')'];\n    },\n    SpreadElement: function (expr, precedence, flags) {\n      return ['...', this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)];\n    },\n    TaggedTemplateExpression: function (expr, precedence, flags) {\n      var itemFlags = E_TTF;\n\n      if (!(flags & F_ALLOW_CALL)) {\n        itemFlags = E_TFF;\n      }\n\n      var result = [this.generateExpression(expr.tag, Precedence.Call, itemFlags), this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)];\n      return parenthesize(result, Precedence.TaggedTemplate, precedence);\n    },\n    TemplateElement: function (expr, precedence, flags) {\n      // Don't use \"cooked\". Since tagged template can use raw template\n      // representation. So if we do so, it breaks the script semantics.\n      return expr.value.raw;\n    },\n    TemplateLiteral: function (expr, precedence, flags) {\n      var result, i, iz;\n      result = ['`'];\n\n      for (i = 0, iz = expr.quasis.length; i < iz; ++i) {\n        result.push(this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT));\n\n        if (i + 1 < iz) {\n          result.push('${' + space);\n          result.push(this.generateExpression(expr.expressions[i], Precedence.Sequence, E_TTT));\n          result.push(space + '}');\n        }\n      }\n\n      result.push('`');\n      return result;\n    },\n    ModuleSpecifier: function (expr, precedence, flags) {\n      return this.Literal(expr, precedence, flags);\n    },\n    ImportExpression: function (expr, precedence, flag) {\n      return parenthesize(['import(', this.generateExpression(expr.source, Precedence.Assignment, E_TTT), ')'], Precedence.Call, precedence);\n    }\n  };\n  merge(CodeGenerator.prototype, CodeGenerator.Expression);\n\n  CodeGenerator.prototype.generateExpression = function (expr, precedence, flags) {\n    var result, type;\n    type = expr.type || Syntax.Property;\n\n    if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {\n      return generateVerbatim(expr, precedence);\n    }\n\n    result = this[type](expr, precedence, flags);\n\n    if (extra.comment) {\n      result = addComments(expr, result);\n    }\n\n    return toSourceNodeWhenNeeded(result, expr);\n  };\n\n  CodeGenerator.prototype.generateStatement = function (stmt, flags) {\n    var result, fragment;\n    result = this[stmt.type](stmt, flags); // Attach comments\n\n    if (extra.comment) {\n      result = addComments(stmt, result);\n    }\n\n    fragment = toSourceNodeWhenNeeded(result).toString();\n\n    if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' && fragment.charAt(fragment.length - 1) === '\\n') {\n      result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\\s+$/, '') : fragment.replace(/\\s+$/, '');\n    }\n\n    return toSourceNodeWhenNeeded(result, stmt);\n  };\n\n  function generateInternal(node) {\n    var codegen;\n    codegen = new CodeGenerator();\n\n    if (isStatement(node)) {\n      return codegen.generateStatement(node, S_TFFF);\n    }\n\n    if (isExpression(node)) {\n      return codegen.generateExpression(node, Precedence.Sequence, E_TTT);\n    }\n\n    throw new Error('Unknown node type: ' + node.type);\n  }\n\n  function generate(node, options) {\n    var defaultOptions = getDefaultOptions(),\n        result,\n        pair;\n\n    if (options != null) {\n      // Obsolete options\n      //\n      //   `options.indent`\n      //   `options.base`\n      //\n      // Instead of them, we can use `option.format.indent`.\n      if (typeof options.indent === 'string') {\n        defaultOptions.format.indent.style = options.indent;\n      }\n\n      if (typeof options.base === 'number') {\n        defaultOptions.format.indent.base = options.base;\n      }\n\n      options = updateDeeply(defaultOptions, options);\n      indent = options.format.indent.style;\n\n      if (typeof options.base === 'string') {\n        base = options.base;\n      } else {\n        base = stringRepeat(indent, options.format.indent.base);\n      }\n    } else {\n      options = defaultOptions;\n      indent = options.format.indent.style;\n      base = stringRepeat(indent, options.format.indent.base);\n    }\n\n    json = options.format.json;\n    renumber = options.format.renumber;\n    hexadecimal = json ? false : options.format.hexadecimal;\n    quotes = json ? 'double' : options.format.quotes;\n    escapeless = options.format.escapeless;\n    newline = options.format.newline;\n    space = options.format.space;\n\n    if (options.format.compact) {\n      newline = space = indent = base = '';\n    }\n\n    parentheses = options.format.parentheses;\n    semicolons = options.format.semicolons;\n    safeConcatenation = options.format.safeConcatenation;\n    directive = options.directive;\n    parse = json ? null : options.parse;\n    sourceMap = options.sourceMap;\n    sourceCode = options.sourceCode;\n    preserveBlankLines = options.format.preserveBlankLines && sourceCode !== null;\n    extra = options;\n\n    if (sourceMap) {\n      if (!exports.browser) {\n        // We assume environment is node.js\n        // And prevent from including source-map by browserify\n        SourceNode = require('source-map').SourceNode;\n      } else {\n        SourceNode = global.sourceMap.SourceNode;\n      }\n    }\n\n    result = generateInternal(node);\n\n    if (!sourceMap) {\n      pair = {\n        code: result.toString(),\n        map: null\n      };\n      return options.sourceMapWithCode ? pair : pair.code;\n    }\n\n    pair = result.toStringWithSourceMap({\n      file: options.file,\n      sourceRoot: options.sourceMapRoot\n    });\n\n    if (options.sourceContent) {\n      pair.map.setSourceContent(options.sourceMap, options.sourceContent);\n    }\n\n    if (options.sourceMapWithCode) {\n      return pair;\n    }\n\n    return pair.map.toString();\n  }\n\n  FORMAT_MINIFY = {\n    indent: {\n      style: '',\n      base: 0\n    },\n    renumber: true,\n    hexadecimal: true,\n    quotes: 'auto',\n    escapeless: true,\n    compact: true,\n    parentheses: false,\n    semicolons: false\n  };\n  FORMAT_DEFAULTS = getDefaultOptions().format;\n  exports.version = require('./package.json').version;\n  exports.generate = generate;\n  exports.attachComments = estraverse.attachComments;\n  exports.Precedence = updateDeeply({}, Precedence);\n  exports.browser = false;\n  exports.FORMAT_MINIFY = FORMAT_MINIFY;\n  exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;\n})();\n/* vim: set sw=4 ts=4 et tw=80 : */","map":{"version":3,"names":["Syntax","Precedence","BinaryPrecedence","SourceNode","estraverse","esutils","base","indent","json","renumber","hexadecimal","quotes","escapeless","newline","space","parentheses","semicolons","safeConcatenation","directive","extra","parse","sourceMap","sourceCode","preserveBlankLines","FORMAT_MINIFY","FORMAT_DEFAULTS","require","isExpression","node","CodeGenerator","Expression","hasOwnProperty","type","isStatement","Statement","Sequence","Yield","Assignment","Conditional","ArrowFunction","LogicalOR","LogicalAND","BitwiseOR","BitwiseXOR","BitwiseAND","Equality","Relational","BitwiseSHIFT","Additive","Multiplicative","Exponentiation","Await","Unary","Postfix","OptionalChaining","Call","New","TaggedTemplate","Member","Primary","F_ALLOW_IN","F_ALLOW_CALL","F_ALLOW_UNPARATH_NEW","F_FUNC_BODY","F_DIRECTIVE_CTX","F_SEMICOLON_OPT","E_FTT","E_TTF","E_TTT","E_TFF","E_FFT","E_TFT","S_TFFF","S_TFFT","S_FFFF","S_TFTF","S_TTFF","getDefaultOptions","comment","format","style","adjustMultilineComment","compact","moz","comprehensionExpressionStartsWithAssignment","starlessGenerator","sourceMapRoot","sourceMapWithCode","raw","verbatim","stringRepeat","str","num","result","hasLineTerminator","test","endsWithLineTerminator","len","length","code","isLineTerminator","charCodeAt","merge","target","override","key","updateDeeply","val","isHashObject","Object","RegExp","generateNumber","value","point","temp","exponent","pos","Error","indexOf","slice","replace","Math","floor","toString","escapeRegExpCharacter","ch","previousIsBackslash","String","fromCharCode","generateRegExp","reg","match","flags","i","iz","characterInBrack","source","escapeAllowedCharacter","next","hex","toUpperCase","isDecimalDigit","escapeDisallowedCharacter","escapeDirective","quote","escapeString","singleQuotes","doubleQuotes","single","isIdentifierPartES5","flattenToString","arr","elem","Array","isArray","toSourceNodeWhenNeeded","generated","loc","name","start","line","column","noEmptySpace","join","left","right","leftSource","rightSource","leftCharCode","rightCharCode","isWhiteSpace","addIndent","stmt","withIndent","fn","previousBase","calculateSpaces","specialBase","array","j","spaces","sn","split","Number","MAX_VALUE","generateComment","addComments","save","tailingToStatement","fragment","extRange","range","prevRange","prefix","infix","suffix","count","leadingComments","extendedRange","substring","push","Program","body","trailingComments","generateBlankLines","end","newlineCount","parenthesize","text","current","should","generateVerbatimString","string","generateVerbatim","expr","precedence","prec","content","prototype","maybeBlock","noLeadingComment","that","BlockStatement","generateStatement","EmptyStatement","maybeBlockSuffix","ends","generateIdentifier","generateAsyncPrefix","spaceRequired","async","generateStarSuffix","isGenerator","generator","generateMethodPrefix","prop","func","computed","generatePattern","Identifier","generateExpression","generateFunctionParams","hasDefault","ArrowFunctionExpression","rest","defaults","params","generateAssignment","generateFunctionBody","expression","charAt","generateIterationForStatement","operator","await","VariableDeclaration","kind","declarations","generatePropertyKey","semicolon","bodyFlags","BreakStatement","label","ContinueStatement","ClassBody","ClassDeclaration","id","superClass","DirectiveStatement","DoWhileStatement","CatchClause","guard","param","splice","DebuggerStatement","ExportDefaultDeclaration","declaration","ExportNamedDeclaration","specifiers","ExportBatchSpecifier","ExportAllDeclaration","ExpressionStatement","isClassPrefixed","isFunctionPrefixed","isAsyncPrefixed","Literal","ImportDeclaration","cursor","ImportDefaultSpecifier","ImportNamespaceSpecifier","VariableDeclarator","itemFlags","init","block","ThrowStatement","argument","TryStatement","guardedHandlers","handlers","finalizer","handler","SwitchStatement","discriminant","cases","SwitchCase","consequent","IfStatement","semicolonOptional","alternate","ForStatement","update","ForInStatement","ForOfStatement","LabeledStatement","FunctionDeclaration","ReturnStatement","WhileStatement","WithStatement","object","SequenceExpression","expressions","AssignmentExpression","ConditionalExpression","LogicalExpression","BinaryExpression","leftPrecedence","rightPrecedence","currentPrecedence","CallExpression","callee","optional","ChainExpression","NewExpression","MemberExpression","property","MetaProperty","meta","UnaryExpression","YieldExpression","delegate","AwaitExpression","all","UpdateExpression","FunctionExpression","ArrayPattern","ArrayExpression","isPattern","multiline","elements","RestElement","ClassExpression","MethodDefinition","Property","shorthand","AssignmentPattern","method","ObjectExpression","properties","ObjectPattern","ThisExpression","Super","local","ImportSpecifier","imported","ExportSpecifier","exported","e","regex","pattern","GeneratorExpression","ComprehensionExpression","blocks","filter","ComprehensionBlock","of","SpreadElement","TaggedTemplateExpression","tag","quasi","TemplateElement","TemplateLiteral","quasis","ModuleSpecifier","ImportExpression","flag","replaceRight","generateInternal","codegen","generate","options","defaultOptions","pair","exports","browser","global","map","toStringWithSourceMap","file","sourceRoot","sourceContent","setSourceContent","version","attachComments"],"sources":["C:/Users/17033/balmco/node_modules/escodegen/escodegen.js"],"sourcesContent":["/*\n  Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2015 Ingvar Stepanyan <me@rreverser.com>\n  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>\n  Copyright (C) 2012-2013 Michael Ficarra <escodegen.copyright@michael.ficarra.me>\n  Copyright (C) 2012-2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2013 Irakli Gozalishvili <rfobic@gmail.com>\n  Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>\n  Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>\n  Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*global exports:true, require:true, global:true*/\n(function () {\n    'use strict';\n\n    var Syntax,\n        Precedence,\n        BinaryPrecedence,\n        SourceNode,\n        estraverse,\n        esutils,\n        base,\n        indent,\n        json,\n        renumber,\n        hexadecimal,\n        quotes,\n        escapeless,\n        newline,\n        space,\n        parentheses,\n        semicolons,\n        safeConcatenation,\n        directive,\n        extra,\n        parse,\n        sourceMap,\n        sourceCode,\n        preserveBlankLines,\n        FORMAT_MINIFY,\n        FORMAT_DEFAULTS;\n\n    estraverse = require('estraverse');\n    esutils = require('esutils');\n\n    Syntax = estraverse.Syntax;\n\n    // Generation is done by generateExpression.\n    function isExpression(node) {\n        return CodeGenerator.Expression.hasOwnProperty(node.type);\n    }\n\n    // Generation is done by generateStatement.\n    function isStatement(node) {\n        return CodeGenerator.Statement.hasOwnProperty(node.type);\n    }\n\n    Precedence = {\n        Sequence: 0,\n        Yield: 1,\n        Assignment: 1,\n        Conditional: 2,\n        ArrowFunction: 2,\n        LogicalOR: 3,\n        LogicalAND: 4,\n        BitwiseOR: 5,\n        BitwiseXOR: 6,\n        BitwiseAND: 7,\n        Equality: 8,\n        Relational: 9,\n        BitwiseSHIFT: 10,\n        Additive: 11,\n        Multiplicative: 12,\n        Exponentiation: 13,\n        Await: 14,\n        Unary: 14,\n        Postfix: 15,\n        OptionalChaining: 16,\n        Call: 17,\n        New: 18,\n        TaggedTemplate: 19,\n        Member: 20,\n        Primary: 21\n    };\n\n    BinaryPrecedence = {\n        '||': Precedence.LogicalOR,\n        '&&': Precedence.LogicalAND,\n        '|': Precedence.BitwiseOR,\n        '^': Precedence.BitwiseXOR,\n        '&': Precedence.BitwiseAND,\n        '==': Precedence.Equality,\n        '!=': Precedence.Equality,\n        '===': Precedence.Equality,\n        '!==': Precedence.Equality,\n        'is': Precedence.Equality,\n        'isnt': Precedence.Equality,\n        '<': Precedence.Relational,\n        '>': Precedence.Relational,\n        '<=': Precedence.Relational,\n        '>=': Precedence.Relational,\n        'in': Precedence.Relational,\n        'instanceof': Precedence.Relational,\n        '<<': Precedence.BitwiseSHIFT,\n        '>>': Precedence.BitwiseSHIFT,\n        '>>>': Precedence.BitwiseSHIFT,\n        '+': Precedence.Additive,\n        '-': Precedence.Additive,\n        '*': Precedence.Multiplicative,\n        '%': Precedence.Multiplicative,\n        '/': Precedence.Multiplicative,\n        '**': Precedence.Exponentiation\n    };\n\n    //Flags\n    var F_ALLOW_IN = 1,\n        F_ALLOW_CALL = 1 << 1,\n        F_ALLOW_UNPARATH_NEW = 1 << 2,\n        F_FUNC_BODY = 1 << 3,\n        F_DIRECTIVE_CTX = 1 << 4,\n        F_SEMICOLON_OPT = 1 << 5;\n\n    //Expression flag sets\n    //NOTE: Flag order:\n    // F_ALLOW_IN\n    // F_ALLOW_CALL\n    // F_ALLOW_UNPARATH_NEW\n    var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,\n        E_TTF = F_ALLOW_IN | F_ALLOW_CALL,\n        E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,\n        E_TFF = F_ALLOW_IN,\n        E_FFT = F_ALLOW_UNPARATH_NEW,\n        E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW;\n\n    //Statement flag sets\n    //NOTE: Flag order:\n    // F_ALLOW_IN\n    // F_FUNC_BODY\n    // F_DIRECTIVE_CTX\n    // F_SEMICOLON_OPT\n    var S_TFFF = F_ALLOW_IN,\n        S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT,\n        S_FFFF = 0x00,\n        S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX,\n        S_TTFF = F_ALLOW_IN | F_FUNC_BODY;\n\n    function getDefaultOptions() {\n        // default options\n        return {\n            indent: null,\n            base: null,\n            parse: null,\n            comment: false,\n            format: {\n                indent: {\n                    style: '    ',\n                    base: 0,\n                    adjustMultilineComment: false\n                },\n                newline: '\\n',\n                space: ' ',\n                json: false,\n                renumber: false,\n                hexadecimal: false,\n                quotes: 'single',\n                escapeless: false,\n                compact: false,\n                parentheses: true,\n                semicolons: true,\n                safeConcatenation: false,\n                preserveBlankLines: false\n            },\n            moz: {\n                comprehensionExpressionStartsWithAssignment: false,\n                starlessGenerator: false\n            },\n            sourceMap: null,\n            sourceMapRoot: null,\n            sourceMapWithCode: false,\n            directive: false,\n            raw: true,\n            verbatim: null,\n            sourceCode: null\n        };\n    }\n\n    function stringRepeat(str, num) {\n        var result = '';\n\n        for (num |= 0; num > 0; num >>>= 1, str += str) {\n            if (num & 1) {\n                result += str;\n            }\n        }\n\n        return result;\n    }\n\n    function hasLineTerminator(str) {\n        return (/[\\r\\n]/g).test(str);\n    }\n\n    function endsWithLineTerminator(str) {\n        var len = str.length;\n        return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));\n    }\n\n    function merge(target, override) {\n        var key;\n        for (key in override) {\n            if (override.hasOwnProperty(key)) {\n                target[key] = override[key];\n            }\n        }\n        return target;\n    }\n\n    function updateDeeply(target, override) {\n        var key, val;\n\n        function isHashObject(target) {\n            return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);\n        }\n\n        for (key in override) {\n            if (override.hasOwnProperty(key)) {\n                val = override[key];\n                if (isHashObject(val)) {\n                    if (isHashObject(target[key])) {\n                        updateDeeply(target[key], val);\n                    } else {\n                        target[key] = updateDeeply({}, val);\n                    }\n                } else {\n                    target[key] = val;\n                }\n            }\n        }\n        return target;\n    }\n\n    function generateNumber(value) {\n        var result, point, temp, exponent, pos;\n\n        if (value !== value) {\n            throw new Error('Numeric literal whose value is NaN');\n        }\n        if (value < 0 || (value === 0 && 1 / value < 0)) {\n            throw new Error('Numeric literal whose value is negative');\n        }\n\n        if (value === 1 / 0) {\n            return json ? 'null' : renumber ? '1e400' : '1e+400';\n        }\n\n        result = '' + value;\n        if (!renumber || result.length < 3) {\n            return result;\n        }\n\n        point = result.indexOf('.');\n        if (!json && result.charCodeAt(0) === 0x30  /* 0 */ && point === 1) {\n            point = 0;\n            result = result.slice(1);\n        }\n        temp = result;\n        result = result.replace('e+', 'e');\n        exponent = 0;\n        if ((pos = temp.indexOf('e')) > 0) {\n            exponent = +temp.slice(pos + 1);\n            temp = temp.slice(0, pos);\n        }\n        if (point >= 0) {\n            exponent -= temp.length - point - 1;\n            temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';\n        }\n        pos = 0;\n        while (temp.charCodeAt(temp.length + pos - 1) === 0x30  /* 0 */) {\n            --pos;\n        }\n        if (pos !== 0) {\n            exponent -= pos;\n            temp = temp.slice(0, pos);\n        }\n        if (exponent !== 0) {\n            temp += 'e' + exponent;\n        }\n        if ((temp.length < result.length ||\n                    (hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length)) &&\n                +temp === value) {\n            result = temp;\n        }\n\n        return result;\n    }\n\n    // Generate valid RegExp expression.\n    // This function is based on https://github.com/Constellation/iv Engine\n\n    function escapeRegExpCharacter(ch, previousIsBackslash) {\n        // not handling '\\' and handling \\u2028 or \\u2029 to unicode escape sequence\n        if ((ch & ~1) === 0x2028) {\n            return (previousIsBackslash ? 'u' : '\\\\u') + ((ch === 0x2028) ? '2028' : '2029');\n        } else if (ch === 10 || ch === 13) {  // \\n, \\r\n            return (previousIsBackslash ? '' : '\\\\') + ((ch === 10) ? 'n' : 'r');\n        }\n        return String.fromCharCode(ch);\n    }\n\n    function generateRegExp(reg) {\n        var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;\n\n        result = reg.toString();\n\n        if (reg.source) {\n            // extract flag from toString result\n            match = result.match(/\\/([^/]*)$/);\n            if (!match) {\n                return result;\n            }\n\n            flags = match[1];\n            result = '';\n\n            characterInBrack = false;\n            previousIsBackslash = false;\n            for (i = 0, iz = reg.source.length; i < iz; ++i) {\n                ch = reg.source.charCodeAt(i);\n\n                if (!previousIsBackslash) {\n                    if (characterInBrack) {\n                        if (ch === 93) {  // ]\n                            characterInBrack = false;\n                        }\n                    } else {\n                        if (ch === 47) {  // /\n                            result += '\\\\';\n                        } else if (ch === 91) {  // [\n                            characterInBrack = true;\n                        }\n                    }\n                    result += escapeRegExpCharacter(ch, previousIsBackslash);\n                    previousIsBackslash = ch === 92;  // \\\n                } else {\n                    // if new RegExp(\"\\\\\\n') is provided, create /\\n/\n                    result += escapeRegExpCharacter(ch, previousIsBackslash);\n                    // prevent like /\\\\[/]/\n                    previousIsBackslash = false;\n                }\n            }\n\n            return '/' + result + '/' + flags;\n        }\n\n        return result;\n    }\n\n    function escapeAllowedCharacter(code, next) {\n        var hex;\n\n        if (code === 0x08  /* \\b */) {\n            return '\\\\b';\n        }\n\n        if (code === 0x0C  /* \\f */) {\n            return '\\\\f';\n        }\n\n        if (code === 0x09  /* \\t */) {\n            return '\\\\t';\n        }\n\n        hex = code.toString(16).toUpperCase();\n        if (json || code > 0xFF) {\n            return '\\\\u' + '0000'.slice(hex.length) + hex;\n        } else if (code === 0x0000 && !esutils.code.isDecimalDigit(next)) {\n            return '\\\\0';\n        } else if (code === 0x000B  /* \\v */) { // '\\v'\n            return '\\\\x0B';\n        } else {\n            return '\\\\x' + '00'.slice(hex.length) + hex;\n        }\n    }\n\n    function escapeDisallowedCharacter(code) {\n        if (code === 0x5C  /* \\ */) {\n            return '\\\\\\\\';\n        }\n\n        if (code === 0x0A  /* \\n */) {\n            return '\\\\n';\n        }\n\n        if (code === 0x0D  /* \\r */) {\n            return '\\\\r';\n        }\n\n        if (code === 0x2028) {\n            return '\\\\u2028';\n        }\n\n        if (code === 0x2029) {\n            return '\\\\u2029';\n        }\n\n        throw new Error('Incorrectly classified character');\n    }\n\n    function escapeDirective(str) {\n        var i, iz, code, quote;\n\n        quote = quotes === 'double' ? '\"' : '\\'';\n        for (i = 0, iz = str.length; i < iz; ++i) {\n            code = str.charCodeAt(i);\n            if (code === 0x27  /* ' */) {\n                quote = '\"';\n                break;\n            } else if (code === 0x22  /* \" */) {\n                quote = '\\'';\n                break;\n            } else if (code === 0x5C  /* \\ */) {\n                ++i;\n            }\n        }\n\n        return quote + str + quote;\n    }\n\n    function escapeString(str) {\n        var result = '', i, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;\n\n        for (i = 0, len = str.length; i < len; ++i) {\n            code = str.charCodeAt(i);\n            if (code === 0x27  /* ' */) {\n                ++singleQuotes;\n            } else if (code === 0x22  /* \" */) {\n                ++doubleQuotes;\n            } else if (code === 0x2F  /* / */ && json) {\n                result += '\\\\';\n            } else if (esutils.code.isLineTerminator(code) || code === 0x5C  /* \\ */) {\n                result += escapeDisallowedCharacter(code);\n                continue;\n            } else if (!esutils.code.isIdentifierPartES5(code) && (json && code < 0x20  /* SP */ || !json && !escapeless && (code < 0x20  /* SP */ || code > 0x7E  /* ~ */))) {\n                result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));\n                continue;\n            }\n            result += String.fromCharCode(code);\n        }\n\n        single = !(quotes === 'double' || (quotes === 'auto' && doubleQuotes < singleQuotes));\n        quote = single ? '\\'' : '\"';\n\n        if (!(single ? singleQuotes : doubleQuotes)) {\n            return quote + result + quote;\n        }\n\n        str = result;\n        result = quote;\n\n        for (i = 0, len = str.length; i < len; ++i) {\n            code = str.charCodeAt(i);\n            if ((code === 0x27  /* ' */ && single) || (code === 0x22  /* \" */ && !single)) {\n                result += '\\\\';\n            }\n            result += String.fromCharCode(code);\n        }\n\n        return result + quote;\n    }\n\n    /**\n     * flatten an array to a string, where the array can contain\n     * either strings or nested arrays\n     */\n    function flattenToString(arr) {\n        var i, iz, elem, result = '';\n        for (i = 0, iz = arr.length; i < iz; ++i) {\n            elem = arr[i];\n            result += Array.isArray(elem) ? flattenToString(elem) : elem;\n        }\n        return result;\n    }\n\n    /**\n     * convert generated to a SourceNode when source maps are enabled.\n     */\n    function toSourceNodeWhenNeeded(generated, node) {\n        if (!sourceMap) {\n            // with no source maps, generated is either an\n            // array or a string.  if an array, flatten it.\n            // if a string, just return it\n            if (Array.isArray(generated)) {\n                return flattenToString(generated);\n            } else {\n                return generated;\n            }\n        }\n        if (node == null) {\n            if (generated instanceof SourceNode) {\n                return generated;\n            } else {\n                node = {};\n            }\n        }\n        if (node.loc == null) {\n            return new SourceNode(null, null, sourceMap, generated, node.name || null);\n        }\n        return new SourceNode(node.loc.start.line, node.loc.start.column, (sourceMap === true ? node.loc.source || null : sourceMap), generated, node.name || null);\n    }\n\n    function noEmptySpace() {\n        return (space) ? space : ' ';\n    }\n\n    function join(left, right) {\n        var leftSource,\n            rightSource,\n            leftCharCode,\n            rightCharCode;\n\n        leftSource = toSourceNodeWhenNeeded(left).toString();\n        if (leftSource.length === 0) {\n            return [right];\n        }\n\n        rightSource = toSourceNodeWhenNeeded(right).toString();\n        if (rightSource.length === 0) {\n            return [left];\n        }\n\n        leftCharCode = leftSource.charCodeAt(leftSource.length - 1);\n        rightCharCode = rightSource.charCodeAt(0);\n\n        if ((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode ||\n            esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode) ||\n            leftCharCode === 0x2F  /* / */ && rightCharCode === 0x69  /* i */) { // infix word operators all start with `i`\n            return [left, noEmptySpace(), right];\n        } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) ||\n                esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {\n            return [left, right];\n        }\n        return [left, space, right];\n    }\n\n    function addIndent(stmt) {\n        return [base, stmt];\n    }\n\n    function withIndent(fn) {\n        var previousBase;\n        previousBase = base;\n        base += indent;\n        fn(base);\n        base = previousBase;\n    }\n\n    function calculateSpaces(str) {\n        var i;\n        for (i = str.length - 1; i >= 0; --i) {\n            if (esutils.code.isLineTerminator(str.charCodeAt(i))) {\n                break;\n            }\n        }\n        return (str.length - 1) - i;\n    }\n\n    function adjustMultilineComment(value, specialBase) {\n        var array, i, len, line, j, spaces, previousBase, sn;\n\n        array = value.split(/\\r\\n|[\\r\\n]/);\n        spaces = Number.MAX_VALUE;\n\n        // first line doesn't have indentation\n        for (i = 1, len = array.length; i < len; ++i) {\n            line = array[i];\n            j = 0;\n            while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {\n                ++j;\n            }\n            if (spaces > j) {\n                spaces = j;\n            }\n        }\n\n        if (typeof specialBase !== 'undefined') {\n            // pattern like\n            // {\n            //   var t = 20;  /*\n            //                 * this is comment\n            //                 */\n            // }\n            previousBase = base;\n            if (array[1][spaces] === '*') {\n                specialBase += ' ';\n            }\n            base = specialBase;\n        } else {\n            if (spaces & 1) {\n                // /*\n                //  *\n                //  */\n                // If spaces are odd number, above pattern is considered.\n                // We waste 1 space.\n                --spaces;\n            }\n            previousBase = base;\n        }\n\n        for (i = 1, len = array.length; i < len; ++i) {\n            sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));\n            array[i] = sourceMap ? sn.join('') : sn;\n        }\n\n        base = previousBase;\n\n        return array.join('\\n');\n    }\n\n    function generateComment(comment, specialBase) {\n        if (comment.type === 'Line') {\n            if (endsWithLineTerminator(comment.value)) {\n                return '//' + comment.value;\n            } else {\n                // Always use LineTerminator\n                var result = '//' + comment.value;\n                if (!preserveBlankLines) {\n                    result += '\\n';\n                }\n                return result;\n            }\n        }\n        if (extra.format.indent.adjustMultilineComment && /[\\n\\r]/.test(comment.value)) {\n            return adjustMultilineComment('/*' + comment.value + '*/', specialBase);\n        }\n        return '/*' + comment.value + '*/';\n    }\n\n    function addComments(stmt, result) {\n        var i, len, comment, save, tailingToStatement, specialBase, fragment,\n            extRange, range, prevRange, prefix, infix, suffix, count;\n\n        if (stmt.leadingComments && stmt.leadingComments.length > 0) {\n            save = result;\n\n            if (preserveBlankLines) {\n                comment = stmt.leadingComments[0];\n                result = [];\n\n                extRange = comment.extendedRange;\n                range = comment.range;\n\n                prefix = sourceCode.substring(extRange[0], range[0]);\n                count = (prefix.match(/\\n/g) || []).length;\n                if (count > 0) {\n                    result.push(stringRepeat('\\n', count));\n                    result.push(addIndent(generateComment(comment)));\n                } else {\n                    result.push(prefix);\n                    result.push(generateComment(comment));\n                }\n\n                prevRange = range;\n\n                for (i = 1, len = stmt.leadingComments.length; i < len; i++) {\n                    comment = stmt.leadingComments[i];\n                    range = comment.range;\n\n                    infix = sourceCode.substring(prevRange[1], range[0]);\n                    count = (infix.match(/\\n/g) || []).length;\n                    result.push(stringRepeat('\\n', count));\n                    result.push(addIndent(generateComment(comment)));\n\n                    prevRange = range;\n                }\n\n                suffix = sourceCode.substring(range[1], extRange[1]);\n                count = (suffix.match(/\\n/g) || []).length;\n                result.push(stringRepeat('\\n', count));\n            } else {\n                comment = stmt.leadingComments[0];\n                result = [];\n                if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {\n                    result.push('\\n');\n                }\n                result.push(generateComment(comment));\n                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                    result.push('\\n');\n                }\n\n                for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {\n                    comment = stmt.leadingComments[i];\n                    fragment = [generateComment(comment)];\n                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                        fragment.push('\\n');\n                    }\n                    result.push(addIndent(fragment));\n                }\n            }\n\n            result.push(addIndent(save));\n        }\n\n        if (stmt.trailingComments) {\n\n            if (preserveBlankLines) {\n                comment = stmt.trailingComments[0];\n                extRange = comment.extendedRange;\n                range = comment.range;\n\n                prefix = sourceCode.substring(extRange[0], range[0]);\n                count = (prefix.match(/\\n/g) || []).length;\n\n                if (count > 0) {\n                    result.push(stringRepeat('\\n', count));\n                    result.push(addIndent(generateComment(comment)));\n                } else {\n                    result.push(prefix);\n                    result.push(generateComment(comment));\n                }\n            } else {\n                tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());\n                specialBase = stringRepeat(' ', calculateSpaces(toSourceNodeWhenNeeded([base, result, indent]).toString()));\n                for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {\n                    comment = stmt.trailingComments[i];\n                    if (tailingToStatement) {\n                        // We assume target like following script\n                        //\n                        // var t = 20;  /**\n                        //               * This is comment of t\n                        //               */\n                        if (i === 0) {\n                            // first case\n                            result = [result, indent];\n                        } else {\n                            result = [result, specialBase];\n                        }\n                        result.push(generateComment(comment, specialBase));\n                    } else {\n                        result = [result, addIndent(generateComment(comment))];\n                    }\n                    if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                        result = [result, '\\n'];\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    function generateBlankLines(start, end, result) {\n        var j, newlineCount = 0;\n\n        for (j = start; j < end; j++) {\n            if (sourceCode[j] === '\\n') {\n                newlineCount++;\n            }\n        }\n\n        for (j = 1; j < newlineCount; j++) {\n            result.push(newline);\n        }\n    }\n\n    function parenthesize(text, current, should) {\n        if (current < should) {\n            return ['(', text, ')'];\n        }\n        return text;\n    }\n\n    function generateVerbatimString(string) {\n        var i, iz, result;\n        result = string.split(/\\r\\n|\\n/);\n        for (i = 1, iz = result.length; i < iz; i++) {\n            result[i] = newline + base + result[i];\n        }\n        return result;\n    }\n\n    function generateVerbatim(expr, precedence) {\n        var verbatim, result, prec;\n        verbatim = expr[extra.verbatim];\n\n        if (typeof verbatim === 'string') {\n            result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);\n        } else {\n            // verbatim is object\n            result = generateVerbatimString(verbatim.content);\n            prec = (verbatim.precedence != null) ? verbatim.precedence : Precedence.Sequence;\n            result = parenthesize(result, prec, precedence);\n        }\n\n        return toSourceNodeWhenNeeded(result, expr);\n    }\n\n    function CodeGenerator() {\n    }\n\n    // Helpers.\n\n    CodeGenerator.prototype.maybeBlock = function(stmt, flags) {\n        var result, noLeadingComment, that = this;\n\n        noLeadingComment = !extra.comment || !stmt.leadingComments;\n\n        if (stmt.type === Syntax.BlockStatement && noLeadingComment) {\n            return [space, this.generateStatement(stmt, flags)];\n        }\n\n        if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {\n            return ';';\n        }\n\n        withIndent(function () {\n            result = [\n                newline,\n                addIndent(that.generateStatement(stmt, flags))\n            ];\n        });\n\n        return result;\n    };\n\n    CodeGenerator.prototype.maybeBlockSuffix = function (stmt, result) {\n        var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());\n        if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {\n            return [result, space];\n        }\n        if (ends) {\n            return [result, base];\n        }\n        return [result, newline, base];\n    };\n\n    function generateIdentifier(node) {\n        return toSourceNodeWhenNeeded(node.name, node);\n    }\n\n    function generateAsyncPrefix(node, spaceRequired) {\n        return node.async ? 'async' + (spaceRequired ? noEmptySpace() : space) : '';\n    }\n\n    function generateStarSuffix(node) {\n        var isGenerator = node.generator && !extra.moz.starlessGenerator;\n        return isGenerator ? '*' + space : '';\n    }\n\n    function generateMethodPrefix(prop) {\n        var func = prop.value, prefix = '';\n        if (func.async) {\n            prefix += generateAsyncPrefix(func, !prop.computed);\n        }\n        if (func.generator) {\n            // avoid space before method name\n            prefix += generateStarSuffix(func) ? '*' : '';\n        }\n        return prefix;\n    }\n\n    CodeGenerator.prototype.generatePattern = function (node, precedence, flags) {\n        if (node.type === Syntax.Identifier) {\n            return generateIdentifier(node);\n        }\n        return this.generateExpression(node, precedence, flags);\n    };\n\n    CodeGenerator.prototype.generateFunctionParams = function (node) {\n        var i, iz, result, hasDefault;\n\n        hasDefault = false;\n\n        if (node.type === Syntax.ArrowFunctionExpression &&\n                !node.rest && (!node.defaults || node.defaults.length === 0) &&\n                node.params.length === 1 && node.params[0].type === Syntax.Identifier) {\n            // arg => { } case\n            result = [generateAsyncPrefix(node, true), generateIdentifier(node.params[0])];\n        } else {\n            result = node.type === Syntax.ArrowFunctionExpression ? [generateAsyncPrefix(node, false)] : [];\n            result.push('(');\n            if (node.defaults) {\n                hasDefault = true;\n            }\n            for (i = 0, iz = node.params.length; i < iz; ++i) {\n                if (hasDefault && node.defaults[i]) {\n                    // Handle default values.\n                    result.push(this.generateAssignment(node.params[i], node.defaults[i], '=', Precedence.Assignment, E_TTT));\n                } else {\n                    result.push(this.generatePattern(node.params[i], Precedence.Assignment, E_TTT));\n                }\n                if (i + 1 < iz) {\n                    result.push(',' + space);\n                }\n            }\n\n            if (node.rest) {\n                if (node.params.length) {\n                    result.push(',' + space);\n                }\n                result.push('...');\n                result.push(generateIdentifier(node.rest));\n            }\n\n            result.push(')');\n        }\n\n        return result;\n    };\n\n    CodeGenerator.prototype.generateFunctionBody = function (node) {\n        var result, expr;\n\n        result = this.generateFunctionParams(node);\n\n        if (node.type === Syntax.ArrowFunctionExpression) {\n            result.push(space);\n            result.push('=>');\n        }\n\n        if (node.expression) {\n            result.push(space);\n            expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);\n            if (expr.toString().charAt(0) === '{') {\n                expr = ['(', expr, ')'];\n            }\n            result.push(expr);\n        } else {\n            result.push(this.maybeBlock(node.body, S_TTFF));\n        }\n\n        return result;\n    };\n\n    CodeGenerator.prototype.generateIterationForStatement = function (operator, stmt, flags) {\n        var result = ['for' + (stmt.await ? noEmptySpace() + 'await' : '') + space + '('], that = this;\n        withIndent(function () {\n            if (stmt.left.type === Syntax.VariableDeclaration) {\n                withIndent(function () {\n                    result.push(stmt.left.kind + noEmptySpace());\n                    result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));\n                });\n            } else {\n                result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));\n            }\n\n            result = join(result, operator);\n            result = [join(\n                result,\n                that.generateExpression(stmt.right, Precedence.Assignment, E_TTT)\n            ), ')'];\n        });\n        result.push(this.maybeBlock(stmt.body, flags));\n        return result;\n    };\n\n    CodeGenerator.prototype.generatePropertyKey = function (expr, computed) {\n        var result = [];\n\n        if (computed) {\n            result.push('[');\n        }\n\n        result.push(this.generateExpression(expr, Precedence.Assignment, E_TTT));\n\n        if (computed) {\n            result.push(']');\n        }\n\n        return result;\n    };\n\n    CodeGenerator.prototype.generateAssignment = function (left, right, operator, precedence, flags) {\n        if (Precedence.Assignment < precedence) {\n            flags |= F_ALLOW_IN;\n        }\n\n        return parenthesize(\n            [\n                this.generateExpression(left, Precedence.Call, flags),\n                space + operator + space,\n                this.generateExpression(right, Precedence.Assignment, flags)\n            ],\n            Precedence.Assignment,\n            precedence\n        );\n    };\n\n    CodeGenerator.prototype.semicolon = function (flags) {\n        if (!semicolons && flags & F_SEMICOLON_OPT) {\n            return '';\n        }\n        return ';';\n    };\n\n    // Statements.\n\n    CodeGenerator.Statement = {\n\n        BlockStatement: function (stmt, flags) {\n            var range, content, result = ['{', newline], that = this;\n\n            withIndent(function () {\n                // handle functions without any code\n                if (stmt.body.length === 0 && preserveBlankLines) {\n                    range = stmt.range;\n                    if (range[1] - range[0] > 2) {\n                        content = sourceCode.substring(range[0] + 1, range[1] - 1);\n                        if (content[0] === '\\n') {\n                            result = ['{'];\n                        }\n                        result.push(content);\n                    }\n                }\n\n                var i, iz, fragment, bodyFlags;\n                bodyFlags = S_TFFF;\n                if (flags & F_FUNC_BODY) {\n                    bodyFlags |= F_DIRECTIVE_CTX;\n                }\n\n                for (i = 0, iz = stmt.body.length; i < iz; ++i) {\n                    if (preserveBlankLines) {\n                        // handle spaces before the first line\n                        if (i === 0) {\n                            if (stmt.body[0].leadingComments) {\n                                range = stmt.body[0].leadingComments[0].extendedRange;\n                                content = sourceCode.substring(range[0], range[1]);\n                                if (content[0] === '\\n') {\n                                    result = ['{'];\n                                }\n                            }\n                            if (!stmt.body[0].leadingComments) {\n                                generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);\n                            }\n                        }\n\n                        // handle spaces between lines\n                        if (i > 0) {\n                            if (!stmt.body[i - 1].trailingComments  && !stmt.body[i].leadingComments) {\n                                generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);\n                            }\n                        }\n                    }\n\n                    if (i === iz - 1) {\n                        bodyFlags |= F_SEMICOLON_OPT;\n                    }\n\n                    if (stmt.body[i].leadingComments && preserveBlankLines) {\n                        fragment = that.generateStatement(stmt.body[i], bodyFlags);\n                    } else {\n                        fragment = addIndent(that.generateStatement(stmt.body[i], bodyFlags));\n                    }\n\n                    result.push(fragment);\n                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                        if (preserveBlankLines && i < iz - 1) {\n                            // don't add a new line if there are leading coments\n                            // in the next statement\n                            if (!stmt.body[i + 1].leadingComments) {\n                                result.push(newline);\n                            }\n                        } else {\n                            result.push(newline);\n                        }\n                    }\n\n                    if (preserveBlankLines) {\n                        // handle spaces after the last line\n                        if (i === iz - 1) {\n                            if (!stmt.body[i].trailingComments) {\n                                generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);\n                            }\n                        }\n                    }\n                }\n            });\n\n            result.push(addIndent('}'));\n            return result;\n        },\n\n        BreakStatement: function (stmt, flags) {\n            if (stmt.label) {\n                return 'break ' + stmt.label.name + this.semicolon(flags);\n            }\n            return 'break' + this.semicolon(flags);\n        },\n\n        ContinueStatement: function (stmt, flags) {\n            if (stmt.label) {\n                return 'continue ' + stmt.label.name + this.semicolon(flags);\n            }\n            return 'continue' + this.semicolon(flags);\n        },\n\n        ClassBody: function (stmt, flags) {\n            var result = [ '{', newline], that = this;\n\n            withIndent(function (indent) {\n                var i, iz;\n\n                for (i = 0, iz = stmt.body.length; i < iz; ++i) {\n                    result.push(indent);\n                    result.push(that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT));\n                    if (i + 1 < iz) {\n                        result.push(newline);\n                    }\n                }\n            });\n\n            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                result.push(newline);\n            }\n            result.push(base);\n            result.push('}');\n            return result;\n        },\n\n        ClassDeclaration: function (stmt, flags) {\n            var result, fragment;\n            result  = ['class'];\n            if (stmt.id) {\n                result = join(result, this.generateExpression(stmt.id, Precedence.Sequence, E_TTT));\n            }\n            if (stmt.superClass) {\n                fragment = join('extends', this.generateExpression(stmt.superClass, Precedence.Unary, E_TTT));\n                result = join(result, fragment);\n            }\n            result.push(space);\n            result.push(this.generateStatement(stmt.body, S_TFFT));\n            return result;\n        },\n\n        DirectiveStatement: function (stmt, flags) {\n            if (extra.raw && stmt.raw) {\n                return stmt.raw + this.semicolon(flags);\n            }\n            return escapeDirective(stmt.directive) + this.semicolon(flags);\n        },\n\n        DoWhileStatement: function (stmt, flags) {\n            // Because `do 42 while (cond)` is Syntax Error. We need semicolon.\n            var result = join('do', this.maybeBlock(stmt.body, S_TFFF));\n            result = this.maybeBlockSuffix(stmt.body, result);\n            return join(result, [\n                'while' + space + '(',\n                this.generateExpression(stmt.test, Precedence.Sequence, E_TTT),\n                ')' + this.semicolon(flags)\n            ]);\n        },\n\n        CatchClause: function (stmt, flags) {\n            var result, that = this;\n            withIndent(function () {\n                var guard;\n\n                if (stmt.param) {\n                    result = [\n                        'catch' + space + '(',\n                        that.generateExpression(stmt.param, Precedence.Sequence, E_TTT),\n                        ')'\n                    ];\n\n                    if (stmt.guard) {\n                        guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);\n                        result.splice(2, 0, ' if ', guard);\n                    }\n                } else {\n                    result = ['catch'];\n                }\n            });\n            result.push(this.maybeBlock(stmt.body, S_TFFF));\n            return result;\n        },\n\n        DebuggerStatement: function (stmt, flags) {\n            return 'debugger' + this.semicolon(flags);\n        },\n\n        EmptyStatement: function (stmt, flags) {\n            return ';';\n        },\n\n        ExportDefaultDeclaration: function (stmt, flags) {\n            var result = [ 'export' ], bodyFlags;\n\n            bodyFlags = (flags & F_SEMICOLON_OPT) ? S_TFFT : S_TFFF;\n\n            // export default HoistableDeclaration[Default]\n            // export default AssignmentExpression[In] ;\n            result = join(result, 'default');\n            if (isStatement(stmt.declaration)) {\n                result = join(result, this.generateStatement(stmt.declaration, bodyFlags));\n            } else {\n                result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));\n            }\n            return result;\n        },\n\n        ExportNamedDeclaration: function (stmt, flags) {\n            var result = [ 'export' ], bodyFlags, that = this;\n\n            bodyFlags = (flags & F_SEMICOLON_OPT) ? S_TFFT : S_TFFF;\n\n            // export VariableStatement\n            // export Declaration[Default]\n            if (stmt.declaration) {\n                return join(result, this.generateStatement(stmt.declaration, bodyFlags));\n            }\n\n            // export ExportClause[NoReference] FromClause ;\n            // export ExportClause ;\n            if (stmt.specifiers) {\n                if (stmt.specifiers.length === 0) {\n                    result = join(result, '{' + space + '}');\n                } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {\n                    result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));\n                } else {\n                    result = join(result, '{');\n                    withIndent(function (indent) {\n                        var i, iz;\n                        result.push(newline);\n                        for (i = 0, iz = stmt.specifiers.length; i < iz; ++i) {\n                            result.push(indent);\n                            result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));\n                            if (i + 1 < iz) {\n                                result.push(',' + newline);\n                            }\n                        }\n                    });\n                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                        result.push(newline);\n                    }\n                    result.push(base + '}');\n                }\n\n                if (stmt.source) {\n                    result = join(result, [\n                        'from' + space,\n                        // ModuleSpecifier\n                        this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),\n                        this.semicolon(flags)\n                    ]);\n                } else {\n                    result.push(this.semicolon(flags));\n                }\n            }\n            return result;\n        },\n\n        ExportAllDeclaration: function (stmt, flags) {\n            // export * FromClause ;\n            return [\n                'export' + space,\n                '*' + space,\n                'from' + space,\n                // ModuleSpecifier\n                this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),\n                this.semicolon(flags)\n            ];\n        },\n\n        ExpressionStatement: function (stmt, flags) {\n            var result, fragment;\n\n            function isClassPrefixed(fragment) {\n                var code;\n                if (fragment.slice(0, 5) !== 'class') {\n                    return false;\n                }\n                code = fragment.charCodeAt(5);\n                return code === 0x7B  /* '{' */ || esutils.code.isWhiteSpace(code) || esutils.code.isLineTerminator(code);\n            }\n\n            function isFunctionPrefixed(fragment) {\n                var code;\n                if (fragment.slice(0, 8) !== 'function') {\n                    return false;\n                }\n                code = fragment.charCodeAt(8);\n                return code === 0x28 /* '(' */ || esutils.code.isWhiteSpace(code) || code === 0x2A  /* '*' */ || esutils.code.isLineTerminator(code);\n            }\n\n            function isAsyncPrefixed(fragment) {\n                var code, i, iz;\n                if (fragment.slice(0, 5) !== 'async') {\n                    return false;\n                }\n                if (!esutils.code.isWhiteSpace(fragment.charCodeAt(5))) {\n                    return false;\n                }\n                for (i = 6, iz = fragment.length; i < iz; ++i) {\n                    if (!esutils.code.isWhiteSpace(fragment.charCodeAt(i))) {\n                        break;\n                    }\n                }\n                if (i === iz) {\n                    return false;\n                }\n                if (fragment.slice(i, i + 8) !== 'function') {\n                    return false;\n                }\n                code = fragment.charCodeAt(i + 8);\n                return code === 0x28 /* '(' */ || esutils.code.isWhiteSpace(code) || code === 0x2A  /* '*' */ || esutils.code.isLineTerminator(code);\n            }\n\n            result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)];\n            // 12.4 '{', 'function', 'class' is not allowed in this position.\n            // wrap expression with parentheses\n            fragment = toSourceNodeWhenNeeded(result).toString();\n            if (fragment.charCodeAt(0) === 0x7B  /* '{' */ ||  // ObjectExpression\n                    isClassPrefixed(fragment) ||\n                    isFunctionPrefixed(fragment) ||\n                    isAsyncPrefixed(fragment) ||\n                    (directive && (flags & F_DIRECTIVE_CTX) && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string')) {\n                result = ['(', result, ')' + this.semicolon(flags)];\n            } else {\n                result.push(this.semicolon(flags));\n            }\n            return result;\n        },\n\n        ImportDeclaration: function (stmt, flags) {\n            // ES6: 15.2.1 valid import declarations:\n            //     - import ImportClause FromClause ;\n            //     - import ModuleSpecifier ;\n            var result, cursor, that = this;\n\n            // If no ImportClause is present,\n            // this should be `import ModuleSpecifier` so skip `from`\n            // ModuleSpecifier is StringLiteral.\n            if (stmt.specifiers.length === 0) {\n                // import ModuleSpecifier ;\n                return [\n                    'import',\n                    space,\n                    // ModuleSpecifier\n                    this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),\n                    this.semicolon(flags)\n                ];\n            }\n\n            // import ImportClause FromClause ;\n            result = [\n                'import'\n            ];\n            cursor = 0;\n\n            // ImportedBinding\n            if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {\n                result = join(result, [\n                        this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)\n                ]);\n                ++cursor;\n            }\n\n            if (stmt.specifiers[cursor]) {\n                if (cursor !== 0) {\n                    result.push(',');\n                }\n\n                if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {\n                    // NameSpaceImport\n                    result = join(result, [\n                            space,\n                            this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)\n                    ]);\n                } else {\n                    // NamedImports\n                    result.push(space + '{');\n\n                    if ((stmt.specifiers.length - cursor) === 1) {\n                        // import { ... } from \"...\";\n                        result.push(space);\n                        result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));\n                        result.push(space + '}' + space);\n                    } else {\n                        // import {\n                        //    ...,\n                        //    ...,\n                        // } from \"...\";\n                        withIndent(function (indent) {\n                            var i, iz;\n                            result.push(newline);\n                            for (i = cursor, iz = stmt.specifiers.length; i < iz; ++i) {\n                                result.push(indent);\n                                result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));\n                                if (i + 1 < iz) {\n                                    result.push(',' + newline);\n                                }\n                            }\n                        });\n                        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                            result.push(newline);\n                        }\n                        result.push(base + '}' + space);\n                    }\n                }\n            }\n\n            result = join(result, [\n                'from' + space,\n                // ModuleSpecifier\n                this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),\n                this.semicolon(flags)\n            ]);\n            return result;\n        },\n\n        VariableDeclarator: function (stmt, flags) {\n            var itemFlags = (flags & F_ALLOW_IN) ? E_TTT : E_FTT;\n            if (stmt.init) {\n                return [\n                    this.generateExpression(stmt.id, Precedence.Assignment, itemFlags),\n                    space,\n                    '=',\n                    space,\n                    this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)\n                ];\n            }\n            return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);\n        },\n\n        VariableDeclaration: function (stmt, flags) {\n            // VariableDeclarator is typed as Statement,\n            // but joined with comma (not LineTerminator).\n            // So if comment is attached to target node, we should specialize.\n            var result, i, iz, node, bodyFlags, that = this;\n\n            result = [ stmt.kind ];\n\n            bodyFlags = (flags & F_ALLOW_IN) ? S_TFFF : S_FFFF;\n\n            function block() {\n                node = stmt.declarations[0];\n                if (extra.comment && node.leadingComments) {\n                    result.push('\\n');\n                    result.push(addIndent(that.generateStatement(node, bodyFlags)));\n                } else {\n                    result.push(noEmptySpace());\n                    result.push(that.generateStatement(node, bodyFlags));\n                }\n\n                for (i = 1, iz = stmt.declarations.length; i < iz; ++i) {\n                    node = stmt.declarations[i];\n                    if (extra.comment && node.leadingComments) {\n                        result.push(',' + newline);\n                        result.push(addIndent(that.generateStatement(node, bodyFlags)));\n                    } else {\n                        result.push(',' + space);\n                        result.push(that.generateStatement(node, bodyFlags));\n                    }\n                }\n            }\n\n            if (stmt.declarations.length > 1) {\n                withIndent(block);\n            } else {\n                block();\n            }\n\n            result.push(this.semicolon(flags));\n\n            return result;\n        },\n\n        ThrowStatement: function (stmt, flags) {\n            return [join(\n                'throw',\n                this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)\n            ), this.semicolon(flags)];\n        },\n\n        TryStatement: function (stmt, flags) {\n            var result, i, iz, guardedHandlers;\n\n            result = ['try', this.maybeBlock(stmt.block, S_TFFF)];\n            result = this.maybeBlockSuffix(stmt.block, result);\n\n            if (stmt.handlers) {\n                // old interface\n                for (i = 0, iz = stmt.handlers.length; i < iz; ++i) {\n                    result = join(result, this.generateStatement(stmt.handlers[i], S_TFFF));\n                    if (stmt.finalizer || i + 1 !== iz) {\n                        result = this.maybeBlockSuffix(stmt.handlers[i].body, result);\n                    }\n                }\n            } else {\n                guardedHandlers = stmt.guardedHandlers || [];\n\n                for (i = 0, iz = guardedHandlers.length; i < iz; ++i) {\n                    result = join(result, this.generateStatement(guardedHandlers[i], S_TFFF));\n                    if (stmt.finalizer || i + 1 !== iz) {\n                        result = this.maybeBlockSuffix(guardedHandlers[i].body, result);\n                    }\n                }\n\n                // new interface\n                if (stmt.handler) {\n                    if (Array.isArray(stmt.handler)) {\n                        for (i = 0, iz = stmt.handler.length; i < iz; ++i) {\n                            result = join(result, this.generateStatement(stmt.handler[i], S_TFFF));\n                            if (stmt.finalizer || i + 1 !== iz) {\n                                result = this.maybeBlockSuffix(stmt.handler[i].body, result);\n                            }\n                        }\n                    } else {\n                        result = join(result, this.generateStatement(stmt.handler, S_TFFF));\n                        if (stmt.finalizer) {\n                            result = this.maybeBlockSuffix(stmt.handler.body, result);\n                        }\n                    }\n                }\n            }\n            if (stmt.finalizer) {\n                result = join(result, ['finally', this.maybeBlock(stmt.finalizer, S_TFFF)]);\n            }\n            return result;\n        },\n\n        SwitchStatement: function (stmt, flags) {\n            var result, fragment, i, iz, bodyFlags, that = this;\n            withIndent(function () {\n                result = [\n                    'switch' + space + '(',\n                    that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT),\n                    ')' + space + '{' + newline\n                ];\n            });\n            if (stmt.cases) {\n                bodyFlags = S_TFFF;\n                for (i = 0, iz = stmt.cases.length; i < iz; ++i) {\n                    if (i === iz - 1) {\n                        bodyFlags |= F_SEMICOLON_OPT;\n                    }\n                    fragment = addIndent(this.generateStatement(stmt.cases[i], bodyFlags));\n                    result.push(fragment);\n                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                        result.push(newline);\n                    }\n                }\n            }\n            result.push(addIndent('}'));\n            return result;\n        },\n\n        SwitchCase: function (stmt, flags) {\n            var result, fragment, i, iz, bodyFlags, that = this;\n            withIndent(function () {\n                if (stmt.test) {\n                    result = [\n                        join('case', that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)),\n                        ':'\n                    ];\n                } else {\n                    result = ['default:'];\n                }\n\n                i = 0;\n                iz = stmt.consequent.length;\n                if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {\n                    fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);\n                    result.push(fragment);\n                    i = 1;\n                }\n\n                if (i !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                    result.push(newline);\n                }\n\n                bodyFlags = S_TFFF;\n                for (; i < iz; ++i) {\n                    if (i === iz - 1 && flags & F_SEMICOLON_OPT) {\n                        bodyFlags |= F_SEMICOLON_OPT;\n                    }\n                    fragment = addIndent(that.generateStatement(stmt.consequent[i], bodyFlags));\n                    result.push(fragment);\n                    if (i + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                        result.push(newline);\n                    }\n                }\n            });\n            return result;\n        },\n\n        IfStatement: function (stmt, flags) {\n            var result, bodyFlags, semicolonOptional, that = this;\n            withIndent(function () {\n                result = [\n                    'if' + space + '(',\n                    that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),\n                    ')'\n                ];\n            });\n            semicolonOptional = flags & F_SEMICOLON_OPT;\n            bodyFlags = S_TFFF;\n            if (semicolonOptional) {\n                bodyFlags |= F_SEMICOLON_OPT;\n            }\n            if (stmt.alternate) {\n                result.push(this.maybeBlock(stmt.consequent, S_TFFF));\n                result = this.maybeBlockSuffix(stmt.consequent, result);\n                if (stmt.alternate.type === Syntax.IfStatement) {\n                    result = join(result, ['else ', this.generateStatement(stmt.alternate, bodyFlags)]);\n                } else {\n                    result = join(result, join('else', this.maybeBlock(stmt.alternate, bodyFlags)));\n                }\n            } else {\n                result.push(this.maybeBlock(stmt.consequent, bodyFlags));\n            }\n            return result;\n        },\n\n        ForStatement: function (stmt, flags) {\n            var result, that = this;\n            withIndent(function () {\n                result = ['for' + space + '('];\n                if (stmt.init) {\n                    if (stmt.init.type === Syntax.VariableDeclaration) {\n                        result.push(that.generateStatement(stmt.init, S_FFFF));\n                    } else {\n                        // F_ALLOW_IN becomes false.\n                        result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));\n                        result.push(';');\n                    }\n                } else {\n                    result.push(';');\n                }\n\n                if (stmt.test) {\n                    result.push(space);\n                    result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));\n                    result.push(';');\n                } else {\n                    result.push(';');\n                }\n\n                if (stmt.update) {\n                    result.push(space);\n                    result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));\n                    result.push(')');\n                } else {\n                    result.push(')');\n                }\n            });\n\n            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\n            return result;\n        },\n\n        ForInStatement: function (stmt, flags) {\n            return this.generateIterationForStatement('in', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);\n        },\n\n        ForOfStatement: function (stmt, flags) {\n            return this.generateIterationForStatement('of', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);\n        },\n\n        LabeledStatement: function (stmt, flags) {\n            return [stmt.label.name + ':', this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)];\n        },\n\n        Program: function (stmt, flags) {\n            var result, fragment, i, iz, bodyFlags;\n            iz = stmt.body.length;\n            result = [safeConcatenation && iz > 0 ? '\\n' : ''];\n            bodyFlags = S_TFTF;\n            for (i = 0; i < iz; ++i) {\n                if (!safeConcatenation && i === iz - 1) {\n                    bodyFlags |= F_SEMICOLON_OPT;\n                }\n\n                if (preserveBlankLines) {\n                    // handle spaces before the first line\n                    if (i === 0) {\n                        if (!stmt.body[0].leadingComments) {\n                            generateBlankLines(stmt.range[0], stmt.body[i].range[0], result);\n                        }\n                    }\n\n                    // handle spaces between lines\n                    if (i > 0) {\n                        if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {\n                            generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);\n                        }\n                    }\n                }\n\n                fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));\n                result.push(fragment);\n                if (i + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                    if (preserveBlankLines) {\n                        if (!stmt.body[i + 1].leadingComments) {\n                            result.push(newline);\n                        }\n                    } else {\n                        result.push(newline);\n                    }\n                }\n\n                if (preserveBlankLines) {\n                    // handle spaces after the last line\n                    if (i === iz - 1) {\n                        if (!stmt.body[i].trailingComments) {\n                            generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);\n                        }\n                    }\n                }\n            }\n            return result;\n        },\n\n        FunctionDeclaration: function (stmt, flags) {\n            return [\n                generateAsyncPrefix(stmt, true),\n                'function',\n                generateStarSuffix(stmt) || noEmptySpace(),\n                stmt.id ? generateIdentifier(stmt.id) : '',\n                this.generateFunctionBody(stmt)\n            ];\n        },\n\n        ReturnStatement: function (stmt, flags) {\n            if (stmt.argument) {\n                return [join(\n                    'return',\n                    this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)\n                ), this.semicolon(flags)];\n            }\n            return ['return' + this.semicolon(flags)];\n        },\n\n        WhileStatement: function (stmt, flags) {\n            var result, that = this;\n            withIndent(function () {\n                result = [\n                    'while' + space + '(',\n                    that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),\n                    ')'\n                ];\n            });\n            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\n            return result;\n        },\n\n        WithStatement: function (stmt, flags) {\n            var result, that = this;\n            withIndent(function () {\n                result = [\n                    'with' + space + '(',\n                    that.generateExpression(stmt.object, Precedence.Sequence, E_TTT),\n                    ')'\n                ];\n            });\n            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\n            return result;\n        }\n\n    };\n\n    merge(CodeGenerator.prototype, CodeGenerator.Statement);\n\n    // Expressions.\n\n    CodeGenerator.Expression = {\n\n        SequenceExpression: function (expr, precedence, flags) {\n            var result, i, iz;\n            if (Precedence.Sequence < precedence) {\n                flags |= F_ALLOW_IN;\n            }\n            result = [];\n            for (i = 0, iz = expr.expressions.length; i < iz; ++i) {\n                result.push(this.generateExpression(expr.expressions[i], Precedence.Assignment, flags));\n                if (i + 1 < iz) {\n                    result.push(',' + space);\n                }\n            }\n            return parenthesize(result, Precedence.Sequence, precedence);\n        },\n\n        AssignmentExpression: function (expr, precedence, flags) {\n            return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);\n        },\n\n        ArrowFunctionExpression: function (expr, precedence, flags) {\n            return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);\n        },\n\n        ConditionalExpression: function (expr, precedence, flags) {\n            if (Precedence.Conditional < precedence) {\n                flags |= F_ALLOW_IN;\n            }\n            return parenthesize(\n                [\n                    this.generateExpression(expr.test, Precedence.LogicalOR, flags),\n                    space + '?' + space,\n                    this.generateExpression(expr.consequent, Precedence.Assignment, flags),\n                    space + ':' + space,\n                    this.generateExpression(expr.alternate, Precedence.Assignment, flags)\n                ],\n                Precedence.Conditional,\n                precedence\n            );\n        },\n\n        LogicalExpression: function (expr, precedence, flags) {\n            return this.BinaryExpression(expr, precedence, flags);\n        },\n\n        BinaryExpression: function (expr, precedence, flags) {\n            var result, leftPrecedence, rightPrecedence, currentPrecedence, fragment, leftSource;\n            currentPrecedence = BinaryPrecedence[expr.operator];\n            leftPrecedence = expr.operator === '**' ? Precedence.Postfix : currentPrecedence;\n            rightPrecedence = expr.operator === '**' ? currentPrecedence : currentPrecedence + 1;\n\n            if (currentPrecedence < precedence) {\n                flags |= F_ALLOW_IN;\n            }\n\n            fragment = this.generateExpression(expr.left, leftPrecedence, flags);\n\n            leftSource = fragment.toString();\n\n            if (leftSource.charCodeAt(leftSource.length - 1) === 0x2F /* / */ && esutils.code.isIdentifierPartES5(expr.operator.charCodeAt(0))) {\n                result = [fragment, noEmptySpace(), expr.operator];\n            } else {\n                result = join(fragment, expr.operator);\n            }\n\n            fragment = this.generateExpression(expr.right, rightPrecedence, flags);\n\n            if (expr.operator === '/' && fragment.toString().charAt(0) === '/' ||\n            expr.operator.slice(-1) === '<' && fragment.toString().slice(0, 3) === '!--') {\n                // If '/' concats with '/' or `<` concats with `!--`, it is interpreted as comment start\n                result.push(noEmptySpace());\n                result.push(fragment);\n            } else {\n                result = join(result, fragment);\n            }\n\n            if (expr.operator === 'in' && !(flags & F_ALLOW_IN)) {\n                return ['(', result, ')'];\n            }\n            return parenthesize(result, currentPrecedence, precedence);\n        },\n\n        CallExpression: function (expr, precedence, flags) {\n            var result, i, iz;\n\n            // F_ALLOW_UNPARATH_NEW becomes false.\n            result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];\n\n            if (expr.optional) {\n                result.push('?.');\n            }\n\n            result.push('(');\n            for (i = 0, iz = expr['arguments'].length; i < iz; ++i) {\n                result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));\n                if (i + 1 < iz) {\n                    result.push(',' + space);\n                }\n            }\n            result.push(')');\n\n            if (!(flags & F_ALLOW_CALL)) {\n                return ['(', result, ')'];\n            }\n\n            return parenthesize(result, Precedence.Call, precedence);\n        },\n\n        ChainExpression: function (expr, precedence, flags) {\n            if (Precedence.OptionalChaining < precedence) {\n                flags |= F_ALLOW_CALL;\n            }\n\n            var result = this.generateExpression(expr.expression, Precedence.OptionalChaining, flags);\n\n            return parenthesize(result, Precedence.OptionalChaining, precedence);\n        },\n\n        NewExpression: function (expr, precedence, flags) {\n            var result, length, i, iz, itemFlags;\n            length = expr['arguments'].length;\n\n            // F_ALLOW_CALL becomes false.\n            // F_ALLOW_UNPARATH_NEW may become false.\n            itemFlags = (flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0) ? E_TFT : E_TFF;\n\n            result = join(\n                'new',\n                this.generateExpression(expr.callee, Precedence.New, itemFlags)\n            );\n\n            if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {\n                result.push('(');\n                for (i = 0, iz = length; i < iz; ++i) {\n                    result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));\n                    if (i + 1 < iz) {\n                        result.push(',' + space);\n                    }\n                }\n                result.push(')');\n            }\n\n            return parenthesize(result, Precedence.New, precedence);\n        },\n\n        MemberExpression: function (expr, precedence, flags) {\n            var result, fragment;\n\n            // F_ALLOW_UNPARATH_NEW becomes false.\n            result = [this.generateExpression(expr.object, Precedence.Call, (flags & F_ALLOW_CALL) ? E_TTF : E_TFF)];\n\n            if (expr.computed) {\n                if (expr.optional) {\n                    result.push('?.');\n                }\n\n                result.push('[');\n                result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));\n                result.push(']');\n            } else {\n                if (!expr.optional && expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {\n                    fragment = toSourceNodeWhenNeeded(result).toString();\n                    // When the following conditions are all true,\n                    //   1. No floating point\n                    //   2. Don't have exponents\n                    //   3. The last character is a decimal digit\n                    //   4. Not hexadecimal OR octal number literal\n                    // we should add a floating point.\n                    if (\n                            fragment.indexOf('.') < 0 &&\n                            !/[eExX]/.test(fragment) &&\n                            esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) &&\n                            !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)  // '0'\n                            ) {\n                        result.push(' ');\n                    }\n                }\n                result.push(expr.optional ? '?.' : '.');\n                result.push(generateIdentifier(expr.property));\n            }\n\n            return parenthesize(result, Precedence.Member, precedence);\n        },\n\n        MetaProperty: function (expr, precedence, flags) {\n            var result;\n            result = [];\n            result.push(typeof expr.meta === \"string\" ? expr.meta : generateIdentifier(expr.meta));\n            result.push('.');\n            result.push(typeof expr.property === \"string\" ? expr.property : generateIdentifier(expr.property));\n            return parenthesize(result, Precedence.Member, precedence);\n        },\n\n        UnaryExpression: function (expr, precedence, flags) {\n            var result, fragment, rightCharCode, leftSource, leftCharCode;\n            fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);\n\n            if (space === '') {\n                result = join(expr.operator, fragment);\n            } else {\n                result = [expr.operator];\n                if (expr.operator.length > 2) {\n                    // delete, void, typeof\n                    // get `typeof []`, not `typeof[]`\n                    result = join(result, fragment);\n                } else {\n                    // Prevent inserting spaces between operator and argument if it is unnecessary\n                    // like, `!cond`\n                    leftSource = toSourceNodeWhenNeeded(result).toString();\n                    leftCharCode = leftSource.charCodeAt(leftSource.length - 1);\n                    rightCharCode = fragment.toString().charCodeAt(0);\n\n                    if (((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode) ||\n                            (esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode))) {\n                        result.push(noEmptySpace());\n                        result.push(fragment);\n                    } else {\n                        result.push(fragment);\n                    }\n                }\n            }\n            return parenthesize(result, Precedence.Unary, precedence);\n        },\n\n        YieldExpression: function (expr, precedence, flags) {\n            var result;\n            if (expr.delegate) {\n                result = 'yield*';\n            } else {\n                result = 'yield';\n            }\n            if (expr.argument) {\n                result = join(\n                    result,\n                    this.generateExpression(expr.argument, Precedence.Yield, E_TTT)\n                );\n            }\n            return parenthesize(result, Precedence.Yield, precedence);\n        },\n\n        AwaitExpression: function (expr, precedence, flags) {\n            var result = join(\n                expr.all ? 'await*' : 'await',\n                this.generateExpression(expr.argument, Precedence.Await, E_TTT)\n            );\n            return parenthesize(result, Precedence.Await, precedence);\n        },\n\n        UpdateExpression: function (expr, precedence, flags) {\n            if (expr.prefix) {\n                return parenthesize(\n                    [\n                        expr.operator,\n                        this.generateExpression(expr.argument, Precedence.Unary, E_TTT)\n                    ],\n                    Precedence.Unary,\n                    precedence\n                );\n            }\n            return parenthesize(\n                [\n                    this.generateExpression(expr.argument, Precedence.Postfix, E_TTT),\n                    expr.operator\n                ],\n                Precedence.Postfix,\n                precedence\n            );\n        },\n\n        FunctionExpression: function (expr, precedence, flags) {\n            var result = [\n                generateAsyncPrefix(expr, true),\n                'function'\n            ];\n            if (expr.id) {\n                result.push(generateStarSuffix(expr) || noEmptySpace());\n                result.push(generateIdentifier(expr.id));\n            } else {\n                result.push(generateStarSuffix(expr) || space);\n            }\n            result.push(this.generateFunctionBody(expr));\n            return result;\n        },\n\n        ArrayPattern: function (expr, precedence, flags) {\n            return this.ArrayExpression(expr, precedence, flags, true);\n        },\n\n        ArrayExpression: function (expr, precedence, flags, isPattern) {\n            var result, multiline, that = this;\n            if (!expr.elements.length) {\n                return '[]';\n            }\n            multiline = isPattern ? false : expr.elements.length > 1;\n            result = ['[', multiline ? newline : ''];\n            withIndent(function (indent) {\n                var i, iz;\n                for (i = 0, iz = expr.elements.length; i < iz; ++i) {\n                    if (!expr.elements[i]) {\n                        if (multiline) {\n                            result.push(indent);\n                        }\n                        if (i + 1 === iz) {\n                            result.push(',');\n                        }\n                    } else {\n                        result.push(multiline ? indent : '');\n                        result.push(that.generateExpression(expr.elements[i], Precedence.Assignment, E_TTT));\n                    }\n                    if (i + 1 < iz) {\n                        result.push(',' + (multiline ? newline : space));\n                    }\n                }\n            });\n            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                result.push(newline);\n            }\n            result.push(multiline ? base : '');\n            result.push(']');\n            return result;\n        },\n\n        RestElement: function(expr, precedence, flags) {\n            return '...' + this.generatePattern(expr.argument);\n        },\n\n        ClassExpression: function (expr, precedence, flags) {\n            var result, fragment;\n            result = ['class'];\n            if (expr.id) {\n                result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));\n            }\n            if (expr.superClass) {\n                fragment = join('extends', this.generateExpression(expr.superClass, Precedence.Unary, E_TTT));\n                result = join(result, fragment);\n            }\n            result.push(space);\n            result.push(this.generateStatement(expr.body, S_TFFT));\n            return result;\n        },\n\n        MethodDefinition: function (expr, precedence, flags) {\n            var result, fragment;\n            if (expr['static']) {\n                result = ['static' + space];\n            } else {\n                result = [];\n            }\n            if (expr.kind === 'get' || expr.kind === 'set') {\n                fragment = [\n                    join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)),\n                    this.generateFunctionBody(expr.value)\n                ];\n            } else {\n                fragment = [\n                    generateMethodPrefix(expr),\n                    this.generatePropertyKey(expr.key, expr.computed),\n                    this.generateFunctionBody(expr.value)\n                ];\n            }\n            return join(result, fragment);\n        },\n\n        Property: function (expr, precedence, flags) {\n            if (expr.kind === 'get' || expr.kind === 'set') {\n                return [\n                    expr.kind, noEmptySpace(),\n                    this.generatePropertyKey(expr.key, expr.computed),\n                    this.generateFunctionBody(expr.value)\n                ];\n            }\n\n            if (expr.shorthand) {\n                if (expr.value.type === \"AssignmentPattern\") {\n                    return this.AssignmentPattern(expr.value, Precedence.Sequence, E_TTT);\n                }\n                return this.generatePropertyKey(expr.key, expr.computed);\n            }\n\n            if (expr.method) {\n                return [\n                    generateMethodPrefix(expr),\n                    this.generatePropertyKey(expr.key, expr.computed),\n                    this.generateFunctionBody(expr.value)\n                ];\n            }\n\n            return [\n                this.generatePropertyKey(expr.key, expr.computed),\n                ':' + space,\n                this.generateExpression(expr.value, Precedence.Assignment, E_TTT)\n            ];\n        },\n\n        ObjectExpression: function (expr, precedence, flags) {\n            var multiline, result, fragment, that = this;\n\n            if (!expr.properties.length) {\n                return '{}';\n            }\n            multiline = expr.properties.length > 1;\n\n            withIndent(function () {\n                fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);\n            });\n\n            if (!multiline) {\n                // issues 4\n                // Do not transform from\n                //   dejavu.Class.declare({\n                //       method2: function () {}\n                //   });\n                // to\n                //   dejavu.Class.declare({method2: function () {\n                //       }});\n                if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                    return [ '{', space, fragment, space, '}' ];\n                }\n            }\n\n            withIndent(function (indent) {\n                var i, iz;\n                result = [ '{', newline, indent, fragment ];\n\n                if (multiline) {\n                    result.push(',' + newline);\n                    for (i = 1, iz = expr.properties.length; i < iz; ++i) {\n                        result.push(indent);\n                        result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));\n                        if (i + 1 < iz) {\n                            result.push(',' + newline);\n                        }\n                    }\n                }\n            });\n\n            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                result.push(newline);\n            }\n            result.push(base);\n            result.push('}');\n            return result;\n        },\n\n        AssignmentPattern: function(expr, precedence, flags) {\n            return this.generateAssignment(expr.left, expr.right, '=', precedence, flags);\n        },\n\n        ObjectPattern: function (expr, precedence, flags) {\n            var result, i, iz, multiline, property, that = this;\n            if (!expr.properties.length) {\n                return '{}';\n            }\n\n            multiline = false;\n            if (expr.properties.length === 1) {\n                property = expr.properties[0];\n                if (\n                    property.type === Syntax.Property\n                    && property.value.type !== Syntax.Identifier\n                ) {\n                    multiline = true;\n                }\n            } else {\n                for (i = 0, iz = expr.properties.length; i < iz; ++i) {\n                    property = expr.properties[i];\n                    if (\n                        property.type === Syntax.Property\n                        && !property.shorthand\n                    ) {\n                        multiline = true;\n                        break;\n                    }\n                }\n            }\n            result = ['{', multiline ? newline : '' ];\n\n            withIndent(function (indent) {\n                var i, iz;\n                for (i = 0, iz = expr.properties.length; i < iz; ++i) {\n                    result.push(multiline ? indent : '');\n                    result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));\n                    if (i + 1 < iz) {\n                        result.push(',' + (multiline ? newline : space));\n                    }\n                }\n            });\n\n            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                result.push(newline);\n            }\n            result.push(multiline ? base : '');\n            result.push('}');\n            return result;\n        },\n\n        ThisExpression: function (expr, precedence, flags) {\n            return 'this';\n        },\n\n        Super: function (expr, precedence, flags) {\n            return 'super';\n        },\n\n        Identifier: function (expr, precedence, flags) {\n            return generateIdentifier(expr);\n        },\n\n        ImportDefaultSpecifier: function (expr, precedence, flags) {\n            return generateIdentifier(expr.id || expr.local);\n        },\n\n        ImportNamespaceSpecifier: function (expr, precedence, flags) {\n            var result = ['*'];\n            var id = expr.id || expr.local;\n            if (id) {\n                result.push(space + 'as' + noEmptySpace() + generateIdentifier(id));\n            }\n            return result;\n        },\n\n        ImportSpecifier: function (expr, precedence, flags) {\n            var imported = expr.imported;\n            var result = [ imported.name ];\n            var local = expr.local;\n            if (local && local.name !== imported.name) {\n                result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(local));\n            }\n            return result;\n        },\n\n        ExportSpecifier: function (expr, precedence, flags) {\n            var local = expr.local;\n            var result = [ local.name ];\n            var exported = expr.exported;\n            if (exported && exported.name !== local.name) {\n                result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(exported));\n            }\n            return result;\n        },\n\n        Literal: function (expr, precedence, flags) {\n            var raw;\n            if (expr.hasOwnProperty('raw') && parse && extra.raw) {\n                try {\n                    raw = parse(expr.raw).body[0].expression;\n                    if (raw.type === Syntax.Literal) {\n                        if (raw.value === expr.value) {\n                            return expr.raw;\n                        }\n                    }\n                } catch (e) {\n                    // not use raw property\n                }\n            }\n\n            if (expr.regex) {\n              return '/' + expr.regex.pattern + '/' + expr.regex.flags;\n            }\n\n            if (expr.value === null) {\n                return 'null';\n            }\n\n            if (typeof expr.value === 'string') {\n                return escapeString(expr.value);\n            }\n\n            if (typeof expr.value === 'number') {\n                return generateNumber(expr.value);\n            }\n\n            if (typeof expr.value === 'boolean') {\n                return expr.value ? 'true' : 'false';\n            }\n\n            return generateRegExp(expr.value);\n        },\n\n        GeneratorExpression: function (expr, precedence, flags) {\n            return this.ComprehensionExpression(expr, precedence, flags);\n        },\n\n        ComprehensionExpression: function (expr, precedence, flags) {\n            // GeneratorExpression should be parenthesized with (...), ComprehensionExpression with [...]\n            // Due to https://bugzilla.mozilla.org/show_bug.cgi?id=883468 position of expr.body can differ in Spidermonkey and ES6\n\n            var result, i, iz, fragment, that = this;\n            result = (expr.type === Syntax.GeneratorExpression) ? ['('] : ['['];\n\n            if (extra.moz.comprehensionExpressionStartsWithAssignment) {\n                fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);\n                result.push(fragment);\n            }\n\n            if (expr.blocks) {\n                withIndent(function () {\n                    for (i = 0, iz = expr.blocks.length; i < iz; ++i) {\n                        fragment = that.generateExpression(expr.blocks[i], Precedence.Sequence, E_TTT);\n                        if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {\n                            result = join(result, fragment);\n                        } else {\n                            result.push(fragment);\n                        }\n                    }\n                });\n            }\n\n            if (expr.filter) {\n                result = join(result, 'if' + space);\n                fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);\n                result = join(result, [ '(', fragment, ')' ]);\n            }\n\n            if (!extra.moz.comprehensionExpressionStartsWithAssignment) {\n                fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);\n\n                result = join(result, fragment);\n            }\n\n            result.push((expr.type === Syntax.GeneratorExpression) ? ')' : ']');\n            return result;\n        },\n\n        ComprehensionBlock: function (expr, precedence, flags) {\n            var fragment;\n            if (expr.left.type === Syntax.VariableDeclaration) {\n                fragment = [\n                    expr.left.kind, noEmptySpace(),\n                    this.generateStatement(expr.left.declarations[0], S_FFFF)\n                ];\n            } else {\n                fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);\n            }\n\n            fragment = join(fragment, expr.of ? 'of' : 'in');\n            fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));\n\n            return [ 'for' + space + '(', fragment, ')' ];\n        },\n\n        SpreadElement: function (expr, precedence, flags) {\n            return [\n                '...',\n                this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)\n            ];\n        },\n\n        TaggedTemplateExpression: function (expr, precedence, flags) {\n            var itemFlags = E_TTF;\n            if (!(flags & F_ALLOW_CALL)) {\n                itemFlags = E_TFF;\n            }\n            var result = [\n                this.generateExpression(expr.tag, Precedence.Call, itemFlags),\n                this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)\n            ];\n            return parenthesize(result, Precedence.TaggedTemplate, precedence);\n        },\n\n        TemplateElement: function (expr, precedence, flags) {\n            // Don't use \"cooked\". Since tagged template can use raw template\n            // representation. So if we do so, it breaks the script semantics.\n            return expr.value.raw;\n        },\n\n        TemplateLiteral: function (expr, precedence, flags) {\n            var result, i, iz;\n            result = [ '`' ];\n            for (i = 0, iz = expr.quasis.length; i < iz; ++i) {\n                result.push(this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT));\n                if (i + 1 < iz) {\n                    result.push('${' + space);\n                    result.push(this.generateExpression(expr.expressions[i], Precedence.Sequence, E_TTT));\n                    result.push(space + '}');\n                }\n            }\n            result.push('`');\n            return result;\n        },\n\n        ModuleSpecifier: function (expr, precedence, flags) {\n            return this.Literal(expr, precedence, flags);\n        },\n\n        ImportExpression: function(expr, precedence, flag) {\n            return parenthesize([\n                'import(',\n                this.generateExpression(expr.source, Precedence.Assignment, E_TTT),\n                ')'\n            ], Precedence.Call, precedence);\n        }\n    };\n\n    merge(CodeGenerator.prototype, CodeGenerator.Expression);\n\n    CodeGenerator.prototype.generateExpression = function (expr, precedence, flags) {\n        var result, type;\n\n        type = expr.type || Syntax.Property;\n\n        if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {\n            return generateVerbatim(expr, precedence);\n        }\n\n        result = this[type](expr, precedence, flags);\n\n\n        if (extra.comment) {\n            result = addComments(expr, result);\n        }\n        return toSourceNodeWhenNeeded(result, expr);\n    };\n\n    CodeGenerator.prototype.generateStatement = function (stmt, flags) {\n        var result,\n            fragment;\n\n        result = this[stmt.type](stmt, flags);\n\n        // Attach comments\n\n        if (extra.comment) {\n            result = addComments(stmt, result);\n        }\n\n        fragment = toSourceNodeWhenNeeded(result).toString();\n        if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' &&  fragment.charAt(fragment.length - 1) === '\\n') {\n            result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\\s+$/, '') : fragment.replace(/\\s+$/, '');\n        }\n\n        return toSourceNodeWhenNeeded(result, stmt);\n    };\n\n    function generateInternal(node) {\n        var codegen;\n\n        codegen = new CodeGenerator();\n        if (isStatement(node)) {\n            return codegen.generateStatement(node, S_TFFF);\n        }\n\n        if (isExpression(node)) {\n            return codegen.generateExpression(node, Precedence.Sequence, E_TTT);\n        }\n\n        throw new Error('Unknown node type: ' + node.type);\n    }\n\n    function generate(node, options) {\n        var defaultOptions = getDefaultOptions(), result, pair;\n\n        if (options != null) {\n            // Obsolete options\n            //\n            //   `options.indent`\n            //   `options.base`\n            //\n            // Instead of them, we can use `option.format.indent`.\n            if (typeof options.indent === 'string') {\n                defaultOptions.format.indent.style = options.indent;\n            }\n            if (typeof options.base === 'number') {\n                defaultOptions.format.indent.base = options.base;\n            }\n            options = updateDeeply(defaultOptions, options);\n            indent = options.format.indent.style;\n            if (typeof options.base === 'string') {\n                base = options.base;\n            } else {\n                base = stringRepeat(indent, options.format.indent.base);\n            }\n        } else {\n            options = defaultOptions;\n            indent = options.format.indent.style;\n            base = stringRepeat(indent, options.format.indent.base);\n        }\n        json = options.format.json;\n        renumber = options.format.renumber;\n        hexadecimal = json ? false : options.format.hexadecimal;\n        quotes = json ? 'double' : options.format.quotes;\n        escapeless = options.format.escapeless;\n        newline = options.format.newline;\n        space = options.format.space;\n        if (options.format.compact) {\n            newline = space = indent = base = '';\n        }\n        parentheses = options.format.parentheses;\n        semicolons = options.format.semicolons;\n        safeConcatenation = options.format.safeConcatenation;\n        directive = options.directive;\n        parse = json ? null : options.parse;\n        sourceMap = options.sourceMap;\n        sourceCode = options.sourceCode;\n        preserveBlankLines = options.format.preserveBlankLines && sourceCode !== null;\n        extra = options;\n\n        if (sourceMap) {\n            if (!exports.browser) {\n                // We assume environment is node.js\n                // And prevent from including source-map by browserify\n                SourceNode = require('source-map').SourceNode;\n            } else {\n                SourceNode = global.sourceMap.SourceNode;\n            }\n        }\n\n        result = generateInternal(node);\n\n        if (!sourceMap) {\n            pair = {code: result.toString(), map: null};\n            return options.sourceMapWithCode ? pair : pair.code;\n        }\n\n\n        pair = result.toStringWithSourceMap({\n            file: options.file,\n            sourceRoot: options.sourceMapRoot\n        });\n\n        if (options.sourceContent) {\n            pair.map.setSourceContent(options.sourceMap,\n                                      options.sourceContent);\n        }\n\n        if (options.sourceMapWithCode) {\n            return pair;\n        }\n\n        return pair.map.toString();\n    }\n\n    FORMAT_MINIFY = {\n        indent: {\n            style: '',\n            base: 0\n        },\n        renumber: true,\n        hexadecimal: true,\n        quotes: 'auto',\n        escapeless: true,\n        compact: true,\n        parentheses: false,\n        semicolons: false\n    };\n\n    FORMAT_DEFAULTS = getDefaultOptions().format;\n\n    exports.version = require('./package.json').version;\n    exports.generate = generate;\n    exports.attachComments = estraverse.attachComments;\n    exports.Precedence = updateDeeply({}, Precedence);\n    exports.browser = false;\n    exports.FORMAT_MINIFY = FORMAT_MINIFY;\n    exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;\n}());\n/* vim: set sw=4 ts=4 et tw=80 : */\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACC,aAAY;EACT;;EAEA,IAAIA,MAAJ,EACIC,UADJ,EAEIC,gBAFJ,EAGIC,UAHJ,EAIIC,UAJJ,EAKIC,OALJ,EAMIC,IANJ,EAOIC,MAPJ,EAQIC,IARJ,EASIC,QATJ,EAUIC,WAVJ,EAWIC,MAXJ,EAYIC,UAZJ,EAaIC,OAbJ,EAcIC,KAdJ,EAeIC,WAfJ,EAgBIC,UAhBJ,EAiBIC,iBAjBJ,EAkBIC,SAlBJ,EAmBIC,KAnBJ,EAoBIC,KApBJ,EAqBIC,SArBJ,EAsBIC,UAtBJ,EAuBIC,kBAvBJ,EAwBIC,aAxBJ,EAyBIC,eAzBJ;EA2BArB,UAAU,GAAGsB,OAAO,CAAC,YAAD,CAApB;EACArB,OAAO,GAAGqB,OAAO,CAAC,SAAD,CAAjB;EAEA1B,MAAM,GAAGI,UAAU,CAACJ,MAApB,CAjCS,CAmCT;;EACA,SAAS2B,YAAT,CAAsBC,IAAtB,EAA4B;IACxB,OAAOC,aAAa,CAACC,UAAd,CAAyBC,cAAzB,CAAwCH,IAAI,CAACI,IAA7C,CAAP;EACH,CAtCQ,CAwCT;;;EACA,SAASC,WAAT,CAAqBL,IAArB,EAA2B;IACvB,OAAOC,aAAa,CAACK,SAAd,CAAwBH,cAAxB,CAAuCH,IAAI,CAACI,IAA5C,CAAP;EACH;;EAED/B,UAAU,GAAG;IACTkC,QAAQ,EAAE,CADD;IAETC,KAAK,EAAE,CAFE;IAGTC,UAAU,EAAE,CAHH;IAITC,WAAW,EAAE,CAJJ;IAKTC,aAAa,EAAE,CALN;IAMTC,SAAS,EAAE,CANF;IAOTC,UAAU,EAAE,CAPH;IAQTC,SAAS,EAAE,CARF;IASTC,UAAU,EAAE,CATH;IAUTC,UAAU,EAAE,CAVH;IAWTC,QAAQ,EAAE,CAXD;IAYTC,UAAU,EAAE,CAZH;IAaTC,YAAY,EAAE,EAbL;IAcTC,QAAQ,EAAE,EAdD;IAeTC,cAAc,EAAE,EAfP;IAgBTC,cAAc,EAAE,EAhBP;IAiBTC,KAAK,EAAE,EAjBE;IAkBTC,KAAK,EAAE,EAlBE;IAmBTC,OAAO,EAAE,EAnBA;IAoBTC,gBAAgB,EAAE,EApBT;IAqBTC,IAAI,EAAE,EArBG;IAsBTC,GAAG,EAAE,EAtBI;IAuBTC,cAAc,EAAE,EAvBP;IAwBTC,MAAM,EAAE,EAxBC;IAyBTC,OAAO,EAAE;EAzBA,CAAb;EA4BAzD,gBAAgB,GAAG;IACf,MAAMD,UAAU,CAACuC,SADF;IAEf,MAAMvC,UAAU,CAACwC,UAFF;IAGf,KAAKxC,UAAU,CAACyC,SAHD;IAIf,KAAKzC,UAAU,CAAC0C,UAJD;IAKf,KAAK1C,UAAU,CAAC2C,UALD;IAMf,MAAM3C,UAAU,CAAC4C,QANF;IAOf,MAAM5C,UAAU,CAAC4C,QAPF;IAQf,OAAO5C,UAAU,CAAC4C,QARH;IASf,OAAO5C,UAAU,CAAC4C,QATH;IAUf,MAAM5C,UAAU,CAAC4C,QAVF;IAWf,QAAQ5C,UAAU,CAAC4C,QAXJ;IAYf,KAAK5C,UAAU,CAAC6C,UAZD;IAaf,KAAK7C,UAAU,CAAC6C,UAbD;IAcf,MAAM7C,UAAU,CAAC6C,UAdF;IAef,MAAM7C,UAAU,CAAC6C,UAfF;IAgBf,MAAM7C,UAAU,CAAC6C,UAhBF;IAiBf,cAAc7C,UAAU,CAAC6C,UAjBV;IAkBf,MAAM7C,UAAU,CAAC8C,YAlBF;IAmBf,MAAM9C,UAAU,CAAC8C,YAnBF;IAoBf,OAAO9C,UAAU,CAAC8C,YApBH;IAqBf,KAAK9C,UAAU,CAAC+C,QArBD;IAsBf,KAAK/C,UAAU,CAAC+C,QAtBD;IAuBf,KAAK/C,UAAU,CAACgD,cAvBD;IAwBf,KAAKhD,UAAU,CAACgD,cAxBD;IAyBf,KAAKhD,UAAU,CAACgD,cAzBD;IA0Bf,MAAMhD,UAAU,CAACiD;EA1BF,CAAnB,CAzES,CAsGT;;EACA,IAAIU,UAAU,GAAG,CAAjB;EAAA,IACIC,YAAY,GAAG,KAAK,CADxB;EAAA,IAEIC,oBAAoB,GAAG,KAAK,CAFhC;EAAA,IAGIC,WAAW,GAAG,KAAK,CAHvB;EAAA,IAIIC,eAAe,GAAG,KAAK,CAJ3B;EAAA,IAKIC,eAAe,GAAG,KAAK,CAL3B,CAvGS,CA8GT;EACA;EACA;EACA;EACA;;EACA,IAAIC,KAAK,GAAGL,YAAY,GAAGC,oBAA3B;EAAA,IACIK,KAAK,GAAGP,UAAU,GAAGC,YADzB;EAAA,IAEIO,KAAK,GAAGR,UAAU,GAAGC,YAAb,GAA4BC,oBAFxC;EAAA,IAGIO,KAAK,GAAGT,UAHZ;EAAA,IAIIU,KAAK,GAAGR,oBAJZ;EAAA,IAKIS,KAAK,GAAGX,UAAU,GAAGE,oBALzB,CAnHS,CA0HT;EACA;EACA;EACA;EACA;EACA;;EACA,IAAIU,MAAM,GAAGZ,UAAb;EAAA,IACIa,MAAM,GAAGb,UAAU,GAAGK,eAD1B;EAAA,IAEIS,MAAM,GAAG,IAFb;EAAA,IAGIC,MAAM,GAAGf,UAAU,GAAGI,eAH1B;EAAA,IAIIY,MAAM,GAAGhB,UAAU,GAAGG,WAJ1B;;EAMA,SAASc,iBAAT,GAA6B;IACzB;IACA,OAAO;MACHtE,MAAM,EAAE,IADL;MAEHD,IAAI,EAAE,IAFH;MAGHc,KAAK,EAAE,IAHJ;MAIH0D,OAAO,EAAE,KAJN;MAKHC,MAAM,EAAE;QACJxE,MAAM,EAAE;UACJyE,KAAK,EAAE,MADH;UAEJ1E,IAAI,EAAE,CAFF;UAGJ2E,sBAAsB,EAAE;QAHpB,CADJ;QAMJpE,OAAO,EAAE,IANL;QAOJC,KAAK,EAAE,GAPH;QAQJN,IAAI,EAAE,KARF;QASJC,QAAQ,EAAE,KATN;QAUJC,WAAW,EAAE,KAVT;QAWJC,MAAM,EAAE,QAXJ;QAYJC,UAAU,EAAE,KAZR;QAaJsE,OAAO,EAAE,KAbL;QAcJnE,WAAW,EAAE,IAdT;QAeJC,UAAU,EAAE,IAfR;QAgBJC,iBAAiB,EAAE,KAhBf;QAiBJM,kBAAkB,EAAE;MAjBhB,CALL;MAwBH4D,GAAG,EAAE;QACDC,2CAA2C,EAAE,KAD5C;QAEDC,iBAAiB,EAAE;MAFlB,CAxBF;MA4BHhE,SAAS,EAAE,IA5BR;MA6BHiE,aAAa,EAAE,IA7BZ;MA8BHC,iBAAiB,EAAE,KA9BhB;MA+BHrE,SAAS,EAAE,KA/BR;MAgCHsE,GAAG,EAAE,IAhCF;MAiCHC,QAAQ,EAAE,IAjCP;MAkCHnE,UAAU,EAAE;IAlCT,CAAP;EAoCH;;EAED,SAASoE,YAAT,CAAsBC,GAAtB,EAA2BC,GAA3B,EAAgC;IAC5B,IAAIC,MAAM,GAAG,EAAb;;IAEA,KAAKD,GAAG,IAAI,CAAZ,EAAeA,GAAG,GAAG,CAArB,EAAwBA,GAAG,MAAM,CAAT,EAAYD,GAAG,IAAIA,GAA3C,EAAgD;MAC5C,IAAIC,GAAG,GAAG,CAAV,EAAa;QACTC,MAAM,IAAIF,GAAV;MACH;IACJ;;IAED,OAAOE,MAAP;EACH;;EAED,SAASC,iBAAT,CAA2BH,GAA3B,EAAgC;IAC5B,OAAQ,SAAD,CAAYI,IAAZ,CAAiBJ,GAAjB,CAAP;EACH;;EAED,SAASK,sBAAT,CAAgCL,GAAhC,EAAqC;IACjC,IAAIM,GAAG,GAAGN,GAAG,CAACO,MAAd;IACA,OAAOD,GAAG,IAAI5F,OAAO,CAAC8F,IAAR,CAAaC,gBAAb,CAA8BT,GAAG,CAACU,UAAJ,CAAeJ,GAAG,GAAG,CAArB,CAA9B,CAAd;EACH;;EAED,SAASK,KAAT,CAAeC,MAAf,EAAuBC,QAAvB,EAAiC;IAC7B,IAAIC,GAAJ;;IACA,KAAKA,GAAL,IAAYD,QAAZ,EAAsB;MAClB,IAAIA,QAAQ,CAACzE,cAAT,CAAwB0E,GAAxB,CAAJ,EAAkC;QAC9BF,MAAM,CAACE,GAAD,CAAN,GAAcD,QAAQ,CAACC,GAAD,CAAtB;MACH;IACJ;;IACD,OAAOF,MAAP;EACH;;EAED,SAASG,YAAT,CAAsBH,MAAtB,EAA8BC,QAA9B,EAAwC;IACpC,IAAIC,GAAJ,EAASE,GAAT;;IAEA,SAASC,YAAT,CAAsBL,MAAtB,EAA8B;MAC1B,OAAO,OAAOA,MAAP,KAAkB,QAAlB,IAA8BA,MAAM,YAAYM,MAAhD,IAA0D,EAAEN,MAAM,YAAYO,MAApB,CAAjE;IACH;;IAED,KAAKL,GAAL,IAAYD,QAAZ,EAAsB;MAClB,IAAIA,QAAQ,CAACzE,cAAT,CAAwB0E,GAAxB,CAAJ,EAAkC;QAC9BE,GAAG,GAAGH,QAAQ,CAACC,GAAD,CAAd;;QACA,IAAIG,YAAY,CAACD,GAAD,CAAhB,EAAuB;UACnB,IAAIC,YAAY,CAACL,MAAM,CAACE,GAAD,CAAP,CAAhB,EAA+B;YAC3BC,YAAY,CAACH,MAAM,CAACE,GAAD,CAAP,EAAcE,GAAd,CAAZ;UACH,CAFD,MAEO;YACHJ,MAAM,CAACE,GAAD,CAAN,GAAcC,YAAY,CAAC,EAAD,EAAKC,GAAL,CAA1B;UACH;QACJ,CAND,MAMO;UACHJ,MAAM,CAACE,GAAD,CAAN,GAAcE,GAAd;QACH;MACJ;IACJ;;IACD,OAAOJ,MAAP;EACH;;EAED,SAASQ,cAAT,CAAwBC,KAAxB,EAA+B;IAC3B,IAAInB,MAAJ,EAAYoB,KAAZ,EAAmBC,IAAnB,EAAyBC,QAAzB,EAAmCC,GAAnC;;IAEA,IAAIJ,KAAK,KAAKA,KAAd,EAAqB;MACjB,MAAM,IAAIK,KAAJ,CAAU,oCAAV,CAAN;IACH;;IACD,IAAIL,KAAK,GAAG,CAAR,IAAcA,KAAK,KAAK,CAAV,IAAe,IAAIA,KAAJ,GAAY,CAA7C,EAAiD;MAC7C,MAAM,IAAIK,KAAJ,CAAU,yCAAV,CAAN;IACH;;IAED,IAAIL,KAAK,KAAK,IAAI,CAAlB,EAAqB;MACjB,OAAOxG,IAAI,GAAG,MAAH,GAAYC,QAAQ,GAAG,OAAH,GAAa,QAA5C;IACH;;IAEDoF,MAAM,GAAG,KAAKmB,KAAd;;IACA,IAAI,CAACvG,QAAD,IAAaoF,MAAM,CAACK,MAAP,GAAgB,CAAjC,EAAoC;MAChC,OAAOL,MAAP;IACH;;IAEDoB,KAAK,GAAGpB,MAAM,CAACyB,OAAP,CAAe,GAAf,CAAR;;IACA,IAAI,CAAC9G,IAAD,IAASqF,MAAM,CAACQ,UAAP,CAAkB,CAAlB,MAAyB;IAAM;IAAxC,GAAmDY,KAAK,KAAK,CAAjE,EAAoE;MAChEA,KAAK,GAAG,CAAR;MACApB,MAAM,GAAGA,MAAM,CAAC0B,KAAP,CAAa,CAAb,CAAT;IACH;;IACDL,IAAI,GAAGrB,MAAP;IACAA,MAAM,GAAGA,MAAM,CAAC2B,OAAP,CAAe,IAAf,EAAqB,GAArB,CAAT;IACAL,QAAQ,GAAG,CAAX;;IACA,IAAI,CAACC,GAAG,GAAGF,IAAI,CAACI,OAAL,CAAa,GAAb,CAAP,IAA4B,CAAhC,EAAmC;MAC/BH,QAAQ,GAAG,CAACD,IAAI,CAACK,KAAL,CAAWH,GAAG,GAAG,CAAjB,CAAZ;MACAF,IAAI,GAAGA,IAAI,CAACK,KAAL,CAAW,CAAX,EAAcH,GAAd,CAAP;IACH;;IACD,IAAIH,KAAK,IAAI,CAAb,EAAgB;MACZE,QAAQ,IAAID,IAAI,CAAChB,MAAL,GAAce,KAAd,GAAsB,CAAlC;MACAC,IAAI,GAAG,EAAEA,IAAI,CAACK,KAAL,CAAW,CAAX,EAAcN,KAAd,IAAuBC,IAAI,CAACK,KAAL,CAAWN,KAAK,GAAG,CAAnB,CAAzB,IAAkD,EAAzD;IACH;;IACDG,GAAG,GAAG,CAAN;;IACA,OAAOF,IAAI,CAACb,UAAL,CAAgBa,IAAI,CAAChB,MAAL,GAAckB,GAAd,GAAoB,CAApC,MAA2C;IAAM;IAAxD,EAAiE;MAC7D,EAAEA,GAAF;IACH;;IACD,IAAIA,GAAG,KAAK,CAAZ,EAAe;MACXD,QAAQ,IAAIC,GAAZ;MACAF,IAAI,GAAGA,IAAI,CAACK,KAAL,CAAW,CAAX,EAAcH,GAAd,CAAP;IACH;;IACD,IAAID,QAAQ,KAAK,CAAjB,EAAoB;MAChBD,IAAI,IAAI,MAAMC,QAAd;IACH;;IACD,IAAI,CAACD,IAAI,CAAChB,MAAL,GAAcL,MAAM,CAACK,MAArB,IACQxF,WAAW,IAAIsG,KAAK,GAAG,IAAvB,IAA+BS,IAAI,CAACC,KAAL,CAAWV,KAAX,MAAsBA,KAArD,IAA8D,CAACE,IAAI,GAAG,OAAOF,KAAK,CAACW,QAAN,CAAe,EAAf,CAAf,EAAmCzB,MAAnC,GAA4CL,MAAM,CAACK,MAD1H,KAEI,CAACgB,IAAD,KAAUF,KAFlB,EAEyB;MACrBnB,MAAM,GAAGqB,IAAT;IACH;;IAED,OAAOrB,MAAP;EACH,CA1RQ,CA4RT;EACA;;;EAEA,SAAS+B,qBAAT,CAA+BC,EAA/B,EAAmCC,mBAAnC,EAAwD;IACpD;IACA,IAAI,CAACD,EAAE,GAAG,CAAC,CAAP,MAAc,MAAlB,EAA0B;MACtB,OAAO,CAACC,mBAAmB,GAAG,GAAH,GAAS,KAA7B,KAAwCD,EAAE,KAAK,MAAR,GAAkB,MAAlB,GAA2B,MAAlE,CAAP;IACH,CAFD,MAEO,IAAIA,EAAE,KAAK,EAAP,IAAaA,EAAE,KAAK,EAAxB,EAA4B;MAAG;MAClC,OAAO,CAACC,mBAAmB,GAAG,EAAH,GAAQ,IAA5B,KAAsCD,EAAE,KAAK,EAAR,GAAc,GAAd,GAAoB,GAAzD,CAAP;IACH;;IACD,OAAOE,MAAM,CAACC,YAAP,CAAoBH,EAApB,CAAP;EACH;;EAED,SAASI,cAAT,CAAwBC,GAAxB,EAA6B;IACzB,IAAIC,KAAJ,EAAWtC,MAAX,EAAmBuC,KAAnB,EAA0BC,CAA1B,EAA6BC,EAA7B,EAAiCT,EAAjC,EAAqCU,gBAArC,EAAuDT,mBAAvD;IAEAjC,MAAM,GAAGqC,GAAG,CAACP,QAAJ,EAAT;;IAEA,IAAIO,GAAG,CAACM,MAAR,EAAgB;MACZ;MACAL,KAAK,GAAGtC,MAAM,CAACsC,KAAP,CAAa,YAAb,CAAR;;MACA,IAAI,CAACA,KAAL,EAAY;QACR,OAAOtC,MAAP;MACH;;MAEDuC,KAAK,GAAGD,KAAK,CAAC,CAAD,CAAb;MACAtC,MAAM,GAAG,EAAT;MAEA0C,gBAAgB,GAAG,KAAnB;MACAT,mBAAmB,GAAG,KAAtB;;MACA,KAAKO,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGJ,GAAG,CAACM,MAAJ,CAAWtC,MAA5B,EAAoCmC,CAAC,GAAGC,EAAxC,EAA4C,EAAED,CAA9C,EAAiD;QAC7CR,EAAE,GAAGK,GAAG,CAACM,MAAJ,CAAWnC,UAAX,CAAsBgC,CAAtB,CAAL;;QAEA,IAAI,CAACP,mBAAL,EAA0B;UACtB,IAAIS,gBAAJ,EAAsB;YAClB,IAAIV,EAAE,KAAK,EAAX,EAAe;cAAG;cACdU,gBAAgB,GAAG,KAAnB;YACH;UACJ,CAJD,MAIO;YACH,IAAIV,EAAE,KAAK,EAAX,EAAe;cAAG;cACdhC,MAAM,IAAI,IAAV;YACH,CAFD,MAEO,IAAIgC,EAAE,KAAK,EAAX,EAAe;cAAG;cACrBU,gBAAgB,GAAG,IAAnB;YACH;UACJ;;UACD1C,MAAM,IAAI+B,qBAAqB,CAACC,EAAD,EAAKC,mBAAL,CAA/B;UACAA,mBAAmB,GAAGD,EAAE,KAAK,EAA7B,CAbsB,CAaY;QACrC,CAdD,MAcO;UACH;UACAhC,MAAM,IAAI+B,qBAAqB,CAACC,EAAD,EAAKC,mBAAL,CAA/B,CAFG,CAGH;;UACAA,mBAAmB,GAAG,KAAtB;QACH;MACJ;;MAED,OAAO,MAAMjC,MAAN,GAAe,GAAf,GAAqBuC,KAA5B;IACH;;IAED,OAAOvC,MAAP;EACH;;EAED,SAAS4C,sBAAT,CAAgCtC,IAAhC,EAAsCuC,IAAtC,EAA4C;IACxC,IAAIC,GAAJ;;IAEA,IAAIxC,IAAI,KAAK;IAAM;IAAnB,EAA6B;MACzB,OAAO,KAAP;IACH;;IAED,IAAIA,IAAI,KAAK;IAAM;IAAnB,EAA6B;MACzB,OAAO,KAAP;IACH;;IAED,IAAIA,IAAI,KAAK;IAAM;IAAnB,EAA6B;MACzB,OAAO,KAAP;IACH;;IAEDwC,GAAG,GAAGxC,IAAI,CAACwB,QAAL,CAAc,EAAd,EAAkBiB,WAAlB,EAAN;;IACA,IAAIpI,IAAI,IAAI2F,IAAI,GAAG,IAAnB,EAAyB;MACrB,OAAO,QAAQ,OAAOoB,KAAP,CAAaoB,GAAG,CAACzC,MAAjB,CAAR,GAAmCyC,GAA1C;IACH,CAFD,MAEO,IAAIxC,IAAI,KAAK,MAAT,IAAmB,CAAC9F,OAAO,CAAC8F,IAAR,CAAa0C,cAAb,CAA4BH,IAA5B,CAAxB,EAA2D;MAC9D,OAAO,KAAP;IACH,CAFM,MAEA,IAAIvC,IAAI,KAAK;IAAQ;IAArB,EAA+B;MAAE;MACpC,OAAO,OAAP;IACH,CAFM,MAEA;MACH,OAAO,QAAQ,KAAKoB,KAAL,CAAWoB,GAAG,CAACzC,MAAf,CAAR,GAAiCyC,GAAxC;IACH;EACJ;;EAED,SAASG,yBAAT,CAAmC3C,IAAnC,EAAyC;IACrC,IAAIA,IAAI,KAAK;IAAM;IAAnB,EAA4B;MACxB,OAAO,MAAP;IACH;;IAED,IAAIA,IAAI,KAAK;IAAM;IAAnB,EAA6B;MACzB,OAAO,KAAP;IACH;;IAED,IAAIA,IAAI,KAAK;IAAM;IAAnB,EAA6B;MACzB,OAAO,KAAP;IACH;;IAED,IAAIA,IAAI,KAAK,MAAb,EAAqB;MACjB,OAAO,SAAP;IACH;;IAED,IAAIA,IAAI,KAAK,MAAb,EAAqB;MACjB,OAAO,SAAP;IACH;;IAED,MAAM,IAAIkB,KAAJ,CAAU,kCAAV,CAAN;EACH;;EAED,SAAS0B,eAAT,CAAyBpD,GAAzB,EAA8B;IAC1B,IAAI0C,CAAJ,EAAOC,EAAP,EAAWnC,IAAX,EAAiB6C,KAAjB;IAEAA,KAAK,GAAGrI,MAAM,KAAK,QAAX,GAAsB,GAAtB,GAA4B,IAApC;;IACA,KAAK0H,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAG3C,GAAG,CAACO,MAArB,EAA6BmC,CAAC,GAAGC,EAAjC,EAAqC,EAAED,CAAvC,EAA0C;MACtClC,IAAI,GAAGR,GAAG,CAACU,UAAJ,CAAegC,CAAf,CAAP;;MACA,IAAIlC,IAAI,KAAK;MAAM;MAAnB,EAA4B;QACxB6C,KAAK,GAAG,GAAR;QACA;MACH,CAHD,MAGO,IAAI7C,IAAI,KAAK;MAAM;MAAnB,EAA4B;QAC/B6C,KAAK,GAAG,IAAR;QACA;MACH,CAHM,MAGA,IAAI7C,IAAI,KAAK;MAAM;MAAnB,EAA4B;QAC/B,EAAEkC,CAAF;MACH;IACJ;;IAED,OAAOW,KAAK,GAAGrD,GAAR,GAAcqD,KAArB;EACH;;EAED,SAASC,YAAT,CAAsBtD,GAAtB,EAA2B;IACvB,IAAIE,MAAM,GAAG,EAAb;IAAA,IAAiBwC,CAAjB;IAAA,IAAoBpC,GAApB;IAAA,IAAyBE,IAAzB;IAAA,IAA+B+C,YAAY,GAAG,CAA9C;IAAA,IAAiDC,YAAY,GAAG,CAAhE;IAAA,IAAmEC,MAAnE;IAAA,IAA2EJ,KAA3E;;IAEA,KAAKX,CAAC,GAAG,CAAJ,EAAOpC,GAAG,GAAGN,GAAG,CAACO,MAAtB,EAA8BmC,CAAC,GAAGpC,GAAlC,EAAuC,EAAEoC,CAAzC,EAA4C;MACxClC,IAAI,GAAGR,GAAG,CAACU,UAAJ,CAAegC,CAAf,CAAP;;MACA,IAAIlC,IAAI,KAAK;MAAM;MAAnB,EAA4B;QACxB,EAAE+C,YAAF;MACH,CAFD,MAEO,IAAI/C,IAAI,KAAK;MAAM;MAAnB,EAA4B;QAC/B,EAAEgD,YAAF;MACH,CAFM,MAEA,IAAIhD,IAAI,KAAK;MAAM;MAAf,GAA0B3F,IAA9B,EAAoC;QACvCqF,MAAM,IAAI,IAAV;MACH,CAFM,MAEA,IAAIxF,OAAO,CAAC8F,IAAR,CAAaC,gBAAb,CAA8BD,IAA9B,KAAuCA,IAAI,KAAK;MAAM;MAA1D,EAAmE;QACtEN,MAAM,IAAIiD,yBAAyB,CAAC3C,IAAD,CAAnC;QACA;MACH,CAHM,MAGA,IAAI,CAAC9F,OAAO,CAAC8F,IAAR,CAAakD,mBAAb,CAAiClD,IAAjC,CAAD,KAA4C3F,IAAI,IAAI2F,IAAI,GAAG;MAAM;MAArB,GAAiC,CAAC3F,IAAD,IAAS,CAACI,UAAV,KAAyBuF,IAAI,GAAG;MAAM;MAAb,GAAyBA,IAAI,GAAG;MAAM;MAA/D,CAA7E,CAAJ,EAA2J;QAC9JN,MAAM,IAAI4C,sBAAsB,CAACtC,IAAD,EAAOR,GAAG,CAACU,UAAJ,CAAegC,CAAC,GAAG,CAAnB,CAAP,CAAhC;QACA;MACH;;MACDxC,MAAM,IAAIkC,MAAM,CAACC,YAAP,CAAoB7B,IAApB,CAAV;IACH;;IAEDiD,MAAM,GAAG,EAAEzI,MAAM,KAAK,QAAX,IAAwBA,MAAM,KAAK,MAAX,IAAqBwI,YAAY,GAAGD,YAA9D,CAAT;IACAF,KAAK,GAAGI,MAAM,GAAG,IAAH,GAAU,GAAxB;;IAEA,IAAI,EAAEA,MAAM,GAAGF,YAAH,GAAkBC,YAA1B,CAAJ,EAA6C;MACzC,OAAOH,KAAK,GAAGnD,MAAR,GAAiBmD,KAAxB;IACH;;IAEDrD,GAAG,GAAGE,MAAN;IACAA,MAAM,GAAGmD,KAAT;;IAEA,KAAKX,CAAC,GAAG,CAAJ,EAAOpC,GAAG,GAAGN,GAAG,CAACO,MAAtB,EAA8BmC,CAAC,GAAGpC,GAAlC,EAAuC,EAAEoC,CAAzC,EAA4C;MACxClC,IAAI,GAAGR,GAAG,CAACU,UAAJ,CAAegC,CAAf,CAAP;;MACA,IAAKlC,IAAI,KAAK;MAAM;MAAf,GAA0BiD,MAA3B,IAAuCjD,IAAI,KAAK;MAAM;MAAf,GAA0B,CAACiD,MAAtE,EAA+E;QAC3EvD,MAAM,IAAI,IAAV;MACH;;MACDA,MAAM,IAAIkC,MAAM,CAACC,YAAP,CAAoB7B,IAApB,CAAV;IACH;;IAED,OAAON,MAAM,GAAGmD,KAAhB;EACH;EAED;AACJ;AACA;AACA;;;EACI,SAASM,eAAT,CAAyBC,GAAzB,EAA8B;IAC1B,IAAIlB,CAAJ;IAAA,IAAOC,EAAP;IAAA,IAAWkB,IAAX;IAAA,IAAiB3D,MAAM,GAAG,EAA1B;;IACA,KAAKwC,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGiB,GAAG,CAACrD,MAArB,EAA6BmC,CAAC,GAAGC,EAAjC,EAAqC,EAAED,CAAvC,EAA0C;MACtCmB,IAAI,GAAGD,GAAG,CAAClB,CAAD,CAAV;MACAxC,MAAM,IAAI4D,KAAK,CAACC,OAAN,CAAcF,IAAd,IAAsBF,eAAe,CAACE,IAAD,CAArC,GAA8CA,IAAxD;IACH;;IACD,OAAO3D,MAAP;EACH;EAED;AACJ;AACA;;;EACI,SAAS8D,sBAAT,CAAgCC,SAAhC,EAA2ChI,IAA3C,EAAiD;IAC7C,IAAI,CAACP,SAAL,EAAgB;MACZ;MACA;MACA;MACA,IAAIoI,KAAK,CAACC,OAAN,CAAcE,SAAd,CAAJ,EAA8B;QAC1B,OAAON,eAAe,CAACM,SAAD,CAAtB;MACH,CAFD,MAEO;QACH,OAAOA,SAAP;MACH;IACJ;;IACD,IAAIhI,IAAI,IAAI,IAAZ,EAAkB;MACd,IAAIgI,SAAS,YAAYzJ,UAAzB,EAAqC;QACjC,OAAOyJ,SAAP;MACH,CAFD,MAEO;QACHhI,IAAI,GAAG,EAAP;MACH;IACJ;;IACD,IAAIA,IAAI,CAACiI,GAAL,IAAY,IAAhB,EAAsB;MAClB,OAAO,IAAI1J,UAAJ,CAAe,IAAf,EAAqB,IAArB,EAA2BkB,SAA3B,EAAsCuI,SAAtC,EAAiDhI,IAAI,CAACkI,IAAL,IAAa,IAA9D,CAAP;IACH;;IACD,OAAO,IAAI3J,UAAJ,CAAeyB,IAAI,CAACiI,GAAL,CAASE,KAAT,CAAeC,IAA9B,EAAoCpI,IAAI,CAACiI,GAAL,CAASE,KAAT,CAAeE,MAAnD,EAA4D5I,SAAS,KAAK,IAAd,GAAqBO,IAAI,CAACiI,GAAL,CAASrB,MAAT,IAAmB,IAAxC,GAA+CnH,SAA3G,EAAuHuI,SAAvH,EAAkIhI,IAAI,CAACkI,IAAL,IAAa,IAA/I,CAAP;EACH;;EAED,SAASI,YAAT,GAAwB;IACpB,OAAQpJ,KAAD,GAAUA,KAAV,GAAkB,GAAzB;EACH;;EAED,SAASqJ,IAAT,CAAcC,IAAd,EAAoBC,KAApB,EAA2B;IACvB,IAAIC,UAAJ,EACIC,WADJ,EAEIC,YAFJ,EAGIC,aAHJ;IAKAH,UAAU,GAAGX,sBAAsB,CAACS,IAAD,CAAtB,CAA6BzC,QAA7B,EAAb;;IACA,IAAI2C,UAAU,CAACpE,MAAX,KAAsB,CAA1B,EAA6B;MACzB,OAAO,CAACmE,KAAD,CAAP;IACH;;IAEDE,WAAW,GAAGZ,sBAAsB,CAACU,KAAD,CAAtB,CAA8B1C,QAA9B,EAAd;;IACA,IAAI4C,WAAW,CAACrE,MAAZ,KAAuB,CAA3B,EAA8B;MAC1B,OAAO,CAACkE,IAAD,CAAP;IACH;;IAEDI,YAAY,GAAGF,UAAU,CAACjE,UAAX,CAAsBiE,UAAU,CAACpE,MAAX,GAAoB,CAA1C,CAAf;IACAuE,aAAa,GAAGF,WAAW,CAAClE,UAAZ,CAAuB,CAAvB,CAAhB;;IAEA,IAAI,CAACmE,YAAY,KAAK;IAAM;IAAvB,GAAkCA,YAAY,KAAK;IAAM;IAA1D,KAAsEA,YAAY,KAAKC,aAAvF,IACApK,OAAO,CAAC8F,IAAR,CAAakD,mBAAb,CAAiCmB,YAAjC,KAAkDnK,OAAO,CAAC8F,IAAR,CAAakD,mBAAb,CAAiCoB,aAAjC,CADlD,IAEAD,YAAY,KAAK;IAAM;IAAvB,GAAkCC,aAAa,KAAK;IAAM;IAF9D,EAEuE;MAAE;MACrE,OAAO,CAACL,IAAD,EAAOF,YAAY,EAAnB,EAAuBG,KAAvB,CAAP;IACH,CAJD,MAIO,IAAIhK,OAAO,CAAC8F,IAAR,CAAauE,YAAb,CAA0BF,YAA1B,KAA2CnK,OAAO,CAAC8F,IAAR,CAAaC,gBAAb,CAA8BoE,YAA9B,CAA3C,IACHnK,OAAO,CAAC8F,IAAR,CAAauE,YAAb,CAA0BD,aAA1B,CADG,IACyCpK,OAAO,CAAC8F,IAAR,CAAaC,gBAAb,CAA8BqE,aAA9B,CAD7C,EAC2F;MAC9F,OAAO,CAACL,IAAD,EAAOC,KAAP,CAAP;IACH;;IACD,OAAO,CAACD,IAAD,EAAOtJ,KAAP,EAAcuJ,KAAd,CAAP;EACH;;EAED,SAASM,SAAT,CAAmBC,IAAnB,EAAyB;IACrB,OAAO,CAACtK,IAAD,EAAOsK,IAAP,CAAP;EACH;;EAED,SAASC,UAAT,CAAoBC,EAApB,EAAwB;IACpB,IAAIC,YAAJ;IACAA,YAAY,GAAGzK,IAAf;IACAA,IAAI,IAAIC,MAAR;IACAuK,EAAE,CAACxK,IAAD,CAAF;IACAA,IAAI,GAAGyK,YAAP;EACH;;EAED,SAASC,eAAT,CAAyBrF,GAAzB,EAA8B;IAC1B,IAAI0C,CAAJ;;IACA,KAAKA,CAAC,GAAG1C,GAAG,CAACO,MAAJ,GAAa,CAAtB,EAAyBmC,CAAC,IAAI,CAA9B,EAAiC,EAAEA,CAAnC,EAAsC;MAClC,IAAIhI,OAAO,CAAC8F,IAAR,CAAaC,gBAAb,CAA8BT,GAAG,CAACU,UAAJ,CAAegC,CAAf,CAA9B,CAAJ,EAAsD;QAClD;MACH;IACJ;;IACD,OAAQ1C,GAAG,CAACO,MAAJ,GAAa,CAAd,GAAmBmC,CAA1B;EACH;;EAED,SAASpD,sBAAT,CAAgC+B,KAAhC,EAAuCiE,WAAvC,EAAoD;IAChD,IAAIC,KAAJ,EAAW7C,CAAX,EAAcpC,GAAd,EAAmB+D,IAAnB,EAAyBmB,CAAzB,EAA4BC,MAA5B,EAAoCL,YAApC,EAAkDM,EAAlD;IAEAH,KAAK,GAAGlE,KAAK,CAACsE,KAAN,CAAY,aAAZ,CAAR;IACAF,MAAM,GAAGG,MAAM,CAACC,SAAhB,CAJgD,CAMhD;;IACA,KAAKnD,CAAC,GAAG,CAAJ,EAAOpC,GAAG,GAAGiF,KAAK,CAAChF,MAAxB,EAAgCmC,CAAC,GAAGpC,GAApC,EAAyC,EAAEoC,CAA3C,EAA8C;MAC1C2B,IAAI,GAAGkB,KAAK,CAAC7C,CAAD,CAAZ;MACA8C,CAAC,GAAG,CAAJ;;MACA,OAAOA,CAAC,GAAGnB,IAAI,CAAC9D,MAAT,IAAmB7F,OAAO,CAAC8F,IAAR,CAAauE,YAAb,CAA0BV,IAAI,CAAC3D,UAAL,CAAgB8E,CAAhB,CAA1B,CAA1B,EAAyE;QACrE,EAAEA,CAAF;MACH;;MACD,IAAIC,MAAM,GAAGD,CAAb,EAAgB;QACZC,MAAM,GAAGD,CAAT;MACH;IACJ;;IAED,IAAI,OAAOF,WAAP,KAAuB,WAA3B,EAAwC;MACpC;MACA;MACA;MACA;MACA;MACA;MACAF,YAAY,GAAGzK,IAAf;;MACA,IAAI4K,KAAK,CAAC,CAAD,CAAL,CAASE,MAAT,MAAqB,GAAzB,EAA8B;QAC1BH,WAAW,IAAI,GAAf;MACH;;MACD3K,IAAI,GAAG2K,WAAP;IACH,CAZD,MAYO;MACH,IAAIG,MAAM,GAAG,CAAb,EAAgB;QACZ;QACA;QACA;QACA;QACA;QACA,EAAEA,MAAF;MACH;;MACDL,YAAY,GAAGzK,IAAf;IACH;;IAED,KAAK+H,CAAC,GAAG,CAAJ,EAAOpC,GAAG,GAAGiF,KAAK,CAAChF,MAAxB,EAAgCmC,CAAC,GAAGpC,GAApC,EAAyC,EAAEoC,CAA3C,EAA8C;MAC1CgD,EAAE,GAAG1B,sBAAsB,CAACgB,SAAS,CAACO,KAAK,CAAC7C,CAAD,CAAL,CAASd,KAAT,CAAe6D,MAAf,CAAD,CAAV,CAA3B;MACAF,KAAK,CAAC7C,CAAD,CAAL,GAAWhH,SAAS,GAAGgK,EAAE,CAAClB,IAAH,CAAQ,EAAR,CAAH,GAAiBkB,EAArC;IACH;;IAED/K,IAAI,GAAGyK,YAAP;IAEA,OAAOG,KAAK,CAACf,IAAN,CAAW,IAAX,CAAP;EACH;;EAED,SAASsB,eAAT,CAAyB3G,OAAzB,EAAkCmG,WAAlC,EAA+C;IAC3C,IAAInG,OAAO,CAAC9C,IAAR,KAAiB,MAArB,EAA6B;MACzB,IAAIgE,sBAAsB,CAAClB,OAAO,CAACkC,KAAT,CAA1B,EAA2C;QACvC,OAAO,OAAOlC,OAAO,CAACkC,KAAtB;MACH,CAFD,MAEO;QACH;QACA,IAAInB,MAAM,GAAG,OAAOf,OAAO,CAACkC,KAA5B;;QACA,IAAI,CAACzF,kBAAL,EAAyB;UACrBsE,MAAM,IAAI,IAAV;QACH;;QACD,OAAOA,MAAP;MACH;IACJ;;IACD,IAAI1E,KAAK,CAAC4D,MAAN,CAAaxE,MAAb,CAAoB0E,sBAApB,IAA8C,SAASc,IAAT,CAAcjB,OAAO,CAACkC,KAAtB,CAAlD,EAAgF;MAC5E,OAAO/B,sBAAsB,CAAC,OAAOH,OAAO,CAACkC,KAAf,GAAuB,IAAxB,EAA8BiE,WAA9B,CAA7B;IACH;;IACD,OAAO,OAAOnG,OAAO,CAACkC,KAAf,GAAuB,IAA9B;EACH;;EAED,SAAS0E,WAAT,CAAqBd,IAArB,EAA2B/E,MAA3B,EAAmC;IAC/B,IAAIwC,CAAJ,EAAOpC,GAAP,EAAYnB,OAAZ,EAAqB6G,IAArB,EAA2BC,kBAA3B,EAA+CX,WAA/C,EAA4DY,QAA5D,EACIC,QADJ,EACcC,KADd,EACqBC,SADrB,EACgCC,MADhC,EACwCC,KADxC,EAC+CC,MAD/C,EACuDC,KADvD;;IAGA,IAAIxB,IAAI,CAACyB,eAAL,IAAwBzB,IAAI,CAACyB,eAAL,CAAqBnG,MAArB,GAA8B,CAA1D,EAA6D;MACzDyF,IAAI,GAAG9F,MAAP;;MAEA,IAAItE,kBAAJ,EAAwB;QACpBuD,OAAO,GAAG8F,IAAI,CAACyB,eAAL,CAAqB,CAArB,CAAV;QACAxG,MAAM,GAAG,EAAT;QAEAiG,QAAQ,GAAGhH,OAAO,CAACwH,aAAnB;QACAP,KAAK,GAAGjH,OAAO,CAACiH,KAAhB;QAEAE,MAAM,GAAG3K,UAAU,CAACiL,SAAX,CAAqBT,QAAQ,CAAC,CAAD,CAA7B,EAAkCC,KAAK,CAAC,CAAD,CAAvC,CAAT;QACAK,KAAK,GAAG,CAACH,MAAM,CAAC9D,KAAP,CAAa,KAAb,KAAuB,EAAxB,EAA4BjC,MAApC;;QACA,IAAIkG,KAAK,GAAG,CAAZ,EAAe;UACXvG,MAAM,CAAC2G,IAAP,CAAY9G,YAAY,CAAC,IAAD,EAAO0G,KAAP,CAAxB;UACAvG,MAAM,CAAC2G,IAAP,CAAY7B,SAAS,CAACc,eAAe,CAAC3G,OAAD,CAAhB,CAArB;QACH,CAHD,MAGO;UACHe,MAAM,CAAC2G,IAAP,CAAYP,MAAZ;UACApG,MAAM,CAAC2G,IAAP,CAAYf,eAAe,CAAC3G,OAAD,CAA3B;QACH;;QAEDkH,SAAS,GAAGD,KAAZ;;QAEA,KAAK1D,CAAC,GAAG,CAAJ,EAAOpC,GAAG,GAAG2E,IAAI,CAACyB,eAAL,CAAqBnG,MAAvC,EAA+CmC,CAAC,GAAGpC,GAAnD,EAAwDoC,CAAC,EAAzD,EAA6D;UACzDvD,OAAO,GAAG8F,IAAI,CAACyB,eAAL,CAAqBhE,CAArB,CAAV;UACA0D,KAAK,GAAGjH,OAAO,CAACiH,KAAhB;UAEAG,KAAK,GAAG5K,UAAU,CAACiL,SAAX,CAAqBP,SAAS,CAAC,CAAD,CAA9B,EAAmCD,KAAK,CAAC,CAAD,CAAxC,CAAR;UACAK,KAAK,GAAG,CAACF,KAAK,CAAC/D,KAAN,CAAY,KAAZ,KAAsB,EAAvB,EAA2BjC,MAAnC;UACAL,MAAM,CAAC2G,IAAP,CAAY9G,YAAY,CAAC,IAAD,EAAO0G,KAAP,CAAxB;UACAvG,MAAM,CAAC2G,IAAP,CAAY7B,SAAS,CAACc,eAAe,CAAC3G,OAAD,CAAhB,CAArB;UAEAkH,SAAS,GAAGD,KAAZ;QACH;;QAEDI,MAAM,GAAG7K,UAAU,CAACiL,SAAX,CAAqBR,KAAK,CAAC,CAAD,CAA1B,EAA+BD,QAAQ,CAAC,CAAD,CAAvC,CAAT;QACAM,KAAK,GAAG,CAACD,MAAM,CAAChE,KAAP,CAAa,KAAb,KAAuB,EAAxB,EAA4BjC,MAApC;QACAL,MAAM,CAAC2G,IAAP,CAAY9G,YAAY,CAAC,IAAD,EAAO0G,KAAP,CAAxB;MACH,CAlCD,MAkCO;QACHtH,OAAO,GAAG8F,IAAI,CAACyB,eAAL,CAAqB,CAArB,CAAV;QACAxG,MAAM,GAAG,EAAT;;QACA,IAAI5E,iBAAiB,IAAI2J,IAAI,CAAC5I,IAAL,KAAchC,MAAM,CAACyM,OAA1C,IAAqD7B,IAAI,CAAC8B,IAAL,CAAUxG,MAAV,KAAqB,CAA9E,EAAiF;UAC7EL,MAAM,CAAC2G,IAAP,CAAY,IAAZ;QACH;;QACD3G,MAAM,CAAC2G,IAAP,CAAYf,eAAe,CAAC3G,OAAD,CAA3B;;QACA,IAAI,CAACkB,sBAAsB,CAAC2D,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+B8B,QAA/B,EAAD,CAA3B,EAAwE;UACpE9B,MAAM,CAAC2G,IAAP,CAAY,IAAZ;QACH;;QAED,KAAKnE,CAAC,GAAG,CAAJ,EAAOpC,GAAG,GAAG2E,IAAI,CAACyB,eAAL,CAAqBnG,MAAvC,EAA+CmC,CAAC,GAAGpC,GAAnD,EAAwD,EAAEoC,CAA1D,EAA6D;UACzDvD,OAAO,GAAG8F,IAAI,CAACyB,eAAL,CAAqBhE,CAArB,CAAV;UACAwD,QAAQ,GAAG,CAACJ,eAAe,CAAC3G,OAAD,CAAhB,CAAX;;UACA,IAAI,CAACkB,sBAAsB,CAAC2D,sBAAsB,CAACkC,QAAD,CAAtB,CAAiClE,QAAjC,EAAD,CAA3B,EAA0E;YACtEkE,QAAQ,CAACW,IAAT,CAAc,IAAd;UACH;;UACD3G,MAAM,CAAC2G,IAAP,CAAY7B,SAAS,CAACkB,QAAD,CAArB;QACH;MACJ;;MAEDhG,MAAM,CAAC2G,IAAP,CAAY7B,SAAS,CAACgB,IAAD,CAArB;IACH;;IAED,IAAIf,IAAI,CAAC+B,gBAAT,EAA2B;MAEvB,IAAIpL,kBAAJ,EAAwB;QACpBuD,OAAO,GAAG8F,IAAI,CAAC+B,gBAAL,CAAsB,CAAtB,CAAV;QACAb,QAAQ,GAAGhH,OAAO,CAACwH,aAAnB;QACAP,KAAK,GAAGjH,OAAO,CAACiH,KAAhB;QAEAE,MAAM,GAAG3K,UAAU,CAACiL,SAAX,CAAqBT,QAAQ,CAAC,CAAD,CAA7B,EAAkCC,KAAK,CAAC,CAAD,CAAvC,CAAT;QACAK,KAAK,GAAG,CAACH,MAAM,CAAC9D,KAAP,CAAa,KAAb,KAAuB,EAAxB,EAA4BjC,MAApC;;QAEA,IAAIkG,KAAK,GAAG,CAAZ,EAAe;UACXvG,MAAM,CAAC2G,IAAP,CAAY9G,YAAY,CAAC,IAAD,EAAO0G,KAAP,CAAxB;UACAvG,MAAM,CAAC2G,IAAP,CAAY7B,SAAS,CAACc,eAAe,CAAC3G,OAAD,CAAhB,CAArB;QACH,CAHD,MAGO;UACHe,MAAM,CAAC2G,IAAP,CAAYP,MAAZ;UACApG,MAAM,CAAC2G,IAAP,CAAYf,eAAe,CAAC3G,OAAD,CAA3B;QACH;MACJ,CAfD,MAeO;QACH8G,kBAAkB,GAAG,CAAC5F,sBAAsB,CAAC2D,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+B8B,QAA/B,EAAD,CAA5C;QACAsD,WAAW,GAAGvF,YAAY,CAAC,GAAD,EAAMsF,eAAe,CAACrB,sBAAsB,CAAC,CAACrJ,IAAD,EAAOuF,MAAP,EAAetF,MAAf,CAAD,CAAtB,CAA+CoH,QAA/C,EAAD,CAArB,CAA1B;;QACA,KAAKU,CAAC,GAAG,CAAJ,EAAOpC,GAAG,GAAG2E,IAAI,CAAC+B,gBAAL,CAAsBzG,MAAxC,EAAgDmC,CAAC,GAAGpC,GAApD,EAAyD,EAAEoC,CAA3D,EAA8D;UAC1DvD,OAAO,GAAG8F,IAAI,CAAC+B,gBAAL,CAAsBtE,CAAtB,CAAV;;UACA,IAAIuD,kBAAJ,EAAwB;YACpB;YACA;YACA;YACA;YACA;YACA,IAAIvD,CAAC,KAAK,CAAV,EAAa;cACT;cACAxC,MAAM,GAAG,CAACA,MAAD,EAAStF,MAAT,CAAT;YACH,CAHD,MAGO;cACHsF,MAAM,GAAG,CAACA,MAAD,EAASoF,WAAT,CAAT;YACH;;YACDpF,MAAM,CAAC2G,IAAP,CAAYf,eAAe,CAAC3G,OAAD,EAAUmG,WAAV,CAA3B;UACH,CAbD,MAaO;YACHpF,MAAM,GAAG,CAACA,MAAD,EAAS8E,SAAS,CAACc,eAAe,CAAC3G,OAAD,CAAhB,CAAlB,CAAT;UACH;;UACD,IAAIuD,CAAC,KAAKpC,GAAG,GAAG,CAAZ,IAAiB,CAACD,sBAAsB,CAAC2D,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+B8B,QAA/B,EAAD,CAA5C,EAAyF;YACrF9B,MAAM,GAAG,CAACA,MAAD,EAAS,IAAT,CAAT;UACH;QACJ;MACJ;IACJ;;IAED,OAAOA,MAAP;EACH;;EAED,SAAS+G,kBAAT,CAA4B7C,KAA5B,EAAmC8C,GAAnC,EAAwChH,MAAxC,EAAgD;IAC5C,IAAIsF,CAAJ;IAAA,IAAO2B,YAAY,GAAG,CAAtB;;IAEA,KAAK3B,CAAC,GAAGpB,KAAT,EAAgBoB,CAAC,GAAG0B,GAApB,EAAyB1B,CAAC,EAA1B,EAA8B;MAC1B,IAAI7J,UAAU,CAAC6J,CAAD,CAAV,KAAkB,IAAtB,EAA4B;QACxB2B,YAAY;MACf;IACJ;;IAED,KAAK3B,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG2B,YAAhB,EAA8B3B,CAAC,EAA/B,EAAmC;MAC/BtF,MAAM,CAAC2G,IAAP,CAAY3L,OAAZ;IACH;EACJ;;EAED,SAASkM,YAAT,CAAsBC,IAAtB,EAA4BC,OAA5B,EAAqCC,MAArC,EAA6C;IACzC,IAAID,OAAO,GAAGC,MAAd,EAAsB;MAClB,OAAO,CAAC,GAAD,EAAMF,IAAN,EAAY,GAAZ,CAAP;IACH;;IACD,OAAOA,IAAP;EACH;;EAED,SAASG,sBAAT,CAAgCC,MAAhC,EAAwC;IACpC,IAAI/E,CAAJ,EAAOC,EAAP,EAAWzC,MAAX;IACAA,MAAM,GAAGuH,MAAM,CAAC9B,KAAP,CAAa,SAAb,CAAT;;IACA,KAAKjD,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGzC,MAAM,CAACK,MAAxB,EAAgCmC,CAAC,GAAGC,EAApC,EAAwCD,CAAC,EAAzC,EAA6C;MACzCxC,MAAM,CAACwC,CAAD,CAAN,GAAYxH,OAAO,GAAGP,IAAV,GAAiBuF,MAAM,CAACwC,CAAD,CAAnC;IACH;;IACD,OAAOxC,MAAP;EACH;;EAED,SAASwH,gBAAT,CAA0BC,IAA1B,EAAgCC,UAAhC,EAA4C;IACxC,IAAI9H,QAAJ,EAAcI,MAAd,EAAsB2H,IAAtB;IACA/H,QAAQ,GAAG6H,IAAI,CAACnM,KAAK,CAACsE,QAAP,CAAf;;IAEA,IAAI,OAAOA,QAAP,KAAoB,QAAxB,EAAkC;MAC9BI,MAAM,GAAGkH,YAAY,CAACI,sBAAsB,CAAC1H,QAAD,CAAvB,EAAmCxF,UAAU,CAACkC,QAA9C,EAAwDoL,UAAxD,CAArB;IACH,CAFD,MAEO;MACH;MACA1H,MAAM,GAAGsH,sBAAsB,CAAC1H,QAAQ,CAACgI,OAAV,CAA/B;MACAD,IAAI,GAAI/H,QAAQ,CAAC8H,UAAT,IAAuB,IAAxB,GAAgC9H,QAAQ,CAAC8H,UAAzC,GAAsDtN,UAAU,CAACkC,QAAxE;MACA0D,MAAM,GAAGkH,YAAY,CAAClH,MAAD,EAAS2H,IAAT,EAAeD,UAAf,CAArB;IACH;;IAED,OAAO5D,sBAAsB,CAAC9D,MAAD,EAASyH,IAAT,CAA7B;EACH;;EAED,SAASzL,aAAT,GAAyB,CACxB,CAjxBQ,CAmxBT;;;EAEAA,aAAa,CAAC6L,SAAd,CAAwBC,UAAxB,GAAqC,UAAS/C,IAAT,EAAexC,KAAf,EAAsB;IACvD,IAAIvC,MAAJ;IAAA,IAAY+H,gBAAZ;IAAA,IAA8BC,IAAI,GAAG,IAArC;IAEAD,gBAAgB,GAAG,CAACzM,KAAK,CAAC2D,OAAP,IAAkB,CAAC8F,IAAI,CAACyB,eAA3C;;IAEA,IAAIzB,IAAI,CAAC5I,IAAL,KAAchC,MAAM,CAAC8N,cAArB,IAAuCF,gBAA3C,EAA6D;MACzD,OAAO,CAAC9M,KAAD,EAAQ,KAAKiN,iBAAL,CAAuBnD,IAAvB,EAA6BxC,KAA7B,CAAR,CAAP;IACH;;IAED,IAAIwC,IAAI,CAAC5I,IAAL,KAAchC,MAAM,CAACgO,cAArB,IAAuCJ,gBAA3C,EAA6D;MACzD,OAAO,GAAP;IACH;;IAED/C,UAAU,CAAC,YAAY;MACnBhF,MAAM,GAAG,CACLhF,OADK,EAEL8J,SAAS,CAACkD,IAAI,CAACE,iBAAL,CAAuBnD,IAAvB,EAA6BxC,KAA7B,CAAD,CAFJ,CAAT;IAIH,CALS,CAAV;IAOA,OAAOvC,MAAP;EACH,CArBD;;EAuBAhE,aAAa,CAAC6L,SAAd,CAAwBO,gBAAxB,GAA2C,UAAUrD,IAAV,EAAgB/E,MAAhB,EAAwB;IAC/D,IAAIqI,IAAI,GAAGlI,sBAAsB,CAAC2D,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+B8B,QAA/B,EAAD,CAAjC;;IACA,IAAIiD,IAAI,CAAC5I,IAAL,KAAchC,MAAM,CAAC8N,cAArB,KAAwC,CAAC3M,KAAK,CAAC2D,OAAP,IAAkB,CAAC8F,IAAI,CAACyB,eAAhE,KAAoF,CAAC6B,IAAzF,EAA+F;MAC3F,OAAO,CAACrI,MAAD,EAAS/E,KAAT,CAAP;IACH;;IACD,IAAIoN,IAAJ,EAAU;MACN,OAAO,CAACrI,MAAD,EAASvF,IAAT,CAAP;IACH;;IACD,OAAO,CAACuF,MAAD,EAAShF,OAAT,EAAkBP,IAAlB,CAAP;EACH,CATD;;EAWA,SAAS6N,kBAAT,CAA4BvM,IAA5B,EAAkC;IAC9B,OAAO+H,sBAAsB,CAAC/H,IAAI,CAACkI,IAAN,EAAYlI,IAAZ,CAA7B;EACH;;EAED,SAASwM,mBAAT,CAA6BxM,IAA7B,EAAmCyM,aAAnC,EAAkD;IAC9C,OAAOzM,IAAI,CAAC0M,KAAL,GAAa,WAAWD,aAAa,GAAGnE,YAAY,EAAf,GAAoBpJ,KAA5C,CAAb,GAAkE,EAAzE;EACH;;EAED,SAASyN,kBAAT,CAA4B3M,IAA5B,EAAkC;IAC9B,IAAI4M,WAAW,GAAG5M,IAAI,CAAC6M,SAAL,IAAkB,CAACtN,KAAK,CAACgE,GAAN,CAAUE,iBAA/C;IACA,OAAOmJ,WAAW,GAAG,MAAM1N,KAAT,GAAiB,EAAnC;EACH;;EAED,SAAS4N,oBAAT,CAA8BC,IAA9B,EAAoC;IAChC,IAAIC,IAAI,GAAGD,IAAI,CAAC3H,KAAhB;IAAA,IAAuBiF,MAAM,GAAG,EAAhC;;IACA,IAAI2C,IAAI,CAACN,KAAT,EAAgB;MACZrC,MAAM,IAAImC,mBAAmB,CAACQ,IAAD,EAAO,CAACD,IAAI,CAACE,QAAb,CAA7B;IACH;;IACD,IAAID,IAAI,CAACH,SAAT,EAAoB;MAChB;MACAxC,MAAM,IAAIsC,kBAAkB,CAACK,IAAD,CAAlB,GAA2B,GAA3B,GAAiC,EAA3C;IACH;;IACD,OAAO3C,MAAP;EACH;;EAEDpK,aAAa,CAAC6L,SAAd,CAAwBoB,eAAxB,GAA0C,UAAUlN,IAAV,EAAgB2L,UAAhB,EAA4BnF,KAA5B,EAAmC;IACzE,IAAIxG,IAAI,CAACI,IAAL,KAAchC,MAAM,CAAC+O,UAAzB,EAAqC;MACjC,OAAOZ,kBAAkB,CAACvM,IAAD,CAAzB;IACH;;IACD,OAAO,KAAKoN,kBAAL,CAAwBpN,IAAxB,EAA8B2L,UAA9B,EAA0CnF,KAA1C,CAAP;EACH,CALD;;EAOAvG,aAAa,CAAC6L,SAAd,CAAwBuB,sBAAxB,GAAiD,UAAUrN,IAAV,EAAgB;IAC7D,IAAIyG,CAAJ,EAAOC,EAAP,EAAWzC,MAAX,EAAmBqJ,UAAnB;IAEAA,UAAU,GAAG,KAAb;;IAEA,IAAItN,IAAI,CAACI,IAAL,KAAchC,MAAM,CAACmP,uBAArB,IACI,CAACvN,IAAI,CAACwN,IADV,KACmB,CAACxN,IAAI,CAACyN,QAAN,IAAkBzN,IAAI,CAACyN,QAAL,CAAcnJ,MAAd,KAAyB,CAD9D,KAEItE,IAAI,CAAC0N,MAAL,CAAYpJ,MAAZ,KAAuB,CAF3B,IAEgCtE,IAAI,CAAC0N,MAAL,CAAY,CAAZ,EAAetN,IAAf,KAAwBhC,MAAM,CAAC+O,UAFnE,EAE+E;MAC3E;MACAlJ,MAAM,GAAG,CAACuI,mBAAmB,CAACxM,IAAD,EAAO,IAAP,CAApB,EAAkCuM,kBAAkB,CAACvM,IAAI,CAAC0N,MAAL,CAAY,CAAZ,CAAD,CAApD,CAAT;IACH,CALD,MAKO;MACHzJ,MAAM,GAAGjE,IAAI,CAACI,IAAL,KAAchC,MAAM,CAACmP,uBAArB,GAA+C,CAACf,mBAAmB,CAACxM,IAAD,EAAO,KAAP,CAApB,CAA/C,GAAoF,EAA7F;MACAiE,MAAM,CAAC2G,IAAP,CAAY,GAAZ;;MACA,IAAI5K,IAAI,CAACyN,QAAT,EAAmB;QACfH,UAAU,GAAG,IAAb;MACH;;MACD,KAAK7G,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAG1G,IAAI,CAAC0N,MAAL,CAAYpJ,MAA7B,EAAqCmC,CAAC,GAAGC,EAAzC,EAA6C,EAAED,CAA/C,EAAkD;QAC9C,IAAI6G,UAAU,IAAItN,IAAI,CAACyN,QAAL,CAAchH,CAAd,CAAlB,EAAoC;UAChC;UACAxC,MAAM,CAAC2G,IAAP,CAAY,KAAK+C,kBAAL,CAAwB3N,IAAI,CAAC0N,MAAL,CAAYjH,CAAZ,CAAxB,EAAwCzG,IAAI,CAACyN,QAAL,CAAchH,CAAd,CAAxC,EAA0D,GAA1D,EAA+DpI,UAAU,CAACoC,UAA1E,EAAsF+B,KAAtF,CAAZ;QACH,CAHD,MAGO;UACHyB,MAAM,CAAC2G,IAAP,CAAY,KAAKsC,eAAL,CAAqBlN,IAAI,CAAC0N,MAAL,CAAYjH,CAAZ,CAArB,EAAqCpI,UAAU,CAACoC,UAAhD,EAA4D+B,KAA5D,CAAZ;QACH;;QACD,IAAIiE,CAAC,GAAG,CAAJ,GAAQC,EAAZ,EAAgB;UACZzC,MAAM,CAAC2G,IAAP,CAAY,MAAM1L,KAAlB;QACH;MACJ;;MAED,IAAIc,IAAI,CAACwN,IAAT,EAAe;QACX,IAAIxN,IAAI,CAAC0N,MAAL,CAAYpJ,MAAhB,EAAwB;UACpBL,MAAM,CAAC2G,IAAP,CAAY,MAAM1L,KAAlB;QACH;;QACD+E,MAAM,CAAC2G,IAAP,CAAY,KAAZ;QACA3G,MAAM,CAAC2G,IAAP,CAAY2B,kBAAkB,CAACvM,IAAI,CAACwN,IAAN,CAA9B;MACH;;MAEDvJ,MAAM,CAAC2G,IAAP,CAAY,GAAZ;IACH;;IAED,OAAO3G,MAAP;EACH,CAxCD;;EA0CAhE,aAAa,CAAC6L,SAAd,CAAwB8B,oBAAxB,GAA+C,UAAU5N,IAAV,EAAgB;IAC3D,IAAIiE,MAAJ,EAAYyH,IAAZ;IAEAzH,MAAM,GAAG,KAAKoJ,sBAAL,CAA4BrN,IAA5B,CAAT;;IAEA,IAAIA,IAAI,CAACI,IAAL,KAAchC,MAAM,CAACmP,uBAAzB,EAAkD;MAC9CtJ,MAAM,CAAC2G,IAAP,CAAY1L,KAAZ;MACA+E,MAAM,CAAC2G,IAAP,CAAY,IAAZ;IACH;;IAED,IAAI5K,IAAI,CAAC6N,UAAT,EAAqB;MACjB5J,MAAM,CAAC2G,IAAP,CAAY1L,KAAZ;MACAwM,IAAI,GAAG,KAAK0B,kBAAL,CAAwBpN,IAAI,CAAC8K,IAA7B,EAAmCzM,UAAU,CAACoC,UAA9C,EAA0D+B,KAA1D,CAAP;;MACA,IAAIkJ,IAAI,CAAC3F,QAAL,GAAgB+H,MAAhB,CAAuB,CAAvB,MAA8B,GAAlC,EAAuC;QACnCpC,IAAI,GAAG,CAAC,GAAD,EAAMA,IAAN,EAAY,GAAZ,CAAP;MACH;;MACDzH,MAAM,CAAC2G,IAAP,CAAYc,IAAZ;IACH,CAPD,MAOO;MACHzH,MAAM,CAAC2G,IAAP,CAAY,KAAKmB,UAAL,CAAgB/L,IAAI,CAAC8K,IAArB,EAA2B9H,MAA3B,CAAZ;IACH;;IAED,OAAOiB,MAAP;EACH,CAtBD;;EAwBAhE,aAAa,CAAC6L,SAAd,CAAwBiC,6BAAxB,GAAwD,UAAUC,QAAV,EAAoBhF,IAApB,EAA0BxC,KAA1B,EAAiC;IACrF,IAAIvC,MAAM,GAAG,CAAC,SAAS+E,IAAI,CAACiF,KAAL,GAAa3F,YAAY,KAAK,OAA9B,GAAwC,EAAjD,IAAuDpJ,KAAvD,GAA+D,GAAhE,CAAb;IAAA,IAAmF+M,IAAI,GAAG,IAA1F;IACAhD,UAAU,CAAC,YAAY;MACnB,IAAID,IAAI,CAACR,IAAL,CAAUpI,IAAV,KAAmBhC,MAAM,CAAC8P,mBAA9B,EAAmD;QAC/CjF,UAAU,CAAC,YAAY;UACnBhF,MAAM,CAAC2G,IAAP,CAAY5B,IAAI,CAACR,IAAL,CAAU2F,IAAV,GAAiB7F,YAAY,EAAzC;UACArE,MAAM,CAAC2G,IAAP,CAAYqB,IAAI,CAACE,iBAAL,CAAuBnD,IAAI,CAACR,IAAL,CAAU4F,YAAV,CAAuB,CAAvB,CAAvB,EAAkDtL,MAAlD,CAAZ;QACH,CAHS,CAAV;MAIH,CALD,MAKO;QACHmB,MAAM,CAAC2G,IAAP,CAAYqB,IAAI,CAACmB,kBAAL,CAAwBpE,IAAI,CAACR,IAA7B,EAAmCnK,UAAU,CAACsD,IAA9C,EAAoDa,KAApD,CAAZ;MACH;;MAEDyB,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS+J,QAAT,CAAb;MACA/J,MAAM,GAAG,CAACsE,IAAI,CACVtE,MADU,EAEVgI,IAAI,CAACmB,kBAAL,CAAwBpE,IAAI,CAACP,KAA7B,EAAoCpK,UAAU,CAACoC,UAA/C,EAA2D+B,KAA3D,CAFU,CAAL,EAGN,GAHM,CAAT;IAIH,CAfS,CAAV;IAgBAyB,MAAM,CAAC2G,IAAP,CAAY,KAAKmB,UAAL,CAAgB/C,IAAI,CAAC8B,IAArB,EAA2BtE,KAA3B,CAAZ;IACA,OAAOvC,MAAP;EACH,CApBD;;EAsBAhE,aAAa,CAAC6L,SAAd,CAAwBuC,mBAAxB,GAA8C,UAAU3C,IAAV,EAAgBuB,QAAhB,EAA0B;IACpE,IAAIhJ,MAAM,GAAG,EAAb;;IAEA,IAAIgJ,QAAJ,EAAc;MACVhJ,MAAM,CAAC2G,IAAP,CAAY,GAAZ;IACH;;IAED3G,MAAM,CAAC2G,IAAP,CAAY,KAAKwC,kBAAL,CAAwB1B,IAAxB,EAA8BrN,UAAU,CAACoC,UAAzC,EAAqD+B,KAArD,CAAZ;;IAEA,IAAIyK,QAAJ,EAAc;MACVhJ,MAAM,CAAC2G,IAAP,CAAY,GAAZ;IACH;;IAED,OAAO3G,MAAP;EACH,CAdD;;EAgBAhE,aAAa,CAAC6L,SAAd,CAAwB6B,kBAAxB,GAA6C,UAAUnF,IAAV,EAAgBC,KAAhB,EAAuBuF,QAAvB,EAAiCrC,UAAjC,EAA6CnF,KAA7C,EAAoD;IAC7F,IAAInI,UAAU,CAACoC,UAAX,GAAwBkL,UAA5B,EAAwC;MACpCnF,KAAK,IAAIxE,UAAT;IACH;;IAED,OAAOmJ,YAAY,CACf,CACI,KAAKiC,kBAAL,CAAwB5E,IAAxB,EAA8BnK,UAAU,CAACsD,IAAzC,EAA+C6E,KAA/C,CADJ,EAEItH,KAAK,GAAG8O,QAAR,GAAmB9O,KAFvB,EAGI,KAAKkO,kBAAL,CAAwB3E,KAAxB,EAA+BpK,UAAU,CAACoC,UAA1C,EAAsD+F,KAAtD,CAHJ,CADe,EAMfnI,UAAU,CAACoC,UANI,EAOfkL,UAPe,CAAnB;EASH,CAdD;;EAgBA1L,aAAa,CAAC6L,SAAd,CAAwBwC,SAAxB,GAAoC,UAAU9H,KAAV,EAAiB;IACjD,IAAI,CAACpH,UAAD,IAAeoH,KAAK,GAAGnE,eAA3B,EAA4C;MACxC,OAAO,EAAP;IACH;;IACD,OAAO,GAAP;EACH,CALD,CA/8BS,CAs9BT;;;EAEApC,aAAa,CAACK,SAAd,GAA0B;IAEtB4L,cAAc,EAAE,UAAUlD,IAAV,EAAgBxC,KAAhB,EAAuB;MACnC,IAAI2D,KAAJ;MAAA,IAAW0B,OAAX;MAAA,IAAoB5H,MAAM,GAAG,CAAC,GAAD,EAAMhF,OAAN,CAA7B;MAAA,IAA6CgN,IAAI,GAAG,IAApD;MAEAhD,UAAU,CAAC,YAAY;QACnB;QACA,IAAID,IAAI,CAAC8B,IAAL,CAAUxG,MAAV,KAAqB,CAArB,IAA0B3E,kBAA9B,EAAkD;UAC9CwK,KAAK,GAAGnB,IAAI,CAACmB,KAAb;;UACA,IAAIA,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAAhB,GAAsB,CAA1B,EAA6B;YACzB0B,OAAO,GAAGnM,UAAU,CAACiL,SAAX,CAAqBR,KAAK,CAAC,CAAD,CAAL,GAAW,CAAhC,EAAmCA,KAAK,CAAC,CAAD,CAAL,GAAW,CAA9C,CAAV;;YACA,IAAI0B,OAAO,CAAC,CAAD,CAAP,KAAe,IAAnB,EAAyB;cACrB5H,MAAM,GAAG,CAAC,GAAD,CAAT;YACH;;YACDA,MAAM,CAAC2G,IAAP,CAAYiB,OAAZ;UACH;QACJ;;QAED,IAAIpF,CAAJ,EAAOC,EAAP,EAAWuD,QAAX,EAAqBsE,SAArB;QACAA,SAAS,GAAG3L,MAAZ;;QACA,IAAI4D,KAAK,GAAGrE,WAAZ,EAAyB;UACrBoM,SAAS,IAAInM,eAAb;QACH;;QAED,KAAKqE,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGsC,IAAI,CAAC8B,IAAL,CAAUxG,MAA3B,EAAmCmC,CAAC,GAAGC,EAAvC,EAA2C,EAAED,CAA7C,EAAgD;UAC5C,IAAI9G,kBAAJ,EAAwB;YACpB;YACA,IAAI8G,CAAC,KAAK,CAAV,EAAa;cACT,IAAIuC,IAAI,CAAC8B,IAAL,CAAU,CAAV,EAAaL,eAAjB,EAAkC;gBAC9BN,KAAK,GAAGnB,IAAI,CAAC8B,IAAL,CAAU,CAAV,EAAaL,eAAb,CAA6B,CAA7B,EAAgCC,aAAxC;gBACAmB,OAAO,GAAGnM,UAAU,CAACiL,SAAX,CAAqBR,KAAK,CAAC,CAAD,CAA1B,EAA+BA,KAAK,CAAC,CAAD,CAApC,CAAV;;gBACA,IAAI0B,OAAO,CAAC,CAAD,CAAP,KAAe,IAAnB,EAAyB;kBACrB5H,MAAM,GAAG,CAAC,GAAD,CAAT;gBACH;cACJ;;cACD,IAAI,CAAC+E,IAAI,CAAC8B,IAAL,CAAU,CAAV,EAAaL,eAAlB,EAAmC;gBAC/BO,kBAAkB,CAAChC,IAAI,CAACmB,KAAL,CAAW,CAAX,CAAD,EAAgBnB,IAAI,CAAC8B,IAAL,CAAU,CAAV,EAAaX,KAAb,CAAmB,CAAnB,CAAhB,EAAuClG,MAAvC,CAAlB;cACH;YACJ,CAbmB,CAepB;;;YACA,IAAIwC,CAAC,GAAG,CAAR,EAAW;cACP,IAAI,CAACuC,IAAI,CAAC8B,IAAL,CAAUrE,CAAC,GAAG,CAAd,EAAiBsE,gBAAlB,IAAuC,CAAC/B,IAAI,CAAC8B,IAAL,CAAUrE,CAAV,EAAagE,eAAzD,EAA0E;gBACtEO,kBAAkB,CAAChC,IAAI,CAAC8B,IAAL,CAAUrE,CAAC,GAAG,CAAd,EAAiB0D,KAAjB,CAAuB,CAAvB,CAAD,EAA4BnB,IAAI,CAAC8B,IAAL,CAAUrE,CAAV,EAAa0D,KAAb,CAAmB,CAAnB,CAA5B,EAAmDlG,MAAnD,CAAlB;cACH;YACJ;UACJ;;UAED,IAAIwC,CAAC,KAAKC,EAAE,GAAG,CAAf,EAAkB;YACd6H,SAAS,IAAIlM,eAAb;UACH;;UAED,IAAI2G,IAAI,CAAC8B,IAAL,CAAUrE,CAAV,EAAagE,eAAb,IAAgC9K,kBAApC,EAAwD;YACpDsK,QAAQ,GAAGgC,IAAI,CAACE,iBAAL,CAAuBnD,IAAI,CAAC8B,IAAL,CAAUrE,CAAV,CAAvB,EAAqC8H,SAArC,CAAX;UACH,CAFD,MAEO;YACHtE,QAAQ,GAAGlB,SAAS,CAACkD,IAAI,CAACE,iBAAL,CAAuBnD,IAAI,CAAC8B,IAAL,CAAUrE,CAAV,CAAvB,EAAqC8H,SAArC,CAAD,CAApB;UACH;;UAEDtK,MAAM,CAAC2G,IAAP,CAAYX,QAAZ;;UACA,IAAI,CAAC7F,sBAAsB,CAAC2D,sBAAsB,CAACkC,QAAD,CAAtB,CAAiClE,QAAjC,EAAD,CAA3B,EAA0E;YACtE,IAAIpG,kBAAkB,IAAI8G,CAAC,GAAGC,EAAE,GAAG,CAAnC,EAAsC;cAClC;cACA;cACA,IAAI,CAACsC,IAAI,CAAC8B,IAAL,CAAUrE,CAAC,GAAG,CAAd,EAAiBgE,eAAtB,EAAuC;gBACnCxG,MAAM,CAAC2G,IAAP,CAAY3L,OAAZ;cACH;YACJ,CAND,MAMO;cACHgF,MAAM,CAAC2G,IAAP,CAAY3L,OAAZ;YACH;UACJ;;UAED,IAAIU,kBAAJ,EAAwB;YACpB;YACA,IAAI8G,CAAC,KAAKC,EAAE,GAAG,CAAf,EAAkB;cACd,IAAI,CAACsC,IAAI,CAAC8B,IAAL,CAAUrE,CAAV,EAAasE,gBAAlB,EAAoC;gBAChCC,kBAAkB,CAAChC,IAAI,CAAC8B,IAAL,CAAUrE,CAAV,EAAa0D,KAAb,CAAmB,CAAnB,CAAD,EAAwBnB,IAAI,CAACmB,KAAL,CAAW,CAAX,CAAxB,EAAuClG,MAAvC,CAAlB;cACH;YACJ;UACJ;QACJ;MACJ,CA3ES,CAAV;MA6EAA,MAAM,CAAC2G,IAAP,CAAY7B,SAAS,CAAC,GAAD,CAArB;MACA,OAAO9E,MAAP;IACH,CApFqB;IAsFtBuK,cAAc,EAAE,UAAUxF,IAAV,EAAgBxC,KAAhB,EAAuB;MACnC,IAAIwC,IAAI,CAACyF,KAAT,EAAgB;QACZ,OAAO,WAAWzF,IAAI,CAACyF,KAAL,CAAWvG,IAAtB,GAA6B,KAAKoG,SAAL,CAAe9H,KAAf,CAApC;MACH;;MACD,OAAO,UAAU,KAAK8H,SAAL,CAAe9H,KAAf,CAAjB;IACH,CA3FqB;IA6FtBkI,iBAAiB,EAAE,UAAU1F,IAAV,EAAgBxC,KAAhB,EAAuB;MACtC,IAAIwC,IAAI,CAACyF,KAAT,EAAgB;QACZ,OAAO,cAAczF,IAAI,CAACyF,KAAL,CAAWvG,IAAzB,GAAgC,KAAKoG,SAAL,CAAe9H,KAAf,CAAvC;MACH;;MACD,OAAO,aAAa,KAAK8H,SAAL,CAAe9H,KAAf,CAApB;IACH,CAlGqB;IAoGtBmI,SAAS,EAAE,UAAU3F,IAAV,EAAgBxC,KAAhB,EAAuB;MAC9B,IAAIvC,MAAM,GAAG,CAAE,GAAF,EAAOhF,OAAP,CAAb;MAAA,IAA8BgN,IAAI,GAAG,IAArC;MAEAhD,UAAU,CAAC,UAAUtK,MAAV,EAAkB;QACzB,IAAI8H,CAAJ,EAAOC,EAAP;;QAEA,KAAKD,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGsC,IAAI,CAAC8B,IAAL,CAAUxG,MAA3B,EAAmCmC,CAAC,GAAGC,EAAvC,EAA2C,EAAED,CAA7C,EAAgD;UAC5CxC,MAAM,CAAC2G,IAAP,CAAYjM,MAAZ;UACAsF,MAAM,CAAC2G,IAAP,CAAYqB,IAAI,CAACmB,kBAAL,CAAwBpE,IAAI,CAAC8B,IAAL,CAAUrE,CAAV,CAAxB,EAAsCpI,UAAU,CAACkC,QAAjD,EAA2DiC,KAA3D,CAAZ;;UACA,IAAIiE,CAAC,GAAG,CAAJ,GAAQC,EAAZ,EAAgB;YACZzC,MAAM,CAAC2G,IAAP,CAAY3L,OAAZ;UACH;QACJ;MACJ,CAVS,CAAV;;MAYA,IAAI,CAACmF,sBAAsB,CAAC2D,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+B8B,QAA/B,EAAD,CAA3B,EAAwE;QACpE9B,MAAM,CAAC2G,IAAP,CAAY3L,OAAZ;MACH;;MACDgF,MAAM,CAAC2G,IAAP,CAAYlM,IAAZ;MACAuF,MAAM,CAAC2G,IAAP,CAAY,GAAZ;MACA,OAAO3G,MAAP;IACH,CAzHqB;IA2HtB2K,gBAAgB,EAAE,UAAU5F,IAAV,EAAgBxC,KAAhB,EAAuB;MACrC,IAAIvC,MAAJ,EAAYgG,QAAZ;MACAhG,MAAM,GAAI,CAAC,OAAD,CAAV;;MACA,IAAI+E,IAAI,CAAC6F,EAAT,EAAa;QACT5K,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,KAAKmJ,kBAAL,CAAwBpE,IAAI,CAAC6F,EAA7B,EAAiCxQ,UAAU,CAACkC,QAA5C,EAAsDiC,KAAtD,CAAT,CAAb;MACH;;MACD,IAAIwG,IAAI,CAAC8F,UAAT,EAAqB;QACjB7E,QAAQ,GAAG1B,IAAI,CAAC,SAAD,EAAY,KAAK6E,kBAAL,CAAwBpE,IAAI,CAAC8F,UAA7B,EAAyCzQ,UAAU,CAACmD,KAApD,EAA2DgB,KAA3D,CAAZ,CAAf;QACAyB,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAASgG,QAAT,CAAb;MACH;;MACDhG,MAAM,CAAC2G,IAAP,CAAY1L,KAAZ;MACA+E,MAAM,CAAC2G,IAAP,CAAY,KAAKuB,iBAAL,CAAuBnD,IAAI,CAAC8B,IAA5B,EAAkCjI,MAAlC,CAAZ;MACA,OAAOoB,MAAP;IACH,CAxIqB;IA0ItB8K,kBAAkB,EAAE,UAAU/F,IAAV,EAAgBxC,KAAhB,EAAuB;MACvC,IAAIjH,KAAK,CAACqE,GAAN,IAAaoF,IAAI,CAACpF,GAAtB,EAA2B;QACvB,OAAOoF,IAAI,CAACpF,GAAL,GAAW,KAAK0K,SAAL,CAAe9H,KAAf,CAAlB;MACH;;MACD,OAAOW,eAAe,CAAC6B,IAAI,CAAC1J,SAAN,CAAf,GAAkC,KAAKgP,SAAL,CAAe9H,KAAf,CAAzC;IACH,CA/IqB;IAiJtBwI,gBAAgB,EAAE,UAAUhG,IAAV,EAAgBxC,KAAhB,EAAuB;MACrC;MACA,IAAIvC,MAAM,GAAGsE,IAAI,CAAC,IAAD,EAAO,KAAKwD,UAAL,CAAgB/C,IAAI,CAAC8B,IAArB,EAA2BlI,MAA3B,CAAP,CAAjB;MACAqB,MAAM,GAAG,KAAKoI,gBAAL,CAAsBrD,IAAI,CAAC8B,IAA3B,EAAiC7G,MAAjC,CAAT;MACA,OAAOsE,IAAI,CAACtE,MAAD,EAAS,CAChB,UAAU/E,KAAV,GAAkB,GADF,EAEhB,KAAKkO,kBAAL,CAAwBpE,IAAI,CAAC7E,IAA7B,EAAmC9F,UAAU,CAACkC,QAA9C,EAAwDiC,KAAxD,CAFgB,EAGhB,MAAM,KAAK8L,SAAL,CAAe9H,KAAf,CAHU,CAAT,CAAX;IAKH,CA1JqB;IA4JtByI,WAAW,EAAE,UAAUjG,IAAV,EAAgBxC,KAAhB,EAAuB;MAChC,IAAIvC,MAAJ;MAAA,IAAYgI,IAAI,GAAG,IAAnB;MACAhD,UAAU,CAAC,YAAY;QACnB,IAAIiG,KAAJ;;QAEA,IAAIlG,IAAI,CAACmG,KAAT,EAAgB;UACZlL,MAAM,GAAG,CACL,UAAU/E,KAAV,GAAkB,GADb,EAEL+M,IAAI,CAACmB,kBAAL,CAAwBpE,IAAI,CAACmG,KAA7B,EAAoC9Q,UAAU,CAACkC,QAA/C,EAAyDiC,KAAzD,CAFK,EAGL,GAHK,CAAT;;UAMA,IAAIwG,IAAI,CAACkG,KAAT,EAAgB;YACZA,KAAK,GAAGjD,IAAI,CAACmB,kBAAL,CAAwBpE,IAAI,CAACkG,KAA7B,EAAoC7Q,UAAU,CAACkC,QAA/C,EAAyDiC,KAAzD,CAAR;YACAyB,MAAM,CAACmL,MAAP,CAAc,CAAd,EAAiB,CAAjB,EAAoB,MAApB,EAA4BF,KAA5B;UACH;QACJ,CAXD,MAWO;UACHjL,MAAM,GAAG,CAAC,OAAD,CAAT;QACH;MACJ,CAjBS,CAAV;MAkBAA,MAAM,CAAC2G,IAAP,CAAY,KAAKmB,UAAL,CAAgB/C,IAAI,CAAC8B,IAArB,EAA2BlI,MAA3B,CAAZ;MACA,OAAOqB,MAAP;IACH,CAlLqB;IAoLtBoL,iBAAiB,EAAE,UAAUrG,IAAV,EAAgBxC,KAAhB,EAAuB;MACtC,OAAO,aAAa,KAAK8H,SAAL,CAAe9H,KAAf,CAApB;IACH,CAtLqB;IAwLtB4F,cAAc,EAAE,UAAUpD,IAAV,EAAgBxC,KAAhB,EAAuB;MACnC,OAAO,GAAP;IACH,CA1LqB;IA4LtB8I,wBAAwB,EAAE,UAAUtG,IAAV,EAAgBxC,KAAhB,EAAuB;MAC7C,IAAIvC,MAAM,GAAG,CAAE,QAAF,CAAb;MAAA,IAA2BsK,SAA3B;MAEAA,SAAS,GAAI/H,KAAK,GAAGnE,eAAT,GAA4BQ,MAA5B,GAAqCD,MAAjD,CAH6C,CAK7C;MACA;;MACAqB,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,SAAT,CAAb;;MACA,IAAI5D,WAAW,CAAC2I,IAAI,CAACuG,WAAN,CAAf,EAAmC;QAC/BtL,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,KAAKkI,iBAAL,CAAuBnD,IAAI,CAACuG,WAA5B,EAAyChB,SAAzC,CAAT,CAAb;MACH,CAFD,MAEO;QACHtK,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,KAAKmJ,kBAAL,CAAwBpE,IAAI,CAACuG,WAA7B,EAA0ClR,UAAU,CAACoC,UAArD,EAAiE+B,KAAjE,IAA0E,KAAK8L,SAAL,CAAe9H,KAAf,CAAnF,CAAb;MACH;;MACD,OAAOvC,MAAP;IACH,CA1MqB;IA4MtBuL,sBAAsB,EAAE,UAAUxG,IAAV,EAAgBxC,KAAhB,EAAuB;MAC3C,IAAIvC,MAAM,GAAG,CAAE,QAAF,CAAb;MAAA,IAA2BsK,SAA3B;MAAA,IAAsCtC,IAAI,GAAG,IAA7C;MAEAsC,SAAS,GAAI/H,KAAK,GAAGnE,eAAT,GAA4BQ,MAA5B,GAAqCD,MAAjD,CAH2C,CAK3C;MACA;;MACA,IAAIoG,IAAI,CAACuG,WAAT,EAAsB;QAClB,OAAOhH,IAAI,CAACtE,MAAD,EAAS,KAAKkI,iBAAL,CAAuBnD,IAAI,CAACuG,WAA5B,EAAyChB,SAAzC,CAAT,CAAX;MACH,CAT0C,CAW3C;MACA;;;MACA,IAAIvF,IAAI,CAACyG,UAAT,EAAqB;QACjB,IAAIzG,IAAI,CAACyG,UAAL,CAAgBnL,MAAhB,KAA2B,CAA/B,EAAkC;UAC9BL,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,MAAM/E,KAAN,GAAc,GAAvB,CAAb;QACH,CAFD,MAEO,IAAI8J,IAAI,CAACyG,UAAL,CAAgB,CAAhB,EAAmBrP,IAAnB,KAA4BhC,MAAM,CAACsR,oBAAvC,EAA6D;UAChEzL,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,KAAKmJ,kBAAL,CAAwBpE,IAAI,CAACyG,UAAL,CAAgB,CAAhB,CAAxB,EAA4CpR,UAAU,CAACkC,QAAvD,EAAiEiC,KAAjE,CAAT,CAAb;QACH,CAFM,MAEA;UACHyB,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,GAAT,CAAb;UACAgF,UAAU,CAAC,UAAUtK,MAAV,EAAkB;YACzB,IAAI8H,CAAJ,EAAOC,EAAP;YACAzC,MAAM,CAAC2G,IAAP,CAAY3L,OAAZ;;YACA,KAAKwH,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGsC,IAAI,CAACyG,UAAL,CAAgBnL,MAAjC,EAAyCmC,CAAC,GAAGC,EAA7C,EAAiD,EAAED,CAAnD,EAAsD;cAClDxC,MAAM,CAAC2G,IAAP,CAAYjM,MAAZ;cACAsF,MAAM,CAAC2G,IAAP,CAAYqB,IAAI,CAACmB,kBAAL,CAAwBpE,IAAI,CAACyG,UAAL,CAAgBhJ,CAAhB,CAAxB,EAA4CpI,UAAU,CAACkC,QAAvD,EAAiEiC,KAAjE,CAAZ;;cACA,IAAIiE,CAAC,GAAG,CAAJ,GAAQC,EAAZ,EAAgB;gBACZzC,MAAM,CAAC2G,IAAP,CAAY,MAAM3L,OAAlB;cACH;YACJ;UACJ,CAVS,CAAV;;UAWA,IAAI,CAACmF,sBAAsB,CAAC2D,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+B8B,QAA/B,EAAD,CAA3B,EAAwE;YACpE9B,MAAM,CAAC2G,IAAP,CAAY3L,OAAZ;UACH;;UACDgF,MAAM,CAAC2G,IAAP,CAAYlM,IAAI,GAAG,GAAnB;QACH;;QAED,IAAIsK,IAAI,CAACpC,MAAT,EAAiB;UACb3C,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,CAClB,SAAS/E,KADS,EAElB;UACA,KAAKkO,kBAAL,CAAwBpE,IAAI,CAACpC,MAA7B,EAAqCvI,UAAU,CAACkC,QAAhD,EAA0DiC,KAA1D,CAHkB,EAIlB,KAAK8L,SAAL,CAAe9H,KAAf,CAJkB,CAAT,CAAb;QAMH,CAPD,MAOO;UACHvC,MAAM,CAAC2G,IAAP,CAAY,KAAK0D,SAAL,CAAe9H,KAAf,CAAZ;QACH;MACJ;;MACD,OAAOvC,MAAP;IACH,CA7PqB;IA+PtB0L,oBAAoB,EAAE,UAAU3G,IAAV,EAAgBxC,KAAhB,EAAuB;MACzC;MACA,OAAO,CACH,WAAWtH,KADR,EAEH,MAAMA,KAFH,EAGH,SAASA,KAHN,EAIH;MACA,KAAKkO,kBAAL,CAAwBpE,IAAI,CAACpC,MAA7B,EAAqCvI,UAAU,CAACkC,QAAhD,EAA0DiC,KAA1D,CALG,EAMH,KAAK8L,SAAL,CAAe9H,KAAf,CANG,CAAP;IAQH,CAzQqB;IA2QtBoJ,mBAAmB,EAAE,UAAU5G,IAAV,EAAgBxC,KAAhB,EAAuB;MACxC,IAAIvC,MAAJ,EAAYgG,QAAZ;;MAEA,SAAS4F,eAAT,CAAyB5F,QAAzB,EAAmC;QAC/B,IAAI1F,IAAJ;;QACA,IAAI0F,QAAQ,CAACtE,KAAT,CAAe,CAAf,EAAkB,CAAlB,MAAyB,OAA7B,EAAsC;UAClC,OAAO,KAAP;QACH;;QACDpB,IAAI,GAAG0F,QAAQ,CAACxF,UAAT,CAAoB,CAApB,CAAP;QACA,OAAOF,IAAI,KAAK;QAAM;QAAf,GAA4B9F,OAAO,CAAC8F,IAAR,CAAauE,YAAb,CAA0BvE,IAA1B,CAA5B,IAA+D9F,OAAO,CAAC8F,IAAR,CAAaC,gBAAb,CAA8BD,IAA9B,CAAtE;MACH;;MAED,SAASuL,kBAAT,CAA4B7F,QAA5B,EAAsC;QAClC,IAAI1F,IAAJ;;QACA,IAAI0F,QAAQ,CAACtE,KAAT,CAAe,CAAf,EAAkB,CAAlB,MAAyB,UAA7B,EAAyC;UACrC,OAAO,KAAP;QACH;;QACDpB,IAAI,GAAG0F,QAAQ,CAACxF,UAAT,CAAoB,CAApB,CAAP;QACA,OAAOF,IAAI,KAAK;QAAK;QAAd,GAA2B9F,OAAO,CAAC8F,IAAR,CAAauE,YAAb,CAA0BvE,IAA1B,CAA3B,IAA8DA,IAAI,KAAK;QAAM;QAA7E,GAA0F9F,OAAO,CAAC8F,IAAR,CAAaC,gBAAb,CAA8BD,IAA9B,CAAjG;MACH;;MAED,SAASwL,eAAT,CAAyB9F,QAAzB,EAAmC;QAC/B,IAAI1F,IAAJ,EAAUkC,CAAV,EAAaC,EAAb;;QACA,IAAIuD,QAAQ,CAACtE,KAAT,CAAe,CAAf,EAAkB,CAAlB,MAAyB,OAA7B,EAAsC;UAClC,OAAO,KAAP;QACH;;QACD,IAAI,CAAClH,OAAO,CAAC8F,IAAR,CAAauE,YAAb,CAA0BmB,QAAQ,CAACxF,UAAT,CAAoB,CAApB,CAA1B,CAAL,EAAwD;UACpD,OAAO,KAAP;QACH;;QACD,KAAKgC,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGuD,QAAQ,CAAC3F,MAA1B,EAAkCmC,CAAC,GAAGC,EAAtC,EAA0C,EAAED,CAA5C,EAA+C;UAC3C,IAAI,CAAChI,OAAO,CAAC8F,IAAR,CAAauE,YAAb,CAA0BmB,QAAQ,CAACxF,UAAT,CAAoBgC,CAApB,CAA1B,CAAL,EAAwD;YACpD;UACH;QACJ;;QACD,IAAIA,CAAC,KAAKC,EAAV,EAAc;UACV,OAAO,KAAP;QACH;;QACD,IAAIuD,QAAQ,CAACtE,KAAT,CAAec,CAAf,EAAkBA,CAAC,GAAG,CAAtB,MAA6B,UAAjC,EAA6C;UACzC,OAAO,KAAP;QACH;;QACDlC,IAAI,GAAG0F,QAAQ,CAACxF,UAAT,CAAoBgC,CAAC,GAAG,CAAxB,CAAP;QACA,OAAOlC,IAAI,KAAK;QAAK;QAAd,GAA2B9F,OAAO,CAAC8F,IAAR,CAAauE,YAAb,CAA0BvE,IAA1B,CAA3B,IAA8DA,IAAI,KAAK;QAAM;QAA7E,GAA0F9F,OAAO,CAAC8F,IAAR,CAAaC,gBAAb,CAA8BD,IAA9B,CAAjG;MACH;;MAEDN,MAAM,GAAG,CAAC,KAAKmJ,kBAAL,CAAwBpE,IAAI,CAAC6E,UAA7B,EAAyCxP,UAAU,CAACkC,QAApD,EAA8DiC,KAA9D,CAAD,CAAT,CA5CwC,CA6CxC;MACA;;MACAyH,QAAQ,GAAGlC,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+B8B,QAA/B,EAAX;;MACA,IAAIkE,QAAQ,CAACxF,UAAT,CAAoB,CAApB,MAA2B;MAAM;MAAjC,GAA+C;MAC3CoL,eAAe,CAAC5F,QAAD,CADnB,IAEI6F,kBAAkB,CAAC7F,QAAD,CAFtB,IAGI8F,eAAe,CAAC9F,QAAD,CAHnB,IAIK3K,SAAS,IAAKkH,KAAK,GAAGpE,eAAtB,IAA0C4G,IAAI,CAAC6E,UAAL,CAAgBzN,IAAhB,KAAyBhC,MAAM,CAAC4R,OAA1E,IAAqF,OAAOhH,IAAI,CAAC6E,UAAL,CAAgBzI,KAAvB,KAAiC,QAJ/H,EAI0I;QACtInB,MAAM,GAAG,CAAC,GAAD,EAAMA,MAAN,EAAc,MAAM,KAAKqK,SAAL,CAAe9H,KAAf,CAApB,CAAT;MACH,CAND,MAMO;QACHvC,MAAM,CAAC2G,IAAP,CAAY,KAAK0D,SAAL,CAAe9H,KAAf,CAAZ;MACH;;MACD,OAAOvC,MAAP;IACH,CArUqB;IAuUtBgM,iBAAiB,EAAE,UAAUjH,IAAV,EAAgBxC,KAAhB,EAAuB;MACtC;MACA;MACA;MACA,IAAIvC,MAAJ;MAAA,IAAYiM,MAAZ;MAAA,IAAoBjE,IAAI,GAAG,IAA3B,CAJsC,CAMtC;MACA;MACA;;MACA,IAAIjD,IAAI,CAACyG,UAAL,CAAgBnL,MAAhB,KAA2B,CAA/B,EAAkC;QAC9B;QACA,OAAO,CACH,QADG,EAEHpF,KAFG,EAGH;QACA,KAAKkO,kBAAL,CAAwBpE,IAAI,CAACpC,MAA7B,EAAqCvI,UAAU,CAACkC,QAAhD,EAA0DiC,KAA1D,CAJG,EAKH,KAAK8L,SAAL,CAAe9H,KAAf,CALG,CAAP;MAOH,CAlBqC,CAoBtC;;;MACAvC,MAAM,GAAG,CACL,QADK,CAAT;MAGAiM,MAAM,GAAG,CAAT,CAxBsC,CA0BtC;;MACA,IAAIlH,IAAI,CAACyG,UAAL,CAAgBS,MAAhB,EAAwB9P,IAAxB,KAAiChC,MAAM,CAAC+R,sBAA5C,EAAoE;QAChElM,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,CACd,KAAKmJ,kBAAL,CAAwBpE,IAAI,CAACyG,UAAL,CAAgBS,MAAhB,CAAxB,EAAiD7R,UAAU,CAACkC,QAA5D,EAAsEiC,KAAtE,CADc,CAAT,CAAb;QAGA,EAAE0N,MAAF;MACH;;MAED,IAAIlH,IAAI,CAACyG,UAAL,CAAgBS,MAAhB,CAAJ,EAA6B;QACzB,IAAIA,MAAM,KAAK,CAAf,EAAkB;UACdjM,MAAM,CAAC2G,IAAP,CAAY,GAAZ;QACH;;QAED,IAAI5B,IAAI,CAACyG,UAAL,CAAgBS,MAAhB,EAAwB9P,IAAxB,KAAiChC,MAAM,CAACgS,wBAA5C,EAAsE;UAClE;UACAnM,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,CACd/E,KADc,EAEd,KAAKkO,kBAAL,CAAwBpE,IAAI,CAACyG,UAAL,CAAgBS,MAAhB,CAAxB,EAAiD7R,UAAU,CAACkC,QAA5D,EAAsEiC,KAAtE,CAFc,CAAT,CAAb;QAIH,CAND,MAMO;UACH;UACAyB,MAAM,CAAC2G,IAAP,CAAY1L,KAAK,GAAG,GAApB;;UAEA,IAAK8J,IAAI,CAACyG,UAAL,CAAgBnL,MAAhB,GAAyB4L,MAA1B,KAAsC,CAA1C,EAA6C;YACzC;YACAjM,MAAM,CAAC2G,IAAP,CAAY1L,KAAZ;YACA+E,MAAM,CAAC2G,IAAP,CAAY,KAAKwC,kBAAL,CAAwBpE,IAAI,CAACyG,UAAL,CAAgBS,MAAhB,CAAxB,EAAiD7R,UAAU,CAACkC,QAA5D,EAAsEiC,KAAtE,CAAZ;YACAyB,MAAM,CAAC2G,IAAP,CAAY1L,KAAK,GAAG,GAAR,GAAcA,KAA1B;UACH,CALD,MAKO;YACH;YACA;YACA;YACA;YACA+J,UAAU,CAAC,UAAUtK,MAAV,EAAkB;cACzB,IAAI8H,CAAJ,EAAOC,EAAP;cACAzC,MAAM,CAAC2G,IAAP,CAAY3L,OAAZ;;cACA,KAAKwH,CAAC,GAAGyJ,MAAJ,EAAYxJ,EAAE,GAAGsC,IAAI,CAACyG,UAAL,CAAgBnL,MAAtC,EAA8CmC,CAAC,GAAGC,EAAlD,EAAsD,EAAED,CAAxD,EAA2D;gBACvDxC,MAAM,CAAC2G,IAAP,CAAYjM,MAAZ;gBACAsF,MAAM,CAAC2G,IAAP,CAAYqB,IAAI,CAACmB,kBAAL,CAAwBpE,IAAI,CAACyG,UAAL,CAAgBhJ,CAAhB,CAAxB,EAA4CpI,UAAU,CAACkC,QAAvD,EAAiEiC,KAAjE,CAAZ;;gBACA,IAAIiE,CAAC,GAAG,CAAJ,GAAQC,EAAZ,EAAgB;kBACZzC,MAAM,CAAC2G,IAAP,CAAY,MAAM3L,OAAlB;gBACH;cACJ;YACJ,CAVS,CAAV;;YAWA,IAAI,CAACmF,sBAAsB,CAAC2D,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+B8B,QAA/B,EAAD,CAA3B,EAAwE;cACpE9B,MAAM,CAAC2G,IAAP,CAAY3L,OAAZ;YACH;;YACDgF,MAAM,CAAC2G,IAAP,CAAYlM,IAAI,GAAG,GAAP,GAAaQ,KAAzB;UACH;QACJ;MACJ;;MAED+E,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,CAClB,SAAS/E,KADS,EAElB;MACA,KAAKkO,kBAAL,CAAwBpE,IAAI,CAACpC,MAA7B,EAAqCvI,UAAU,CAACkC,QAAhD,EAA0DiC,KAA1D,CAHkB,EAIlB,KAAK8L,SAAL,CAAe9H,KAAf,CAJkB,CAAT,CAAb;MAMA,OAAOvC,MAAP;IACH,CA5ZqB;IA8ZtBoM,kBAAkB,EAAE,UAAUrH,IAAV,EAAgBxC,KAAhB,EAAuB;MACvC,IAAI8J,SAAS,GAAI9J,KAAK,GAAGxE,UAAT,GAAuBQ,KAAvB,GAA+BF,KAA/C;;MACA,IAAI0G,IAAI,CAACuH,IAAT,EAAe;QACX,OAAO,CACH,KAAKnD,kBAAL,CAAwBpE,IAAI,CAAC6F,EAA7B,EAAiCxQ,UAAU,CAACoC,UAA5C,EAAwD6P,SAAxD,CADG,EAEHpR,KAFG,EAGH,GAHG,EAIHA,KAJG,EAKH,KAAKkO,kBAAL,CAAwBpE,IAAI,CAACuH,IAA7B,EAAmClS,UAAU,CAACoC,UAA9C,EAA0D6P,SAA1D,CALG,CAAP;MAOH;;MACD,OAAO,KAAKpD,eAAL,CAAqBlE,IAAI,CAAC6F,EAA1B,EAA8BxQ,UAAU,CAACoC,UAAzC,EAAqD6P,SAArD,CAAP;IACH,CA1aqB;IA4atBpC,mBAAmB,EAAE,UAAUlF,IAAV,EAAgBxC,KAAhB,EAAuB;MACxC;MACA;MACA;MACA,IAAIvC,MAAJ;MAAA,IAAYwC,CAAZ;MAAA,IAAeC,EAAf;MAAA,IAAmB1G,IAAnB;MAAA,IAAyBuO,SAAzB;MAAA,IAAoCtC,IAAI,GAAG,IAA3C;MAEAhI,MAAM,GAAG,CAAE+E,IAAI,CAACmF,IAAP,CAAT;MAEAI,SAAS,GAAI/H,KAAK,GAAGxE,UAAT,GAAuBY,MAAvB,GAAgCE,MAA5C;;MAEA,SAAS0N,KAAT,GAAiB;QACbxQ,IAAI,GAAGgJ,IAAI,CAACoF,YAAL,CAAkB,CAAlB,CAAP;;QACA,IAAI7O,KAAK,CAAC2D,OAAN,IAAiBlD,IAAI,CAACyK,eAA1B,EAA2C;UACvCxG,MAAM,CAAC2G,IAAP,CAAY,IAAZ;UACA3G,MAAM,CAAC2G,IAAP,CAAY7B,SAAS,CAACkD,IAAI,CAACE,iBAAL,CAAuBnM,IAAvB,EAA6BuO,SAA7B,CAAD,CAArB;QACH,CAHD,MAGO;UACHtK,MAAM,CAAC2G,IAAP,CAAYtC,YAAY,EAAxB;UACArE,MAAM,CAAC2G,IAAP,CAAYqB,IAAI,CAACE,iBAAL,CAAuBnM,IAAvB,EAA6BuO,SAA7B,CAAZ;QACH;;QAED,KAAK9H,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGsC,IAAI,CAACoF,YAAL,CAAkB9J,MAAnC,EAA2CmC,CAAC,GAAGC,EAA/C,EAAmD,EAAED,CAArD,EAAwD;UACpDzG,IAAI,GAAGgJ,IAAI,CAACoF,YAAL,CAAkB3H,CAAlB,CAAP;;UACA,IAAIlH,KAAK,CAAC2D,OAAN,IAAiBlD,IAAI,CAACyK,eAA1B,EAA2C;YACvCxG,MAAM,CAAC2G,IAAP,CAAY,MAAM3L,OAAlB;YACAgF,MAAM,CAAC2G,IAAP,CAAY7B,SAAS,CAACkD,IAAI,CAACE,iBAAL,CAAuBnM,IAAvB,EAA6BuO,SAA7B,CAAD,CAArB;UACH,CAHD,MAGO;YACHtK,MAAM,CAAC2G,IAAP,CAAY,MAAM1L,KAAlB;YACA+E,MAAM,CAAC2G,IAAP,CAAYqB,IAAI,CAACE,iBAAL,CAAuBnM,IAAvB,EAA6BuO,SAA7B,CAAZ;UACH;QACJ;MACJ;;MAED,IAAIvF,IAAI,CAACoF,YAAL,CAAkB9J,MAAlB,GAA2B,CAA/B,EAAkC;QAC9B2E,UAAU,CAACuH,KAAD,CAAV;MACH,CAFD,MAEO;QACHA,KAAK;MACR;;MAEDvM,MAAM,CAAC2G,IAAP,CAAY,KAAK0D,SAAL,CAAe9H,KAAf,CAAZ;MAEA,OAAOvC,MAAP;IACH,CArdqB;IAudtBwM,cAAc,EAAE,UAAUzH,IAAV,EAAgBxC,KAAhB,EAAuB;MACnC,OAAO,CAAC+B,IAAI,CACR,OADQ,EAER,KAAK6E,kBAAL,CAAwBpE,IAAI,CAAC0H,QAA7B,EAAuCrS,UAAU,CAACkC,QAAlD,EAA4DiC,KAA5D,CAFQ,CAAL,EAGJ,KAAK8L,SAAL,CAAe9H,KAAf,CAHI,CAAP;IAIH,CA5dqB;IA8dtBmK,YAAY,EAAE,UAAU3H,IAAV,EAAgBxC,KAAhB,EAAuB;MACjC,IAAIvC,MAAJ,EAAYwC,CAAZ,EAAeC,EAAf,EAAmBkK,eAAnB;MAEA3M,MAAM,GAAG,CAAC,KAAD,EAAQ,KAAK8H,UAAL,CAAgB/C,IAAI,CAACwH,KAArB,EAA4B5N,MAA5B,CAAR,CAAT;MACAqB,MAAM,GAAG,KAAKoI,gBAAL,CAAsBrD,IAAI,CAACwH,KAA3B,EAAkCvM,MAAlC,CAAT;;MAEA,IAAI+E,IAAI,CAAC6H,QAAT,EAAmB;QACf;QACA,KAAKpK,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGsC,IAAI,CAAC6H,QAAL,CAAcvM,MAA/B,EAAuCmC,CAAC,GAAGC,EAA3C,EAA+C,EAAED,CAAjD,EAAoD;UAChDxC,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,KAAKkI,iBAAL,CAAuBnD,IAAI,CAAC6H,QAAL,CAAcpK,CAAd,CAAvB,EAAyC7D,MAAzC,CAAT,CAAb;;UACA,IAAIoG,IAAI,CAAC8H,SAAL,IAAkBrK,CAAC,GAAG,CAAJ,KAAUC,EAAhC,EAAoC;YAChCzC,MAAM,GAAG,KAAKoI,gBAAL,CAAsBrD,IAAI,CAAC6H,QAAL,CAAcpK,CAAd,EAAiBqE,IAAvC,EAA6C7G,MAA7C,CAAT;UACH;QACJ;MACJ,CARD,MAQO;QACH2M,eAAe,GAAG5H,IAAI,CAAC4H,eAAL,IAAwB,EAA1C;;QAEA,KAAKnK,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGkK,eAAe,CAACtM,MAAjC,EAAyCmC,CAAC,GAAGC,EAA7C,EAAiD,EAAED,CAAnD,EAAsD;UAClDxC,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,KAAKkI,iBAAL,CAAuByE,eAAe,CAACnK,CAAD,CAAtC,EAA2C7D,MAA3C,CAAT,CAAb;;UACA,IAAIoG,IAAI,CAAC8H,SAAL,IAAkBrK,CAAC,GAAG,CAAJ,KAAUC,EAAhC,EAAoC;YAChCzC,MAAM,GAAG,KAAKoI,gBAAL,CAAsBuE,eAAe,CAACnK,CAAD,CAAf,CAAmBqE,IAAzC,EAA+C7G,MAA/C,CAAT;UACH;QACJ,CARE,CAUH;;;QACA,IAAI+E,IAAI,CAAC+H,OAAT,EAAkB;UACd,IAAIlJ,KAAK,CAACC,OAAN,CAAckB,IAAI,CAAC+H,OAAnB,CAAJ,EAAiC;YAC7B,KAAKtK,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGsC,IAAI,CAAC+H,OAAL,CAAazM,MAA9B,EAAsCmC,CAAC,GAAGC,EAA1C,EAA8C,EAAED,CAAhD,EAAmD;cAC/CxC,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,KAAKkI,iBAAL,CAAuBnD,IAAI,CAAC+H,OAAL,CAAatK,CAAb,CAAvB,EAAwC7D,MAAxC,CAAT,CAAb;;cACA,IAAIoG,IAAI,CAAC8H,SAAL,IAAkBrK,CAAC,GAAG,CAAJ,KAAUC,EAAhC,EAAoC;gBAChCzC,MAAM,GAAG,KAAKoI,gBAAL,CAAsBrD,IAAI,CAAC+H,OAAL,CAAatK,CAAb,EAAgBqE,IAAtC,EAA4C7G,MAA5C,CAAT;cACH;YACJ;UACJ,CAPD,MAOO;YACHA,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,KAAKkI,iBAAL,CAAuBnD,IAAI,CAAC+H,OAA5B,EAAqCnO,MAArC,CAAT,CAAb;;YACA,IAAIoG,IAAI,CAAC8H,SAAT,EAAoB;cAChB7M,MAAM,GAAG,KAAKoI,gBAAL,CAAsBrD,IAAI,CAAC+H,OAAL,CAAajG,IAAnC,EAAyC7G,MAAzC,CAAT;YACH;UACJ;QACJ;MACJ;;MACD,IAAI+E,IAAI,CAAC8H,SAAT,EAAoB;QAChB7M,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,CAAC,SAAD,EAAY,KAAK8H,UAAL,CAAgB/C,IAAI,CAAC8H,SAArB,EAAgClO,MAAhC,CAAZ,CAAT,CAAb;MACH;;MACD,OAAOqB,MAAP;IACH,CA3gBqB;IA6gBtB+M,eAAe,EAAE,UAAUhI,IAAV,EAAgBxC,KAAhB,EAAuB;MACpC,IAAIvC,MAAJ;MAAA,IAAYgG,QAAZ;MAAA,IAAsBxD,CAAtB;MAAA,IAAyBC,EAAzB;MAAA,IAA6B6H,SAA7B;MAAA,IAAwCtC,IAAI,GAAG,IAA/C;MACAhD,UAAU,CAAC,YAAY;QACnBhF,MAAM,GAAG,CACL,WAAW/E,KAAX,GAAmB,GADd,EAEL+M,IAAI,CAACmB,kBAAL,CAAwBpE,IAAI,CAACiI,YAA7B,EAA2C5S,UAAU,CAACkC,QAAtD,EAAgEiC,KAAhE,CAFK,EAGL,MAAMtD,KAAN,GAAc,GAAd,GAAoBD,OAHf,CAAT;MAKH,CANS,CAAV;;MAOA,IAAI+J,IAAI,CAACkI,KAAT,EAAgB;QACZ3C,SAAS,GAAG3L,MAAZ;;QACA,KAAK6D,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGsC,IAAI,CAACkI,KAAL,CAAW5M,MAA5B,EAAoCmC,CAAC,GAAGC,EAAxC,EAA4C,EAAED,CAA9C,EAAiD;UAC7C,IAAIA,CAAC,KAAKC,EAAE,GAAG,CAAf,EAAkB;YACd6H,SAAS,IAAIlM,eAAb;UACH;;UACD4H,QAAQ,GAAGlB,SAAS,CAAC,KAAKoD,iBAAL,CAAuBnD,IAAI,CAACkI,KAAL,CAAWzK,CAAX,CAAvB,EAAsC8H,SAAtC,CAAD,CAApB;UACAtK,MAAM,CAAC2G,IAAP,CAAYX,QAAZ;;UACA,IAAI,CAAC7F,sBAAsB,CAAC2D,sBAAsB,CAACkC,QAAD,CAAtB,CAAiClE,QAAjC,EAAD,CAA3B,EAA0E;YACtE9B,MAAM,CAAC2G,IAAP,CAAY3L,OAAZ;UACH;QACJ;MACJ;;MACDgF,MAAM,CAAC2G,IAAP,CAAY7B,SAAS,CAAC,GAAD,CAArB;MACA,OAAO9E,MAAP;IACH,CAriBqB;IAuiBtBkN,UAAU,EAAE,UAAUnI,IAAV,EAAgBxC,KAAhB,EAAuB;MAC/B,IAAIvC,MAAJ;MAAA,IAAYgG,QAAZ;MAAA,IAAsBxD,CAAtB;MAAA,IAAyBC,EAAzB;MAAA,IAA6B6H,SAA7B;MAAA,IAAwCtC,IAAI,GAAG,IAA/C;MACAhD,UAAU,CAAC,YAAY;QACnB,IAAID,IAAI,CAAC7E,IAAT,EAAe;UACXF,MAAM,GAAG,CACLsE,IAAI,CAAC,MAAD,EAAS0D,IAAI,CAACmB,kBAAL,CAAwBpE,IAAI,CAAC7E,IAA7B,EAAmC9F,UAAU,CAACkC,QAA9C,EAAwDiC,KAAxD,CAAT,CADC,EAEL,GAFK,CAAT;QAIH,CALD,MAKO;UACHyB,MAAM,GAAG,CAAC,UAAD,CAAT;QACH;;QAEDwC,CAAC,GAAG,CAAJ;QACAC,EAAE,GAAGsC,IAAI,CAACoI,UAAL,CAAgB9M,MAArB;;QACA,IAAIoC,EAAE,IAAIsC,IAAI,CAACoI,UAAL,CAAgB,CAAhB,EAAmBhR,IAAnB,KAA4BhC,MAAM,CAAC8N,cAA7C,EAA6D;UACzDjC,QAAQ,GAAGgC,IAAI,CAACF,UAAL,CAAgB/C,IAAI,CAACoI,UAAL,CAAgB,CAAhB,CAAhB,EAAoCxO,MAApC,CAAX;UACAqB,MAAM,CAAC2G,IAAP,CAAYX,QAAZ;UACAxD,CAAC,GAAG,CAAJ;QACH;;QAED,IAAIA,CAAC,KAAKC,EAAN,IAAY,CAACtC,sBAAsB,CAAC2D,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+B8B,QAA/B,EAAD,CAAvC,EAAoF;UAChF9B,MAAM,CAAC2G,IAAP,CAAY3L,OAAZ;QACH;;QAEDsP,SAAS,GAAG3L,MAAZ;;QACA,OAAO6D,CAAC,GAAGC,EAAX,EAAe,EAAED,CAAjB,EAAoB;UAChB,IAAIA,CAAC,KAAKC,EAAE,GAAG,CAAX,IAAgBF,KAAK,GAAGnE,eAA5B,EAA6C;YACzCkM,SAAS,IAAIlM,eAAb;UACH;;UACD4H,QAAQ,GAAGlB,SAAS,CAACkD,IAAI,CAACE,iBAAL,CAAuBnD,IAAI,CAACoI,UAAL,CAAgB3K,CAAhB,CAAvB,EAA2C8H,SAA3C,CAAD,CAApB;UACAtK,MAAM,CAAC2G,IAAP,CAAYX,QAAZ;;UACA,IAAIxD,CAAC,GAAG,CAAJ,KAAUC,EAAV,IAAgB,CAACtC,sBAAsB,CAAC2D,sBAAsB,CAACkC,QAAD,CAAtB,CAAiClE,QAAjC,EAAD,CAA3C,EAA0F;YACtF9B,MAAM,CAAC2G,IAAP,CAAY3L,OAAZ;UACH;QACJ;MACJ,CAjCS,CAAV;MAkCA,OAAOgF,MAAP;IACH,CA5kBqB;IA8kBtBoN,WAAW,EAAE,UAAUrI,IAAV,EAAgBxC,KAAhB,EAAuB;MAChC,IAAIvC,MAAJ;MAAA,IAAYsK,SAAZ;MAAA,IAAuB+C,iBAAvB;MAAA,IAA0CrF,IAAI,GAAG,IAAjD;MACAhD,UAAU,CAAC,YAAY;QACnBhF,MAAM,GAAG,CACL,OAAO/E,KAAP,GAAe,GADV,EAEL+M,IAAI,CAACmB,kBAAL,CAAwBpE,IAAI,CAAC7E,IAA7B,EAAmC9F,UAAU,CAACkC,QAA9C,EAAwDiC,KAAxD,CAFK,EAGL,GAHK,CAAT;MAKH,CANS,CAAV;MAOA8O,iBAAiB,GAAG9K,KAAK,GAAGnE,eAA5B;MACAkM,SAAS,GAAG3L,MAAZ;;MACA,IAAI0O,iBAAJ,EAAuB;QACnB/C,SAAS,IAAIlM,eAAb;MACH;;MACD,IAAI2G,IAAI,CAACuI,SAAT,EAAoB;QAChBtN,MAAM,CAAC2G,IAAP,CAAY,KAAKmB,UAAL,CAAgB/C,IAAI,CAACoI,UAArB,EAAiCxO,MAAjC,CAAZ;QACAqB,MAAM,GAAG,KAAKoI,gBAAL,CAAsBrD,IAAI,CAACoI,UAA3B,EAAuCnN,MAAvC,CAAT;;QACA,IAAI+E,IAAI,CAACuI,SAAL,CAAenR,IAAf,KAAwBhC,MAAM,CAACiT,WAAnC,EAAgD;UAC5CpN,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,CAAC,OAAD,EAAU,KAAKkI,iBAAL,CAAuBnD,IAAI,CAACuI,SAA5B,EAAuChD,SAAvC,CAAV,CAAT,CAAb;QACH,CAFD,MAEO;UACHtK,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAASsE,IAAI,CAAC,MAAD,EAAS,KAAKwD,UAAL,CAAgB/C,IAAI,CAACuI,SAArB,EAAgChD,SAAhC,CAAT,CAAb,CAAb;QACH;MACJ,CARD,MAQO;QACHtK,MAAM,CAAC2G,IAAP,CAAY,KAAKmB,UAAL,CAAgB/C,IAAI,CAACoI,UAArB,EAAiC7C,SAAjC,CAAZ;MACH;;MACD,OAAOtK,MAAP;IACH,CAxmBqB;IA0mBtBuN,YAAY,EAAE,UAAUxI,IAAV,EAAgBxC,KAAhB,EAAuB;MACjC,IAAIvC,MAAJ;MAAA,IAAYgI,IAAI,GAAG,IAAnB;MACAhD,UAAU,CAAC,YAAY;QACnBhF,MAAM,GAAG,CAAC,QAAQ/E,KAAR,GAAgB,GAAjB,CAAT;;QACA,IAAI8J,IAAI,CAACuH,IAAT,EAAe;UACX,IAAIvH,IAAI,CAACuH,IAAL,CAAUnQ,IAAV,KAAmBhC,MAAM,CAAC8P,mBAA9B,EAAmD;YAC/CjK,MAAM,CAAC2G,IAAP,CAAYqB,IAAI,CAACE,iBAAL,CAAuBnD,IAAI,CAACuH,IAA5B,EAAkCzN,MAAlC,CAAZ;UACH,CAFD,MAEO;YACH;YACAmB,MAAM,CAAC2G,IAAP,CAAYqB,IAAI,CAACmB,kBAAL,CAAwBpE,IAAI,CAACuH,IAA7B,EAAmClS,UAAU,CAACkC,QAA9C,EAAwD+B,KAAxD,CAAZ;YACA2B,MAAM,CAAC2G,IAAP,CAAY,GAAZ;UACH;QACJ,CARD,MAQO;UACH3G,MAAM,CAAC2G,IAAP,CAAY,GAAZ;QACH;;QAED,IAAI5B,IAAI,CAAC7E,IAAT,EAAe;UACXF,MAAM,CAAC2G,IAAP,CAAY1L,KAAZ;UACA+E,MAAM,CAAC2G,IAAP,CAAYqB,IAAI,CAACmB,kBAAL,CAAwBpE,IAAI,CAAC7E,IAA7B,EAAmC9F,UAAU,CAACkC,QAA9C,EAAwDiC,KAAxD,CAAZ;UACAyB,MAAM,CAAC2G,IAAP,CAAY,GAAZ;QACH,CAJD,MAIO;UACH3G,MAAM,CAAC2G,IAAP,CAAY,GAAZ;QACH;;QAED,IAAI5B,IAAI,CAACyI,MAAT,EAAiB;UACbxN,MAAM,CAAC2G,IAAP,CAAY1L,KAAZ;UACA+E,MAAM,CAAC2G,IAAP,CAAYqB,IAAI,CAACmB,kBAAL,CAAwBpE,IAAI,CAACyI,MAA7B,EAAqCpT,UAAU,CAACkC,QAAhD,EAA0DiC,KAA1D,CAAZ;UACAyB,MAAM,CAAC2G,IAAP,CAAY,GAAZ;QACH,CAJD,MAIO;UACH3G,MAAM,CAAC2G,IAAP,CAAY,GAAZ;QACH;MACJ,CA7BS,CAAV;MA+BA3G,MAAM,CAAC2G,IAAP,CAAY,KAAKmB,UAAL,CAAgB/C,IAAI,CAAC8B,IAArB,EAA2BtE,KAAK,GAAGnE,eAAR,GAA0BQ,MAA1B,GAAmCD,MAA9D,CAAZ;MACA,OAAOqB,MAAP;IACH,CA7oBqB;IA+oBtByN,cAAc,EAAE,UAAU1I,IAAV,EAAgBxC,KAAhB,EAAuB;MACnC,OAAO,KAAKuH,6BAAL,CAAmC,IAAnC,EAAyC/E,IAAzC,EAA+CxC,KAAK,GAAGnE,eAAR,GAA0BQ,MAA1B,GAAmCD,MAAlF,CAAP;IACH,CAjpBqB;IAmpBtB+O,cAAc,EAAE,UAAU3I,IAAV,EAAgBxC,KAAhB,EAAuB;MACnC,OAAO,KAAKuH,6BAAL,CAAmC,IAAnC,EAAyC/E,IAAzC,EAA+CxC,KAAK,GAAGnE,eAAR,GAA0BQ,MAA1B,GAAmCD,MAAlF,CAAP;IACH,CArpBqB;IAupBtBgP,gBAAgB,EAAE,UAAU5I,IAAV,EAAgBxC,KAAhB,EAAuB;MACrC,OAAO,CAACwC,IAAI,CAACyF,KAAL,CAAWvG,IAAX,GAAkB,GAAnB,EAAwB,KAAK6D,UAAL,CAAgB/C,IAAI,CAAC8B,IAArB,EAA2BtE,KAAK,GAAGnE,eAAR,GAA0BQ,MAA1B,GAAmCD,MAA9D,CAAxB,CAAP;IACH,CAzpBqB;IA2pBtBiI,OAAO,EAAE,UAAU7B,IAAV,EAAgBxC,KAAhB,EAAuB;MAC5B,IAAIvC,MAAJ,EAAYgG,QAAZ,EAAsBxD,CAAtB,EAAyBC,EAAzB,EAA6B6H,SAA7B;MACA7H,EAAE,GAAGsC,IAAI,CAAC8B,IAAL,CAAUxG,MAAf;MACAL,MAAM,GAAG,CAAC5E,iBAAiB,IAAIqH,EAAE,GAAG,CAA1B,GAA8B,IAA9B,GAAqC,EAAtC,CAAT;MACA6H,SAAS,GAAGxL,MAAZ;;MACA,KAAK0D,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGC,EAAhB,EAAoB,EAAED,CAAtB,EAAyB;QACrB,IAAI,CAACpH,iBAAD,IAAsBoH,CAAC,KAAKC,EAAE,GAAG,CAArC,EAAwC;UACpC6H,SAAS,IAAIlM,eAAb;QACH;;QAED,IAAI1C,kBAAJ,EAAwB;UACpB;UACA,IAAI8G,CAAC,KAAK,CAAV,EAAa;YACT,IAAI,CAACuC,IAAI,CAAC8B,IAAL,CAAU,CAAV,EAAaL,eAAlB,EAAmC;cAC/BO,kBAAkB,CAAChC,IAAI,CAACmB,KAAL,CAAW,CAAX,CAAD,EAAgBnB,IAAI,CAAC8B,IAAL,CAAUrE,CAAV,EAAa0D,KAAb,CAAmB,CAAnB,CAAhB,EAAuClG,MAAvC,CAAlB;YACH;UACJ,CANmB,CAQpB;;;UACA,IAAIwC,CAAC,GAAG,CAAR,EAAW;YACP,IAAI,CAACuC,IAAI,CAAC8B,IAAL,CAAUrE,CAAC,GAAG,CAAd,EAAiBsE,gBAAlB,IAAsC,CAAC/B,IAAI,CAAC8B,IAAL,CAAUrE,CAAV,EAAagE,eAAxD,EAAyE;cACrEO,kBAAkB,CAAChC,IAAI,CAAC8B,IAAL,CAAUrE,CAAC,GAAG,CAAd,EAAiB0D,KAAjB,CAAuB,CAAvB,CAAD,EAA4BnB,IAAI,CAAC8B,IAAL,CAAUrE,CAAV,EAAa0D,KAAb,CAAmB,CAAnB,CAA5B,EAAmDlG,MAAnD,CAAlB;YACH;UACJ;QACJ;;QAEDgG,QAAQ,GAAGlB,SAAS,CAAC,KAAKoD,iBAAL,CAAuBnD,IAAI,CAAC8B,IAAL,CAAUrE,CAAV,CAAvB,EAAqC8H,SAArC,CAAD,CAApB;QACAtK,MAAM,CAAC2G,IAAP,CAAYX,QAAZ;;QACA,IAAIxD,CAAC,GAAG,CAAJ,GAAQC,EAAR,IAAc,CAACtC,sBAAsB,CAAC2D,sBAAsB,CAACkC,QAAD,CAAtB,CAAiClE,QAAjC,EAAD,CAAzC,EAAwF;UACpF,IAAIpG,kBAAJ,EAAwB;YACpB,IAAI,CAACqJ,IAAI,CAAC8B,IAAL,CAAUrE,CAAC,GAAG,CAAd,EAAiBgE,eAAtB,EAAuC;cACnCxG,MAAM,CAAC2G,IAAP,CAAY3L,OAAZ;YACH;UACJ,CAJD,MAIO;YACHgF,MAAM,CAAC2G,IAAP,CAAY3L,OAAZ;UACH;QACJ;;QAED,IAAIU,kBAAJ,EAAwB;UACpB;UACA,IAAI8G,CAAC,KAAKC,EAAE,GAAG,CAAf,EAAkB;YACd,IAAI,CAACsC,IAAI,CAAC8B,IAAL,CAAUrE,CAAV,EAAasE,gBAAlB,EAAoC;cAChCC,kBAAkB,CAAChC,IAAI,CAAC8B,IAAL,CAAUrE,CAAV,EAAa0D,KAAb,CAAmB,CAAnB,CAAD,EAAwBnB,IAAI,CAACmB,KAAL,CAAW,CAAX,CAAxB,EAAuClG,MAAvC,CAAlB;YACH;UACJ;QACJ;MACJ;;MACD,OAAOA,MAAP;IACH,CA3sBqB;IA6sBtB4N,mBAAmB,EAAE,UAAU7I,IAAV,EAAgBxC,KAAhB,EAAuB;MACxC,OAAO,CACHgG,mBAAmB,CAACxD,IAAD,EAAO,IAAP,CADhB,EAEH,UAFG,EAGH2D,kBAAkB,CAAC3D,IAAD,CAAlB,IAA4BV,YAAY,EAHrC,EAIHU,IAAI,CAAC6F,EAAL,GAAUtC,kBAAkB,CAACvD,IAAI,CAAC6F,EAAN,CAA5B,GAAwC,EAJrC,EAKH,KAAKjB,oBAAL,CAA0B5E,IAA1B,CALG,CAAP;IAOH,CArtBqB;IAutBtB8I,eAAe,EAAE,UAAU9I,IAAV,EAAgBxC,KAAhB,EAAuB;MACpC,IAAIwC,IAAI,CAAC0H,QAAT,EAAmB;QACf,OAAO,CAACnI,IAAI,CACR,QADQ,EAER,KAAK6E,kBAAL,CAAwBpE,IAAI,CAAC0H,QAA7B,EAAuCrS,UAAU,CAACkC,QAAlD,EAA4DiC,KAA5D,CAFQ,CAAL,EAGJ,KAAK8L,SAAL,CAAe9H,KAAf,CAHI,CAAP;MAIH;;MACD,OAAO,CAAC,WAAW,KAAK8H,SAAL,CAAe9H,KAAf,CAAZ,CAAP;IACH,CA/tBqB;IAiuBtBuL,cAAc,EAAE,UAAU/I,IAAV,EAAgBxC,KAAhB,EAAuB;MACnC,IAAIvC,MAAJ;MAAA,IAAYgI,IAAI,GAAG,IAAnB;MACAhD,UAAU,CAAC,YAAY;QACnBhF,MAAM,GAAG,CACL,UAAU/E,KAAV,GAAkB,GADb,EAEL+M,IAAI,CAACmB,kBAAL,CAAwBpE,IAAI,CAAC7E,IAA7B,EAAmC9F,UAAU,CAACkC,QAA9C,EAAwDiC,KAAxD,CAFK,EAGL,GAHK,CAAT;MAKH,CANS,CAAV;MAOAyB,MAAM,CAAC2G,IAAP,CAAY,KAAKmB,UAAL,CAAgB/C,IAAI,CAAC8B,IAArB,EAA2BtE,KAAK,GAAGnE,eAAR,GAA0BQ,MAA1B,GAAmCD,MAA9D,CAAZ;MACA,OAAOqB,MAAP;IACH,CA5uBqB;IA8uBtB+N,aAAa,EAAE,UAAUhJ,IAAV,EAAgBxC,KAAhB,EAAuB;MAClC,IAAIvC,MAAJ;MAAA,IAAYgI,IAAI,GAAG,IAAnB;MACAhD,UAAU,CAAC,YAAY;QACnBhF,MAAM,GAAG,CACL,SAAS/E,KAAT,GAAiB,GADZ,EAEL+M,IAAI,CAACmB,kBAAL,CAAwBpE,IAAI,CAACiJ,MAA7B,EAAqC5T,UAAU,CAACkC,QAAhD,EAA0DiC,KAA1D,CAFK,EAGL,GAHK,CAAT;MAKH,CANS,CAAV;MAOAyB,MAAM,CAAC2G,IAAP,CAAY,KAAKmB,UAAL,CAAgB/C,IAAI,CAAC8B,IAArB,EAA2BtE,KAAK,GAAGnE,eAAR,GAA0BQ,MAA1B,GAAmCD,MAA9D,CAAZ;MACA,OAAOqB,MAAP;IACH;EAzvBqB,CAA1B;EA6vBAS,KAAK,CAACzE,aAAa,CAAC6L,SAAf,EAA0B7L,aAAa,CAACK,SAAxC,CAAL,CArtDS,CAutDT;;EAEAL,aAAa,CAACC,UAAd,GAA2B;IAEvBgS,kBAAkB,EAAE,UAAUxG,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MACnD,IAAIvC,MAAJ,EAAYwC,CAAZ,EAAeC,EAAf;;MACA,IAAIrI,UAAU,CAACkC,QAAX,GAAsBoL,UAA1B,EAAsC;QAClCnF,KAAK,IAAIxE,UAAT;MACH;;MACDiC,MAAM,GAAG,EAAT;;MACA,KAAKwC,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGgF,IAAI,CAACyG,WAAL,CAAiB7N,MAAlC,EAA0CmC,CAAC,GAAGC,EAA9C,EAAkD,EAAED,CAApD,EAAuD;QACnDxC,MAAM,CAAC2G,IAAP,CAAY,KAAKwC,kBAAL,CAAwB1B,IAAI,CAACyG,WAAL,CAAiB1L,CAAjB,CAAxB,EAA6CpI,UAAU,CAACoC,UAAxD,EAAoE+F,KAApE,CAAZ;;QACA,IAAIC,CAAC,GAAG,CAAJ,GAAQC,EAAZ,EAAgB;UACZzC,MAAM,CAAC2G,IAAP,CAAY,MAAM1L,KAAlB;QACH;MACJ;;MACD,OAAOiM,YAAY,CAAClH,MAAD,EAAS5F,UAAU,CAACkC,QAApB,EAA8BoL,UAA9B,CAAnB;IACH,CAfsB;IAiBvByG,oBAAoB,EAAE,UAAU1G,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MACrD,OAAO,KAAKmH,kBAAL,CAAwBjC,IAAI,CAAClD,IAA7B,EAAmCkD,IAAI,CAACjD,KAAxC,EAA+CiD,IAAI,CAACsC,QAApD,EAA8DrC,UAA9D,EAA0EnF,KAA1E,CAAP;IACH,CAnBsB;IAqBvB+G,uBAAuB,EAAE,UAAU7B,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MACxD,OAAO2E,YAAY,CAAC,KAAKyC,oBAAL,CAA0BlC,IAA1B,CAAD,EAAkCrN,UAAU,CAACsC,aAA7C,EAA4DgL,UAA5D,CAAnB;IACH,CAvBsB;IAyBvB0G,qBAAqB,EAAE,UAAU3G,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MACtD,IAAInI,UAAU,CAACqC,WAAX,GAAyBiL,UAA7B,EAAyC;QACrCnF,KAAK,IAAIxE,UAAT;MACH;;MACD,OAAOmJ,YAAY,CACf,CACI,KAAKiC,kBAAL,CAAwB1B,IAAI,CAACvH,IAA7B,EAAmC9F,UAAU,CAACuC,SAA9C,EAAyD4F,KAAzD,CADJ,EAEItH,KAAK,GAAG,GAAR,GAAcA,KAFlB,EAGI,KAAKkO,kBAAL,CAAwB1B,IAAI,CAAC0F,UAA7B,EAAyC/S,UAAU,CAACoC,UAApD,EAAgE+F,KAAhE,CAHJ,EAIItH,KAAK,GAAG,GAAR,GAAcA,KAJlB,EAKI,KAAKkO,kBAAL,CAAwB1B,IAAI,CAAC6F,SAA7B,EAAwClT,UAAU,CAACoC,UAAnD,EAA+D+F,KAA/D,CALJ,CADe,EAQfnI,UAAU,CAACqC,WARI,EASfiL,UATe,CAAnB;IAWH,CAxCsB;IA0CvB2G,iBAAiB,EAAE,UAAU5G,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MAClD,OAAO,KAAK+L,gBAAL,CAAsB7G,IAAtB,EAA4BC,UAA5B,EAAwCnF,KAAxC,CAAP;IACH,CA5CsB;IA8CvB+L,gBAAgB,EAAE,UAAU7G,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MACjD,IAAIvC,MAAJ,EAAYuO,cAAZ,EAA4BC,eAA5B,EAA6CC,iBAA7C,EAAgEzI,QAAhE,EAA0EvB,UAA1E;MACAgK,iBAAiB,GAAGpU,gBAAgB,CAACoN,IAAI,CAACsC,QAAN,CAApC;MACAwE,cAAc,GAAG9G,IAAI,CAACsC,QAAL,KAAkB,IAAlB,GAAyB3P,UAAU,CAACoD,OAApC,GAA8CiR,iBAA/D;MACAD,eAAe,GAAG/G,IAAI,CAACsC,QAAL,KAAkB,IAAlB,GAAyB0E,iBAAzB,GAA6CA,iBAAiB,GAAG,CAAnF;;MAEA,IAAIA,iBAAiB,GAAG/G,UAAxB,EAAoC;QAChCnF,KAAK,IAAIxE,UAAT;MACH;;MAEDiI,QAAQ,GAAG,KAAKmD,kBAAL,CAAwB1B,IAAI,CAAClD,IAA7B,EAAmCgK,cAAnC,EAAmDhM,KAAnD,CAAX;MAEAkC,UAAU,GAAGuB,QAAQ,CAAClE,QAAT,EAAb;;MAEA,IAAI2C,UAAU,CAACjE,UAAX,CAAsBiE,UAAU,CAACpE,MAAX,GAAoB,CAA1C,MAAiD;MAAK;MAAtD,GAAiE7F,OAAO,CAAC8F,IAAR,CAAakD,mBAAb,CAAiCiE,IAAI,CAACsC,QAAL,CAAcvJ,UAAd,CAAyB,CAAzB,CAAjC,CAArE,EAAoI;QAChIR,MAAM,GAAG,CAACgG,QAAD,EAAW3B,YAAY,EAAvB,EAA2BoD,IAAI,CAACsC,QAAhC,CAAT;MACH,CAFD,MAEO;QACH/J,MAAM,GAAGsE,IAAI,CAAC0B,QAAD,EAAWyB,IAAI,CAACsC,QAAhB,CAAb;MACH;;MAED/D,QAAQ,GAAG,KAAKmD,kBAAL,CAAwB1B,IAAI,CAACjD,KAA7B,EAAoCgK,eAApC,EAAqDjM,KAArD,CAAX;;MAEA,IAAIkF,IAAI,CAACsC,QAAL,KAAkB,GAAlB,IAAyB/D,QAAQ,CAAClE,QAAT,GAAoB+H,MAApB,CAA2B,CAA3B,MAAkC,GAA3D,IACJpC,IAAI,CAACsC,QAAL,CAAcrI,KAAd,CAAoB,CAAC,CAArB,MAA4B,GAA5B,IAAmCsE,QAAQ,CAAClE,QAAT,GAAoBJ,KAApB,CAA0B,CAA1B,EAA6B,CAA7B,MAAoC,KADvE,EAC8E;QAC1E;QACA1B,MAAM,CAAC2G,IAAP,CAAYtC,YAAY,EAAxB;QACArE,MAAM,CAAC2G,IAAP,CAAYX,QAAZ;MACH,CALD,MAKO;QACHhG,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAASgG,QAAT,CAAb;MACH;;MAED,IAAIyB,IAAI,CAACsC,QAAL,KAAkB,IAAlB,IAA0B,EAAExH,KAAK,GAAGxE,UAAV,CAA9B,EAAqD;QACjD,OAAO,CAAC,GAAD,EAAMiC,MAAN,EAAc,GAAd,CAAP;MACH;;MACD,OAAOkH,YAAY,CAAClH,MAAD,EAASyO,iBAAT,EAA4B/G,UAA5B,CAAnB;IACH,CAjFsB;IAmFvBgH,cAAc,EAAE,UAAUjH,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MAC/C,IAAIvC,MAAJ,EAAYwC,CAAZ,EAAeC,EAAf,CAD+C,CAG/C;;MACAzC,MAAM,GAAG,CAAC,KAAKmJ,kBAAL,CAAwB1B,IAAI,CAACkH,MAA7B,EAAqCvU,UAAU,CAACsD,IAAhD,EAAsDY,KAAtD,CAAD,CAAT;;MAEA,IAAImJ,IAAI,CAACmH,QAAT,EAAmB;QACf5O,MAAM,CAAC2G,IAAP,CAAY,IAAZ;MACH;;MAED3G,MAAM,CAAC2G,IAAP,CAAY,GAAZ;;MACA,KAAKnE,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGgF,IAAI,CAAC,WAAD,CAAJ,CAAkBpH,MAAnC,EAA2CmC,CAAC,GAAGC,EAA/C,EAAmD,EAAED,CAArD,EAAwD;QACpDxC,MAAM,CAAC2G,IAAP,CAAY,KAAKwC,kBAAL,CAAwB1B,IAAI,CAAC,WAAD,CAAJ,CAAkBjF,CAAlB,CAAxB,EAA8CpI,UAAU,CAACoC,UAAzD,EAAqE+B,KAArE,CAAZ;;QACA,IAAIiE,CAAC,GAAG,CAAJ,GAAQC,EAAZ,EAAgB;UACZzC,MAAM,CAAC2G,IAAP,CAAY,MAAM1L,KAAlB;QACH;MACJ;;MACD+E,MAAM,CAAC2G,IAAP,CAAY,GAAZ;;MAEA,IAAI,EAAEpE,KAAK,GAAGvE,YAAV,CAAJ,EAA6B;QACzB,OAAO,CAAC,GAAD,EAAMgC,MAAN,EAAc,GAAd,CAAP;MACH;;MAED,OAAOkH,YAAY,CAAClH,MAAD,EAAS5F,UAAU,CAACsD,IAApB,EAA0BgK,UAA1B,CAAnB;IACH,CA3GsB;IA6GvBmH,eAAe,EAAE,UAAUpH,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MAChD,IAAInI,UAAU,CAACqD,gBAAX,GAA8BiK,UAAlC,EAA8C;QAC1CnF,KAAK,IAAIvE,YAAT;MACH;;MAED,IAAIgC,MAAM,GAAG,KAAKmJ,kBAAL,CAAwB1B,IAAI,CAACmC,UAA7B,EAAyCxP,UAAU,CAACqD,gBAApD,EAAsE8E,KAAtE,CAAb;MAEA,OAAO2E,YAAY,CAAClH,MAAD,EAAS5F,UAAU,CAACqD,gBAApB,EAAsCiK,UAAtC,CAAnB;IACH,CArHsB;IAuHvBoH,aAAa,EAAE,UAAUrH,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MAC9C,IAAIvC,MAAJ,EAAYK,MAAZ,EAAoBmC,CAApB,EAAuBC,EAAvB,EAA2B4J,SAA3B;MACAhM,MAAM,GAAGoH,IAAI,CAAC,WAAD,CAAJ,CAAkBpH,MAA3B,CAF8C,CAI9C;MACA;;MACAgM,SAAS,GAAI9J,KAAK,GAAGtE,oBAAR,IAAgC,CAAC/C,WAAjC,IAAgDmF,MAAM,KAAK,CAA5D,GAAiE3B,KAAjE,GAAyEF,KAArF;MAEAwB,MAAM,GAAGsE,IAAI,CACT,KADS,EAET,KAAK6E,kBAAL,CAAwB1B,IAAI,CAACkH,MAA7B,EAAqCvU,UAAU,CAACuD,GAAhD,EAAqD0O,SAArD,CAFS,CAAb;;MAKA,IAAI,EAAE9J,KAAK,GAAGtE,oBAAV,KAAmC/C,WAAnC,IAAkDmF,MAAM,GAAG,CAA/D,EAAkE;QAC9DL,MAAM,CAAC2G,IAAP,CAAY,GAAZ;;QACA,KAAKnE,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGpC,MAAjB,EAAyBmC,CAAC,GAAGC,EAA7B,EAAiC,EAAED,CAAnC,EAAsC;UAClCxC,MAAM,CAAC2G,IAAP,CAAY,KAAKwC,kBAAL,CAAwB1B,IAAI,CAAC,WAAD,CAAJ,CAAkBjF,CAAlB,CAAxB,EAA8CpI,UAAU,CAACoC,UAAzD,EAAqE+B,KAArE,CAAZ;;UACA,IAAIiE,CAAC,GAAG,CAAJ,GAAQC,EAAZ,EAAgB;YACZzC,MAAM,CAAC2G,IAAP,CAAY,MAAM1L,KAAlB;UACH;QACJ;;QACD+E,MAAM,CAAC2G,IAAP,CAAY,GAAZ;MACH;;MAED,OAAOO,YAAY,CAAClH,MAAD,EAAS5F,UAAU,CAACuD,GAApB,EAAyB+J,UAAzB,CAAnB;IACH,CAhJsB;IAkJvBqH,gBAAgB,EAAE,UAAUtH,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MACjD,IAAIvC,MAAJ,EAAYgG,QAAZ,CADiD,CAGjD;;MACAhG,MAAM,GAAG,CAAC,KAAKmJ,kBAAL,CAAwB1B,IAAI,CAACuG,MAA7B,EAAqC5T,UAAU,CAACsD,IAAhD,EAAuD6E,KAAK,GAAGvE,YAAT,GAAyBM,KAAzB,GAAiCE,KAAvF,CAAD,CAAT;;MAEA,IAAIiJ,IAAI,CAACuB,QAAT,EAAmB;QACf,IAAIvB,IAAI,CAACmH,QAAT,EAAmB;UACf5O,MAAM,CAAC2G,IAAP,CAAY,IAAZ;QACH;;QAED3G,MAAM,CAAC2G,IAAP,CAAY,GAAZ;QACA3G,MAAM,CAAC2G,IAAP,CAAY,KAAKwC,kBAAL,CAAwB1B,IAAI,CAACuH,QAA7B,EAAuC5U,UAAU,CAACkC,QAAlD,EAA4DiG,KAAK,GAAGvE,YAAR,GAAuBO,KAAvB,GAA+BG,KAA3F,CAAZ;QACAsB,MAAM,CAAC2G,IAAP,CAAY,GAAZ;MACH,CARD,MAQO;QACH,IAAI,CAACc,IAAI,CAACmH,QAAN,IAAkBnH,IAAI,CAACuG,MAAL,CAAY7R,IAAZ,KAAqBhC,MAAM,CAAC4R,OAA9C,IAAyD,OAAOtE,IAAI,CAACuG,MAAL,CAAY7M,KAAnB,KAA6B,QAA1F,EAAoG;UAChG6E,QAAQ,GAAGlC,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+B8B,QAA/B,EAAX,CADgG,CAEhG;UACA;UACA;UACA;UACA;UACA;;UACA,IACQkE,QAAQ,CAACvE,OAAT,CAAiB,GAAjB,IAAwB,CAAxB,IACA,CAAC,SAASvB,IAAT,CAAc8F,QAAd,CADD,IAEAxL,OAAO,CAAC8F,IAAR,CAAa0C,cAAb,CAA4BgD,QAAQ,CAACxF,UAAT,CAAoBwF,QAAQ,CAAC3F,MAAT,GAAkB,CAAtC,CAA5B,CAFA,IAGA,EAAE2F,QAAQ,CAAC3F,MAAT,IAAmB,CAAnB,IAAwB2F,QAAQ,CAACxF,UAAT,CAAoB,CAApB,MAA2B,EAArD,CAJR,CAIkE;UAJlE,EAKU;YACNR,MAAM,CAAC2G,IAAP,CAAY,GAAZ;UACH;QACJ;;QACD3G,MAAM,CAAC2G,IAAP,CAAYc,IAAI,CAACmH,QAAL,GAAgB,IAAhB,GAAuB,GAAnC;QACA5O,MAAM,CAAC2G,IAAP,CAAY2B,kBAAkB,CAACb,IAAI,CAACuH,QAAN,CAA9B;MACH;;MAED,OAAO9H,YAAY,CAAClH,MAAD,EAAS5F,UAAU,CAACyD,MAApB,EAA4B6J,UAA5B,CAAnB;IACH,CAvLsB;IAyLvBuH,YAAY,EAAE,UAAUxH,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MAC7C,IAAIvC,MAAJ;MACAA,MAAM,GAAG,EAAT;MACAA,MAAM,CAAC2G,IAAP,CAAY,OAAOc,IAAI,CAACyH,IAAZ,KAAqB,QAArB,GAAgCzH,IAAI,CAACyH,IAArC,GAA4C5G,kBAAkB,CAACb,IAAI,CAACyH,IAAN,CAA1E;MACAlP,MAAM,CAAC2G,IAAP,CAAY,GAAZ;MACA3G,MAAM,CAAC2G,IAAP,CAAY,OAAOc,IAAI,CAACuH,QAAZ,KAAyB,QAAzB,GAAoCvH,IAAI,CAACuH,QAAzC,GAAoD1G,kBAAkB,CAACb,IAAI,CAACuH,QAAN,CAAlF;MACA,OAAO9H,YAAY,CAAClH,MAAD,EAAS5F,UAAU,CAACyD,MAApB,EAA4B6J,UAA5B,CAAnB;IACH,CAhMsB;IAkMvByH,eAAe,EAAE,UAAU1H,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MAChD,IAAIvC,MAAJ,EAAYgG,QAAZ,EAAsBpB,aAAtB,EAAqCH,UAArC,EAAiDE,YAAjD;MACAqB,QAAQ,GAAG,KAAKmD,kBAAL,CAAwB1B,IAAI,CAACgF,QAA7B,EAAuCrS,UAAU,CAACmD,KAAlD,EAAyDgB,KAAzD,CAAX;;MAEA,IAAItD,KAAK,KAAK,EAAd,EAAkB;QACd+E,MAAM,GAAGsE,IAAI,CAACmD,IAAI,CAACsC,QAAN,EAAgB/D,QAAhB,CAAb;MACH,CAFD,MAEO;QACHhG,MAAM,GAAG,CAACyH,IAAI,CAACsC,QAAN,CAAT;;QACA,IAAItC,IAAI,CAACsC,QAAL,CAAc1J,MAAd,GAAuB,CAA3B,EAA8B;UAC1B;UACA;UACAL,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAASgG,QAAT,CAAb;QACH,CAJD,MAIO;UACH;UACA;UACAvB,UAAU,GAAGX,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+B8B,QAA/B,EAAb;UACA6C,YAAY,GAAGF,UAAU,CAACjE,UAAX,CAAsBiE,UAAU,CAACpE,MAAX,GAAoB,CAA1C,CAAf;UACAuE,aAAa,GAAGoB,QAAQ,CAAClE,QAAT,GAAoBtB,UAApB,CAA+B,CAA/B,CAAhB;;UAEA,IAAK,CAACmE,YAAY,KAAK;UAAM;UAAvB,GAAkCA,YAAY,KAAK;UAAM;UAA1D,KAAsEA,YAAY,KAAKC,aAAxF,IACKpK,OAAO,CAAC8F,IAAR,CAAakD,mBAAb,CAAiCmB,YAAjC,KAAkDnK,OAAO,CAAC8F,IAAR,CAAakD,mBAAb,CAAiCoB,aAAjC,CAD3D,EAC6G;YACzG5E,MAAM,CAAC2G,IAAP,CAAYtC,YAAY,EAAxB;YACArE,MAAM,CAAC2G,IAAP,CAAYX,QAAZ;UACH,CAJD,MAIO;YACHhG,MAAM,CAAC2G,IAAP,CAAYX,QAAZ;UACH;QACJ;MACJ;;MACD,OAAOkB,YAAY,CAAClH,MAAD,EAAS5F,UAAU,CAACmD,KAApB,EAA2BmK,UAA3B,CAAnB;IACH,CA/NsB;IAiOvB0H,eAAe,EAAE,UAAU3H,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MAChD,IAAIvC,MAAJ;;MACA,IAAIyH,IAAI,CAAC4H,QAAT,EAAmB;QACfrP,MAAM,GAAG,QAAT;MACH,CAFD,MAEO;QACHA,MAAM,GAAG,OAAT;MACH;;MACD,IAAIyH,IAAI,CAACgF,QAAT,EAAmB;QACfzM,MAAM,GAAGsE,IAAI,CACTtE,MADS,EAET,KAAKmJ,kBAAL,CAAwB1B,IAAI,CAACgF,QAA7B,EAAuCrS,UAAU,CAACmC,KAAlD,EAAyDgC,KAAzD,CAFS,CAAb;MAIH;;MACD,OAAO2I,YAAY,CAAClH,MAAD,EAAS5F,UAAU,CAACmC,KAApB,EAA2BmL,UAA3B,CAAnB;IACH,CA/OsB;IAiPvB4H,eAAe,EAAE,UAAU7H,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MAChD,IAAIvC,MAAM,GAAGsE,IAAI,CACbmD,IAAI,CAAC8H,GAAL,GAAW,QAAX,GAAsB,OADT,EAEb,KAAKpG,kBAAL,CAAwB1B,IAAI,CAACgF,QAA7B,EAAuCrS,UAAU,CAACkD,KAAlD,EAAyDiB,KAAzD,CAFa,CAAjB;MAIA,OAAO2I,YAAY,CAAClH,MAAD,EAAS5F,UAAU,CAACkD,KAApB,EAA2BoK,UAA3B,CAAnB;IACH,CAvPsB;IAyPvB8H,gBAAgB,EAAE,UAAU/H,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MACjD,IAAIkF,IAAI,CAACrB,MAAT,EAAiB;QACb,OAAOc,YAAY,CACf,CACIO,IAAI,CAACsC,QADT,EAEI,KAAKZ,kBAAL,CAAwB1B,IAAI,CAACgF,QAA7B,EAAuCrS,UAAU,CAACmD,KAAlD,EAAyDgB,KAAzD,CAFJ,CADe,EAKfnE,UAAU,CAACmD,KALI,EAMfmK,UANe,CAAnB;MAQH;;MACD,OAAOR,YAAY,CACf,CACI,KAAKiC,kBAAL,CAAwB1B,IAAI,CAACgF,QAA7B,EAAuCrS,UAAU,CAACoD,OAAlD,EAA2De,KAA3D,CADJ,EAEIkJ,IAAI,CAACsC,QAFT,CADe,EAKf3P,UAAU,CAACoD,OALI,EAMfkK,UANe,CAAnB;IAQH,CA5QsB;IA8QvB+H,kBAAkB,EAAE,UAAUhI,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MACnD,IAAIvC,MAAM,GAAG,CACTuI,mBAAmB,CAACd,IAAD,EAAO,IAAP,CADV,EAET,UAFS,CAAb;;MAIA,IAAIA,IAAI,CAACmD,EAAT,EAAa;QACT5K,MAAM,CAAC2G,IAAP,CAAY+B,kBAAkB,CAACjB,IAAD,CAAlB,IAA4BpD,YAAY,EAApD;QACArE,MAAM,CAAC2G,IAAP,CAAY2B,kBAAkB,CAACb,IAAI,CAACmD,EAAN,CAA9B;MACH,CAHD,MAGO;QACH5K,MAAM,CAAC2G,IAAP,CAAY+B,kBAAkB,CAACjB,IAAD,CAAlB,IAA4BxM,KAAxC;MACH;;MACD+E,MAAM,CAAC2G,IAAP,CAAY,KAAKgD,oBAAL,CAA0BlC,IAA1B,CAAZ;MACA,OAAOzH,MAAP;IACH,CA3RsB;IA6RvB0P,YAAY,EAAE,UAAUjI,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MAC7C,OAAO,KAAKoN,eAAL,CAAqBlI,IAArB,EAA2BC,UAA3B,EAAuCnF,KAAvC,EAA8C,IAA9C,CAAP;IACH,CA/RsB;IAiSvBoN,eAAe,EAAE,UAAUlI,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmCqN,SAAnC,EAA8C;MAC3D,IAAI5P,MAAJ;MAAA,IAAY6P,SAAZ;MAAA,IAAuB7H,IAAI,GAAG,IAA9B;;MACA,IAAI,CAACP,IAAI,CAACqI,QAAL,CAAczP,MAAnB,EAA2B;QACvB,OAAO,IAAP;MACH;;MACDwP,SAAS,GAAGD,SAAS,GAAG,KAAH,GAAWnI,IAAI,CAACqI,QAAL,CAAczP,MAAd,GAAuB,CAAvD;MACAL,MAAM,GAAG,CAAC,GAAD,EAAM6P,SAAS,GAAG7U,OAAH,GAAa,EAA5B,CAAT;MACAgK,UAAU,CAAC,UAAUtK,MAAV,EAAkB;QACzB,IAAI8H,CAAJ,EAAOC,EAAP;;QACA,KAAKD,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGgF,IAAI,CAACqI,QAAL,CAAczP,MAA/B,EAAuCmC,CAAC,GAAGC,EAA3C,EAA+C,EAAED,CAAjD,EAAoD;UAChD,IAAI,CAACiF,IAAI,CAACqI,QAAL,CAActN,CAAd,CAAL,EAAuB;YACnB,IAAIqN,SAAJ,EAAe;cACX7P,MAAM,CAAC2G,IAAP,CAAYjM,MAAZ;YACH;;YACD,IAAI8H,CAAC,GAAG,CAAJ,KAAUC,EAAd,EAAkB;cACdzC,MAAM,CAAC2G,IAAP,CAAY,GAAZ;YACH;UACJ,CAPD,MAOO;YACH3G,MAAM,CAAC2G,IAAP,CAAYkJ,SAAS,GAAGnV,MAAH,GAAY,EAAjC;YACAsF,MAAM,CAAC2G,IAAP,CAAYqB,IAAI,CAACmB,kBAAL,CAAwB1B,IAAI,CAACqI,QAAL,CAActN,CAAd,CAAxB,EAA0CpI,UAAU,CAACoC,UAArD,EAAiE+B,KAAjE,CAAZ;UACH;;UACD,IAAIiE,CAAC,GAAG,CAAJ,GAAQC,EAAZ,EAAgB;YACZzC,MAAM,CAAC2G,IAAP,CAAY,OAAOkJ,SAAS,GAAG7U,OAAH,GAAaC,KAA7B,CAAZ;UACH;QACJ;MACJ,CAlBS,CAAV;;MAmBA,IAAI4U,SAAS,IAAI,CAAC1P,sBAAsB,CAAC2D,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+B8B,QAA/B,EAAD,CAAxC,EAAqF;QACjF9B,MAAM,CAAC2G,IAAP,CAAY3L,OAAZ;MACH;;MACDgF,MAAM,CAAC2G,IAAP,CAAYkJ,SAAS,GAAGpV,IAAH,GAAU,EAA/B;MACAuF,MAAM,CAAC2G,IAAP,CAAY,GAAZ;MACA,OAAO3G,MAAP;IACH,CAjUsB;IAmUvB+P,WAAW,EAAE,UAAStI,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;MAC3C,OAAO,QAAQ,KAAK0G,eAAL,CAAqBxB,IAAI,CAACgF,QAA1B,CAAf;IACH,CArUsB;IAuUvBuD,eAAe,EAAE,UAAUvI,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MAChD,IAAIvC,MAAJ,EAAYgG,QAAZ;MACAhG,MAAM,GAAG,CAAC,OAAD,CAAT;;MACA,IAAIyH,IAAI,CAACmD,EAAT,EAAa;QACT5K,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,KAAKmJ,kBAAL,CAAwB1B,IAAI,CAACmD,EAA7B,EAAiCxQ,UAAU,CAACkC,QAA5C,EAAsDiC,KAAtD,CAAT,CAAb;MACH;;MACD,IAAIkJ,IAAI,CAACoD,UAAT,EAAqB;QACjB7E,QAAQ,GAAG1B,IAAI,CAAC,SAAD,EAAY,KAAK6E,kBAAL,CAAwB1B,IAAI,CAACoD,UAA7B,EAAyCzQ,UAAU,CAACmD,KAApD,EAA2DgB,KAA3D,CAAZ,CAAf;QACAyB,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAASgG,QAAT,CAAb;MACH;;MACDhG,MAAM,CAAC2G,IAAP,CAAY1L,KAAZ;MACA+E,MAAM,CAAC2G,IAAP,CAAY,KAAKuB,iBAAL,CAAuBT,IAAI,CAACZ,IAA5B,EAAkCjI,MAAlC,CAAZ;MACA,OAAOoB,MAAP;IACH,CApVsB;IAsVvBiQ,gBAAgB,EAAE,UAAUxI,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MACjD,IAAIvC,MAAJ,EAAYgG,QAAZ;;MACA,IAAIyB,IAAI,CAAC,QAAD,CAAR,EAAoB;QAChBzH,MAAM,GAAG,CAAC,WAAW/E,KAAZ,CAAT;MACH,CAFD,MAEO;QACH+E,MAAM,GAAG,EAAT;MACH;;MACD,IAAIyH,IAAI,CAACyC,IAAL,KAAc,KAAd,IAAuBzC,IAAI,CAACyC,IAAL,KAAc,KAAzC,EAAgD;QAC5ClE,QAAQ,GAAG,CACP1B,IAAI,CAACmD,IAAI,CAACyC,IAAN,EAAY,KAAKE,mBAAL,CAAyB3C,IAAI,CAAC7G,GAA9B,EAAmC6G,IAAI,CAACuB,QAAxC,CAAZ,CADG,EAEP,KAAKW,oBAAL,CAA0BlC,IAAI,CAACtG,KAA/B,CAFO,CAAX;MAIH,CALD,MAKO;QACH6E,QAAQ,GAAG,CACP6C,oBAAoB,CAACpB,IAAD,CADb,EAEP,KAAK2C,mBAAL,CAAyB3C,IAAI,CAAC7G,GAA9B,EAAmC6G,IAAI,CAACuB,QAAxC,CAFO,EAGP,KAAKW,oBAAL,CAA0BlC,IAAI,CAACtG,KAA/B,CAHO,CAAX;MAKH;;MACD,OAAOmD,IAAI,CAACtE,MAAD,EAASgG,QAAT,CAAX;IACH,CA1WsB;IA4WvBkK,QAAQ,EAAE,UAAUzI,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MACzC,IAAIkF,IAAI,CAACyC,IAAL,KAAc,KAAd,IAAuBzC,IAAI,CAACyC,IAAL,KAAc,KAAzC,EAAgD;QAC5C,OAAO,CACHzC,IAAI,CAACyC,IADF,EACQ7F,YAAY,EADpB,EAEH,KAAK+F,mBAAL,CAAyB3C,IAAI,CAAC7G,GAA9B,EAAmC6G,IAAI,CAACuB,QAAxC,CAFG,EAGH,KAAKW,oBAAL,CAA0BlC,IAAI,CAACtG,KAA/B,CAHG,CAAP;MAKH;;MAED,IAAIsG,IAAI,CAAC0I,SAAT,EAAoB;QAChB,IAAI1I,IAAI,CAACtG,KAAL,CAAWhF,IAAX,KAAoB,mBAAxB,EAA6C;UACzC,OAAO,KAAKiU,iBAAL,CAAuB3I,IAAI,CAACtG,KAA5B,EAAmC/G,UAAU,CAACkC,QAA9C,EAAwDiC,KAAxD,CAAP;QACH;;QACD,OAAO,KAAK6L,mBAAL,CAAyB3C,IAAI,CAAC7G,GAA9B,EAAmC6G,IAAI,CAACuB,QAAxC,CAAP;MACH;;MAED,IAAIvB,IAAI,CAAC4I,MAAT,EAAiB;QACb,OAAO,CACHxH,oBAAoB,CAACpB,IAAD,CADjB,EAEH,KAAK2C,mBAAL,CAAyB3C,IAAI,CAAC7G,GAA9B,EAAmC6G,IAAI,CAACuB,QAAxC,CAFG,EAGH,KAAKW,oBAAL,CAA0BlC,IAAI,CAACtG,KAA/B,CAHG,CAAP;MAKH;;MAED,OAAO,CACH,KAAKiJ,mBAAL,CAAyB3C,IAAI,CAAC7G,GAA9B,EAAmC6G,IAAI,CAACuB,QAAxC,CADG,EAEH,MAAM/N,KAFH,EAGH,KAAKkO,kBAAL,CAAwB1B,IAAI,CAACtG,KAA7B,EAAoC/G,UAAU,CAACoC,UAA/C,EAA2D+B,KAA3D,CAHG,CAAP;IAKH,CAzYsB;IA2YvB+R,gBAAgB,EAAE,UAAU7I,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MACjD,IAAIsN,SAAJ;MAAA,IAAe7P,MAAf;MAAA,IAAuBgG,QAAvB;MAAA,IAAiCgC,IAAI,GAAG,IAAxC;;MAEA,IAAI,CAACP,IAAI,CAAC8I,UAAL,CAAgBlQ,MAArB,EAA6B;QACzB,OAAO,IAAP;MACH;;MACDwP,SAAS,GAAGpI,IAAI,CAAC8I,UAAL,CAAgBlQ,MAAhB,GAAyB,CAArC;MAEA2E,UAAU,CAAC,YAAY;QACnBgB,QAAQ,GAAGgC,IAAI,CAACmB,kBAAL,CAAwB1B,IAAI,CAAC8I,UAAL,CAAgB,CAAhB,CAAxB,EAA4CnW,UAAU,CAACkC,QAAvD,EAAiEiC,KAAjE,CAAX;MACH,CAFS,CAAV;;MAIA,IAAI,CAACsR,SAAL,EAAgB;QACZ;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,IAAI,CAAC5P,iBAAiB,CAAC6D,sBAAsB,CAACkC,QAAD,CAAtB,CAAiClE,QAAjC,EAAD,CAAtB,EAAqE;UACjE,OAAO,CAAE,GAAF,EAAO7G,KAAP,EAAc+K,QAAd,EAAwB/K,KAAxB,EAA+B,GAA/B,CAAP;QACH;MACJ;;MAED+J,UAAU,CAAC,UAAUtK,MAAV,EAAkB;QACzB,IAAI8H,CAAJ,EAAOC,EAAP;QACAzC,MAAM,GAAG,CAAE,GAAF,EAAOhF,OAAP,EAAgBN,MAAhB,EAAwBsL,QAAxB,CAAT;;QAEA,IAAI6J,SAAJ,EAAe;UACX7P,MAAM,CAAC2G,IAAP,CAAY,MAAM3L,OAAlB;;UACA,KAAKwH,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGgF,IAAI,CAAC8I,UAAL,CAAgBlQ,MAAjC,EAAyCmC,CAAC,GAAGC,EAA7C,EAAiD,EAAED,CAAnD,EAAsD;YAClDxC,MAAM,CAAC2G,IAAP,CAAYjM,MAAZ;YACAsF,MAAM,CAAC2G,IAAP,CAAYqB,IAAI,CAACmB,kBAAL,CAAwB1B,IAAI,CAAC8I,UAAL,CAAgB/N,CAAhB,CAAxB,EAA4CpI,UAAU,CAACkC,QAAvD,EAAiEiC,KAAjE,CAAZ;;YACA,IAAIiE,CAAC,GAAG,CAAJ,GAAQC,EAAZ,EAAgB;cACZzC,MAAM,CAAC2G,IAAP,CAAY,MAAM3L,OAAlB;YACH;UACJ;QACJ;MACJ,CAdS,CAAV;;MAgBA,IAAI,CAACmF,sBAAsB,CAAC2D,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+B8B,QAA/B,EAAD,CAA3B,EAAwE;QACpE9B,MAAM,CAAC2G,IAAP,CAAY3L,OAAZ;MACH;;MACDgF,MAAM,CAAC2G,IAAP,CAAYlM,IAAZ;MACAuF,MAAM,CAAC2G,IAAP,CAAY,GAAZ;MACA,OAAO3G,MAAP;IACH,CA3bsB;IA6bvBoQ,iBAAiB,EAAE,UAAS3I,IAAT,EAAeC,UAAf,EAA2BnF,KAA3B,EAAkC;MACjD,OAAO,KAAKmH,kBAAL,CAAwBjC,IAAI,CAAClD,IAA7B,EAAmCkD,IAAI,CAACjD,KAAxC,EAA+C,GAA/C,EAAoDkD,UAApD,EAAgEnF,KAAhE,CAAP;IACH,CA/bsB;IAicvBiO,aAAa,EAAE,UAAU/I,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MAC9C,IAAIvC,MAAJ;MAAA,IAAYwC,CAAZ;MAAA,IAAeC,EAAf;MAAA,IAAmBoN,SAAnB;MAAA,IAA8Bb,QAA9B;MAAA,IAAwChH,IAAI,GAAG,IAA/C;;MACA,IAAI,CAACP,IAAI,CAAC8I,UAAL,CAAgBlQ,MAArB,EAA6B;QACzB,OAAO,IAAP;MACH;;MAEDwP,SAAS,GAAG,KAAZ;;MACA,IAAIpI,IAAI,CAAC8I,UAAL,CAAgBlQ,MAAhB,KAA2B,CAA/B,EAAkC;QAC9B2O,QAAQ,GAAGvH,IAAI,CAAC8I,UAAL,CAAgB,CAAhB,CAAX;;QACA,IACIvB,QAAQ,CAAC7S,IAAT,KAAkBhC,MAAM,CAAC+V,QAAzB,IACGlB,QAAQ,CAAC7N,KAAT,CAAehF,IAAf,KAAwBhC,MAAM,CAAC+O,UAFtC,EAGE;UACE2G,SAAS,GAAG,IAAZ;QACH;MACJ,CARD,MAQO;QACH,KAAKrN,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGgF,IAAI,CAAC8I,UAAL,CAAgBlQ,MAAjC,EAAyCmC,CAAC,GAAGC,EAA7C,EAAiD,EAAED,CAAnD,EAAsD;UAClDwM,QAAQ,GAAGvH,IAAI,CAAC8I,UAAL,CAAgB/N,CAAhB,CAAX;;UACA,IACIwM,QAAQ,CAAC7S,IAAT,KAAkBhC,MAAM,CAAC+V,QAAzB,IACG,CAAClB,QAAQ,CAACmB,SAFjB,EAGE;YACEN,SAAS,GAAG,IAAZ;YACA;UACH;QACJ;MACJ;;MACD7P,MAAM,GAAG,CAAC,GAAD,EAAM6P,SAAS,GAAG7U,OAAH,GAAa,EAA5B,CAAT;MAEAgK,UAAU,CAAC,UAAUtK,MAAV,EAAkB;QACzB,IAAI8H,CAAJ,EAAOC,EAAP;;QACA,KAAKD,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGgF,IAAI,CAAC8I,UAAL,CAAgBlQ,MAAjC,EAAyCmC,CAAC,GAAGC,EAA7C,EAAiD,EAAED,CAAnD,EAAsD;UAClDxC,MAAM,CAAC2G,IAAP,CAAYkJ,SAAS,GAAGnV,MAAH,GAAY,EAAjC;UACAsF,MAAM,CAAC2G,IAAP,CAAYqB,IAAI,CAACmB,kBAAL,CAAwB1B,IAAI,CAAC8I,UAAL,CAAgB/N,CAAhB,CAAxB,EAA4CpI,UAAU,CAACkC,QAAvD,EAAiEiC,KAAjE,CAAZ;;UACA,IAAIiE,CAAC,GAAG,CAAJ,GAAQC,EAAZ,EAAgB;YACZzC,MAAM,CAAC2G,IAAP,CAAY,OAAOkJ,SAAS,GAAG7U,OAAH,GAAaC,KAA7B,CAAZ;UACH;QACJ;MACJ,CATS,CAAV;;MAWA,IAAI4U,SAAS,IAAI,CAAC1P,sBAAsB,CAAC2D,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+B8B,QAA/B,EAAD,CAAxC,EAAqF;QACjF9B,MAAM,CAAC2G,IAAP,CAAY3L,OAAZ;MACH;;MACDgF,MAAM,CAAC2G,IAAP,CAAYkJ,SAAS,GAAGpV,IAAH,GAAU,EAA/B;MACAuF,MAAM,CAAC2G,IAAP,CAAY,GAAZ;MACA,OAAO3G,MAAP;IACH,CA/esB;IAifvByQ,cAAc,EAAE,UAAUhJ,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MAC/C,OAAO,MAAP;IACH,CAnfsB;IAqfvBmO,KAAK,EAAE,UAAUjJ,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MACtC,OAAO,OAAP;IACH,CAvfsB;IAyfvB2G,UAAU,EAAE,UAAUzB,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MAC3C,OAAO+F,kBAAkB,CAACb,IAAD,CAAzB;IACH,CA3fsB;IA6fvByE,sBAAsB,EAAE,UAAUzE,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MACvD,OAAO+F,kBAAkB,CAACb,IAAI,CAACmD,EAAL,IAAWnD,IAAI,CAACkJ,KAAjB,CAAzB;IACH,CA/fsB;IAigBvBxE,wBAAwB,EAAE,UAAU1E,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MACzD,IAAIvC,MAAM,GAAG,CAAC,GAAD,CAAb;MACA,IAAI4K,EAAE,GAAGnD,IAAI,CAACmD,EAAL,IAAWnD,IAAI,CAACkJ,KAAzB;;MACA,IAAI/F,EAAJ,EAAQ;QACJ5K,MAAM,CAAC2G,IAAP,CAAY1L,KAAK,GAAG,IAAR,GAAeoJ,YAAY,EAA3B,GAAgCiE,kBAAkB,CAACsC,EAAD,CAA9D;MACH;;MACD,OAAO5K,MAAP;IACH,CAxgBsB;IA0gBvB4Q,eAAe,EAAE,UAAUnJ,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MAChD,IAAIsO,QAAQ,GAAGpJ,IAAI,CAACoJ,QAApB;MACA,IAAI7Q,MAAM,GAAG,CAAE6Q,QAAQ,CAAC5M,IAAX,CAAb;MACA,IAAI0M,KAAK,GAAGlJ,IAAI,CAACkJ,KAAjB;;MACA,IAAIA,KAAK,IAAIA,KAAK,CAAC1M,IAAN,KAAe4M,QAAQ,CAAC5M,IAArC,EAA2C;QACvCjE,MAAM,CAAC2G,IAAP,CAAYtC,YAAY,KAAK,IAAjB,GAAwBA,YAAY,EAApC,GAAyCiE,kBAAkB,CAACqI,KAAD,CAAvE;MACH;;MACD,OAAO3Q,MAAP;IACH,CAlhBsB;IAohBvB8Q,eAAe,EAAE,UAAUrJ,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MAChD,IAAIoO,KAAK,GAAGlJ,IAAI,CAACkJ,KAAjB;MACA,IAAI3Q,MAAM,GAAG,CAAE2Q,KAAK,CAAC1M,IAAR,CAAb;MACA,IAAI8M,QAAQ,GAAGtJ,IAAI,CAACsJ,QAApB;;MACA,IAAIA,QAAQ,IAAIA,QAAQ,CAAC9M,IAAT,KAAkB0M,KAAK,CAAC1M,IAAxC,EAA8C;QAC1CjE,MAAM,CAAC2G,IAAP,CAAYtC,YAAY,KAAK,IAAjB,GAAwBA,YAAY,EAApC,GAAyCiE,kBAAkB,CAACyI,QAAD,CAAvE;MACH;;MACD,OAAO/Q,MAAP;IACH,CA5hBsB;IA8hBvB+L,OAAO,EAAE,UAAUtE,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MACxC,IAAI5C,GAAJ;;MACA,IAAI8H,IAAI,CAACvL,cAAL,CAAoB,KAApB,KAA8BX,KAA9B,IAAuCD,KAAK,CAACqE,GAAjD,EAAsD;QAClD,IAAI;UACAA,GAAG,GAAGpE,KAAK,CAACkM,IAAI,CAAC9H,GAAN,CAAL,CAAgBkH,IAAhB,CAAqB,CAArB,EAAwB+C,UAA9B;;UACA,IAAIjK,GAAG,CAACxD,IAAJ,KAAahC,MAAM,CAAC4R,OAAxB,EAAiC;YAC7B,IAAIpM,GAAG,CAACwB,KAAJ,KAAcsG,IAAI,CAACtG,KAAvB,EAA8B;cAC1B,OAAOsG,IAAI,CAAC9H,GAAZ;YACH;UACJ;QACJ,CAPD,CAOE,OAAOqR,CAAP,EAAU,CACR;QACH;MACJ;;MAED,IAAIvJ,IAAI,CAACwJ,KAAT,EAAgB;QACd,OAAO,MAAMxJ,IAAI,CAACwJ,KAAL,CAAWC,OAAjB,GAA2B,GAA3B,GAAiCzJ,IAAI,CAACwJ,KAAL,CAAW1O,KAAnD;MACD;;MAED,IAAIkF,IAAI,CAACtG,KAAL,KAAe,IAAnB,EAAyB;QACrB,OAAO,MAAP;MACH;;MAED,IAAI,OAAOsG,IAAI,CAACtG,KAAZ,KAAsB,QAA1B,EAAoC;QAChC,OAAOiC,YAAY,CAACqE,IAAI,CAACtG,KAAN,CAAnB;MACH;;MAED,IAAI,OAAOsG,IAAI,CAACtG,KAAZ,KAAsB,QAA1B,EAAoC;QAChC,OAAOD,cAAc,CAACuG,IAAI,CAACtG,KAAN,CAArB;MACH;;MAED,IAAI,OAAOsG,IAAI,CAACtG,KAAZ,KAAsB,SAA1B,EAAqC;QACjC,OAAOsG,IAAI,CAACtG,KAAL,GAAa,MAAb,GAAsB,OAA7B;MACH;;MAED,OAAOiB,cAAc,CAACqF,IAAI,CAACtG,KAAN,CAArB;IACH,CAlkBsB;IAokBvBgQ,mBAAmB,EAAE,UAAU1J,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MACpD,OAAO,KAAK6O,uBAAL,CAA6B3J,IAA7B,EAAmCC,UAAnC,EAA+CnF,KAA/C,CAAP;IACH,CAtkBsB;IAwkBvB6O,uBAAuB,EAAE,UAAU3J,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MACxD;MACA;MAEA,IAAIvC,MAAJ;MAAA,IAAYwC,CAAZ;MAAA,IAAeC,EAAf;MAAA,IAAmBuD,QAAnB;MAAA,IAA6BgC,IAAI,GAAG,IAApC;MACAhI,MAAM,GAAIyH,IAAI,CAACtL,IAAL,KAAchC,MAAM,CAACgX,mBAAtB,GAA6C,CAAC,GAAD,CAA7C,GAAqD,CAAC,GAAD,CAA9D;;MAEA,IAAI7V,KAAK,CAACgE,GAAN,CAAUC,2CAAd,EAA2D;QACvDyG,QAAQ,GAAG,KAAKmD,kBAAL,CAAwB1B,IAAI,CAACZ,IAA7B,EAAmCzM,UAAU,CAACoC,UAA9C,EAA0D+B,KAA1D,CAAX;QACAyB,MAAM,CAAC2G,IAAP,CAAYX,QAAZ;MACH;;MAED,IAAIyB,IAAI,CAAC4J,MAAT,EAAiB;QACbrM,UAAU,CAAC,YAAY;UACnB,KAAKxC,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGgF,IAAI,CAAC4J,MAAL,CAAYhR,MAA7B,EAAqCmC,CAAC,GAAGC,EAAzC,EAA6C,EAAED,CAA/C,EAAkD;YAC9CwD,QAAQ,GAAGgC,IAAI,CAACmB,kBAAL,CAAwB1B,IAAI,CAAC4J,MAAL,CAAY7O,CAAZ,CAAxB,EAAwCpI,UAAU,CAACkC,QAAnD,EAA6DiC,KAA7D,CAAX;;YACA,IAAIiE,CAAC,GAAG,CAAJ,IAASlH,KAAK,CAACgE,GAAN,CAAUC,2CAAvB,EAAoE;cAChES,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAASgG,QAAT,CAAb;YACH,CAFD,MAEO;cACHhG,MAAM,CAAC2G,IAAP,CAAYX,QAAZ;YACH;UACJ;QACJ,CATS,CAAV;MAUH;;MAED,IAAIyB,IAAI,CAAC6J,MAAT,EAAiB;QACbtR,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,OAAO/E,KAAhB,CAAb;QACA+K,QAAQ,GAAG,KAAKmD,kBAAL,CAAwB1B,IAAI,CAAC6J,MAA7B,EAAqClX,UAAU,CAACkC,QAAhD,EAA0DiC,KAA1D,CAAX;QACAyB,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAAS,CAAE,GAAF,EAAOgG,QAAP,EAAiB,GAAjB,CAAT,CAAb;MACH;;MAED,IAAI,CAAC1K,KAAK,CAACgE,GAAN,CAAUC,2CAAf,EAA4D;QACxDyG,QAAQ,GAAG,KAAKmD,kBAAL,CAAwB1B,IAAI,CAACZ,IAA7B,EAAmCzM,UAAU,CAACoC,UAA9C,EAA0D+B,KAA1D,CAAX;QAEAyB,MAAM,GAAGsE,IAAI,CAACtE,MAAD,EAASgG,QAAT,CAAb;MACH;;MAEDhG,MAAM,CAAC2G,IAAP,CAAac,IAAI,CAACtL,IAAL,KAAchC,MAAM,CAACgX,mBAAtB,GAA6C,GAA7C,GAAmD,GAA/D;MACA,OAAOnR,MAAP;IACH,CA/mBsB;IAinBvBuR,kBAAkB,EAAE,UAAU9J,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MACnD,IAAIyD,QAAJ;;MACA,IAAIyB,IAAI,CAAClD,IAAL,CAAUpI,IAAV,KAAmBhC,MAAM,CAAC8P,mBAA9B,EAAmD;QAC/CjE,QAAQ,GAAG,CACPyB,IAAI,CAAClD,IAAL,CAAU2F,IADH,EACS7F,YAAY,EADrB,EAEP,KAAK6D,iBAAL,CAAuBT,IAAI,CAAClD,IAAL,CAAU4F,YAAV,CAAuB,CAAvB,CAAvB,EAAkDtL,MAAlD,CAFO,CAAX;MAIH,CALD,MAKO;QACHmH,QAAQ,GAAG,KAAKmD,kBAAL,CAAwB1B,IAAI,CAAClD,IAA7B,EAAmCnK,UAAU,CAACsD,IAA9C,EAAoDa,KAApD,CAAX;MACH;;MAEDyH,QAAQ,GAAG1B,IAAI,CAAC0B,QAAD,EAAWyB,IAAI,CAAC+J,EAAL,GAAU,IAAV,GAAiB,IAA5B,CAAf;MACAxL,QAAQ,GAAG1B,IAAI,CAAC0B,QAAD,EAAW,KAAKmD,kBAAL,CAAwB1B,IAAI,CAACjD,KAA7B,EAAoCpK,UAAU,CAACkC,QAA/C,EAAyDiC,KAAzD,CAAX,CAAf;MAEA,OAAO,CAAE,QAAQtD,KAAR,GAAgB,GAAlB,EAAuB+K,QAAvB,EAAiC,GAAjC,CAAP;IACH,CAhoBsB;IAkoBvByL,aAAa,EAAE,UAAUhK,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MAC9C,OAAO,CACH,KADG,EAEH,KAAK4G,kBAAL,CAAwB1B,IAAI,CAACgF,QAA7B,EAAuCrS,UAAU,CAACoC,UAAlD,EAA8D+B,KAA9D,CAFG,CAAP;IAIH,CAvoBsB;IAyoBvBmT,wBAAwB,EAAE,UAAUjK,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MACzD,IAAI8J,SAAS,GAAG/N,KAAhB;;MACA,IAAI,EAAEiE,KAAK,GAAGvE,YAAV,CAAJ,EAA6B;QACzBqO,SAAS,GAAG7N,KAAZ;MACH;;MACD,IAAIwB,MAAM,GAAG,CACT,KAAKmJ,kBAAL,CAAwB1B,IAAI,CAACkK,GAA7B,EAAkCvX,UAAU,CAACsD,IAA7C,EAAmD2O,SAAnD,CADS,EAET,KAAKlD,kBAAL,CAAwB1B,IAAI,CAACmK,KAA7B,EAAoCxX,UAAU,CAAC0D,OAA/C,EAAwDW,KAAxD,CAFS,CAAb;MAIA,OAAOyI,YAAY,CAAClH,MAAD,EAAS5F,UAAU,CAACwD,cAApB,EAAoC8J,UAApC,CAAnB;IACH,CAnpBsB;IAqpBvBmK,eAAe,EAAE,UAAUpK,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MAChD;MACA;MACA,OAAOkF,IAAI,CAACtG,KAAL,CAAWxB,GAAlB;IACH,CAzpBsB;IA2pBvBmS,eAAe,EAAE,UAAUrK,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MAChD,IAAIvC,MAAJ,EAAYwC,CAAZ,EAAeC,EAAf;MACAzC,MAAM,GAAG,CAAE,GAAF,CAAT;;MACA,KAAKwC,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGgF,IAAI,CAACsK,MAAL,CAAY1R,MAA7B,EAAqCmC,CAAC,GAAGC,EAAzC,EAA6C,EAAED,CAA/C,EAAkD;QAC9CxC,MAAM,CAAC2G,IAAP,CAAY,KAAKwC,kBAAL,CAAwB1B,IAAI,CAACsK,MAAL,CAAYvP,CAAZ,CAAxB,EAAwCpI,UAAU,CAAC0D,OAAnD,EAA4DS,KAA5D,CAAZ;;QACA,IAAIiE,CAAC,GAAG,CAAJ,GAAQC,EAAZ,EAAgB;UACZzC,MAAM,CAAC2G,IAAP,CAAY,OAAO1L,KAAnB;UACA+E,MAAM,CAAC2G,IAAP,CAAY,KAAKwC,kBAAL,CAAwB1B,IAAI,CAACyG,WAAL,CAAiB1L,CAAjB,CAAxB,EAA6CpI,UAAU,CAACkC,QAAxD,EAAkEiC,KAAlE,CAAZ;UACAyB,MAAM,CAAC2G,IAAP,CAAY1L,KAAK,GAAG,GAApB;QACH;MACJ;;MACD+E,MAAM,CAAC2G,IAAP,CAAY,GAAZ;MACA,OAAO3G,MAAP;IACH,CAxqBsB;IA0qBvBgS,eAAe,EAAE,UAAUvK,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;MAChD,OAAO,KAAKwJ,OAAL,CAAatE,IAAb,EAAmBC,UAAnB,EAA+BnF,KAA/B,CAAP;IACH,CA5qBsB;IA8qBvB0P,gBAAgB,EAAE,UAASxK,IAAT,EAAeC,UAAf,EAA2BwK,IAA3B,EAAiC;MAC/C,OAAOhL,YAAY,CAAC,CAChB,SADgB,EAEhB,KAAKiC,kBAAL,CAAwB1B,IAAI,CAAC9E,MAA7B,EAAqCvI,UAAU,CAACoC,UAAhD,EAA4D+B,KAA5D,CAFgB,EAGhB,GAHgB,CAAD,EAIhBnE,UAAU,CAACsD,IAJK,EAICgK,UAJD,CAAnB;IAKH;EAprBsB,CAA3B;EAurBAjH,KAAK,CAACzE,aAAa,CAAC6L,SAAf,EAA0B7L,aAAa,CAACC,UAAxC,CAAL;;EAEAD,aAAa,CAAC6L,SAAd,CAAwBsB,kBAAxB,GAA6C,UAAU1B,IAAV,EAAgBC,UAAhB,EAA4BnF,KAA5B,EAAmC;IAC5E,IAAIvC,MAAJ,EAAY7D,IAAZ;IAEAA,IAAI,GAAGsL,IAAI,CAACtL,IAAL,IAAahC,MAAM,CAAC+V,QAA3B;;IAEA,IAAI5U,KAAK,CAACsE,QAAN,IAAkB6H,IAAI,CAACvL,cAAL,CAAoBZ,KAAK,CAACsE,QAA1B,CAAtB,EAA2D;MACvD,OAAO4H,gBAAgB,CAACC,IAAD,EAAOC,UAAP,CAAvB;IACH;;IAED1H,MAAM,GAAG,KAAK7D,IAAL,EAAWsL,IAAX,EAAiBC,UAAjB,EAA6BnF,KAA7B,CAAT;;IAGA,IAAIjH,KAAK,CAAC2D,OAAV,EAAmB;MACfe,MAAM,GAAG6F,WAAW,CAAC4B,IAAD,EAAOzH,MAAP,CAApB;IACH;;IACD,OAAO8D,sBAAsB,CAAC9D,MAAD,EAASyH,IAAT,CAA7B;EACH,CAhBD;;EAkBAzL,aAAa,CAAC6L,SAAd,CAAwBK,iBAAxB,GAA4C,UAAUnD,IAAV,EAAgBxC,KAAhB,EAAuB;IAC/D,IAAIvC,MAAJ,EACIgG,QADJ;IAGAhG,MAAM,GAAG,KAAK+E,IAAI,CAAC5I,IAAV,EAAgB4I,IAAhB,EAAsBxC,KAAtB,CAAT,CAJ+D,CAM/D;;IAEA,IAAIjH,KAAK,CAAC2D,OAAV,EAAmB;MACfe,MAAM,GAAG6F,WAAW,CAACd,IAAD,EAAO/E,MAAP,CAApB;IACH;;IAEDgG,QAAQ,GAAGlC,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+B8B,QAA/B,EAAX;;IACA,IAAIiD,IAAI,CAAC5I,IAAL,KAAchC,MAAM,CAACyM,OAArB,IAAgC,CAACxL,iBAAjC,IAAsDJ,OAAO,KAAK,EAAlE,IAAyEgL,QAAQ,CAAC6D,MAAT,CAAgB7D,QAAQ,CAAC3F,MAAT,GAAkB,CAAlC,MAAyC,IAAtH,EAA4H;MACxHL,MAAM,GAAGxE,SAAS,GAAGsI,sBAAsB,CAAC9D,MAAD,CAAtB,CAA+BmS,YAA/B,CAA4C,MAA5C,EAAoD,EAApD,CAAH,GAA6DnM,QAAQ,CAACrE,OAAT,CAAiB,MAAjB,EAAyB,EAAzB,CAA/E;IACH;;IAED,OAAOmC,sBAAsB,CAAC9D,MAAD,EAAS+E,IAAT,CAA7B;EACH,CAlBD;;EAoBA,SAASqN,gBAAT,CAA0BrW,IAA1B,EAAgC;IAC5B,IAAIsW,OAAJ;IAEAA,OAAO,GAAG,IAAIrW,aAAJ,EAAV;;IACA,IAAII,WAAW,CAACL,IAAD,CAAf,EAAuB;MACnB,OAAOsW,OAAO,CAACnK,iBAAR,CAA0BnM,IAA1B,EAAgC4C,MAAhC,CAAP;IACH;;IAED,IAAI7C,YAAY,CAACC,IAAD,CAAhB,EAAwB;MACpB,OAAOsW,OAAO,CAAClJ,kBAAR,CAA2BpN,IAA3B,EAAiC3B,UAAU,CAACkC,QAA5C,EAAsDiC,KAAtD,CAAP;IACH;;IAED,MAAM,IAAIiD,KAAJ,CAAU,wBAAwBzF,IAAI,CAACI,IAAvC,CAAN;EACH;;EAED,SAASmW,QAAT,CAAkBvW,IAAlB,EAAwBwW,OAAxB,EAAiC;IAC7B,IAAIC,cAAc,GAAGxT,iBAAiB,EAAtC;IAAA,IAA0CgB,MAA1C;IAAA,IAAkDyS,IAAlD;;IAEA,IAAIF,OAAO,IAAI,IAAf,EAAqB;MACjB;MACA;MACA;MACA;MACA;MACA;MACA,IAAI,OAAOA,OAAO,CAAC7X,MAAf,KAA0B,QAA9B,EAAwC;QACpC8X,cAAc,CAACtT,MAAf,CAAsBxE,MAAtB,CAA6ByE,KAA7B,GAAqCoT,OAAO,CAAC7X,MAA7C;MACH;;MACD,IAAI,OAAO6X,OAAO,CAAC9X,IAAf,KAAwB,QAA5B,EAAsC;QAClC+X,cAAc,CAACtT,MAAf,CAAsBxE,MAAtB,CAA6BD,IAA7B,GAAoC8X,OAAO,CAAC9X,IAA5C;MACH;;MACD8X,OAAO,GAAG1R,YAAY,CAAC2R,cAAD,EAAiBD,OAAjB,CAAtB;MACA7X,MAAM,GAAG6X,OAAO,CAACrT,MAAR,CAAexE,MAAf,CAAsByE,KAA/B;;MACA,IAAI,OAAOoT,OAAO,CAAC9X,IAAf,KAAwB,QAA5B,EAAsC;QAClCA,IAAI,GAAG8X,OAAO,CAAC9X,IAAf;MACH,CAFD,MAEO;QACHA,IAAI,GAAGoF,YAAY,CAACnF,MAAD,EAAS6X,OAAO,CAACrT,MAAR,CAAexE,MAAf,CAAsBD,IAA/B,CAAnB;MACH;IACJ,CApBD,MAoBO;MACH8X,OAAO,GAAGC,cAAV;MACA9X,MAAM,GAAG6X,OAAO,CAACrT,MAAR,CAAexE,MAAf,CAAsByE,KAA/B;MACA1E,IAAI,GAAGoF,YAAY,CAACnF,MAAD,EAAS6X,OAAO,CAACrT,MAAR,CAAexE,MAAf,CAAsBD,IAA/B,CAAnB;IACH;;IACDE,IAAI,GAAG4X,OAAO,CAACrT,MAAR,CAAevE,IAAtB;IACAC,QAAQ,GAAG2X,OAAO,CAACrT,MAAR,CAAetE,QAA1B;IACAC,WAAW,GAAGF,IAAI,GAAG,KAAH,GAAW4X,OAAO,CAACrT,MAAR,CAAerE,WAA5C;IACAC,MAAM,GAAGH,IAAI,GAAG,QAAH,GAAc4X,OAAO,CAACrT,MAAR,CAAepE,MAA1C;IACAC,UAAU,GAAGwX,OAAO,CAACrT,MAAR,CAAenE,UAA5B;IACAC,OAAO,GAAGuX,OAAO,CAACrT,MAAR,CAAelE,OAAzB;IACAC,KAAK,GAAGsX,OAAO,CAACrT,MAAR,CAAejE,KAAvB;;IACA,IAAIsX,OAAO,CAACrT,MAAR,CAAeG,OAAnB,EAA4B;MACxBrE,OAAO,GAAGC,KAAK,GAAGP,MAAM,GAAGD,IAAI,GAAG,EAAlC;IACH;;IACDS,WAAW,GAAGqX,OAAO,CAACrT,MAAR,CAAehE,WAA7B;IACAC,UAAU,GAAGoX,OAAO,CAACrT,MAAR,CAAe/D,UAA5B;IACAC,iBAAiB,GAAGmX,OAAO,CAACrT,MAAR,CAAe9D,iBAAnC;IACAC,SAAS,GAAGkX,OAAO,CAAClX,SAApB;IACAE,KAAK,GAAGZ,IAAI,GAAG,IAAH,GAAU4X,OAAO,CAAChX,KAA9B;IACAC,SAAS,GAAG+W,OAAO,CAAC/W,SAApB;IACAC,UAAU,GAAG8W,OAAO,CAAC9W,UAArB;IACAC,kBAAkB,GAAG6W,OAAO,CAACrT,MAAR,CAAexD,kBAAf,IAAqCD,UAAU,KAAK,IAAzE;IACAH,KAAK,GAAGiX,OAAR;;IAEA,IAAI/W,SAAJ,EAAe;MACX,IAAI,CAACkX,OAAO,CAACC,OAAb,EAAsB;QAClB;QACA;QACArY,UAAU,GAAGuB,OAAO,CAAC,YAAD,CAAP,CAAsBvB,UAAnC;MACH,CAJD,MAIO;QACHA,UAAU,GAAGsY,MAAM,CAACpX,SAAP,CAAiBlB,UAA9B;MACH;IACJ;;IAED0F,MAAM,GAAGoS,gBAAgB,CAACrW,IAAD,CAAzB;;IAEA,IAAI,CAACP,SAAL,EAAgB;MACZiX,IAAI,GAAG;QAACnS,IAAI,EAAEN,MAAM,CAAC8B,QAAP,EAAP;QAA0B+Q,GAAG,EAAE;MAA/B,CAAP;MACA,OAAON,OAAO,CAAC7S,iBAAR,GAA4B+S,IAA5B,GAAmCA,IAAI,CAACnS,IAA/C;IACH;;IAGDmS,IAAI,GAAGzS,MAAM,CAAC8S,qBAAP,CAA6B;MAChCC,IAAI,EAAER,OAAO,CAACQ,IADkB;MAEhCC,UAAU,EAAET,OAAO,CAAC9S;IAFY,CAA7B,CAAP;;IAKA,IAAI8S,OAAO,CAACU,aAAZ,EAA2B;MACvBR,IAAI,CAACI,GAAL,CAASK,gBAAT,CAA0BX,OAAO,CAAC/W,SAAlC,EAC0B+W,OAAO,CAACU,aADlC;IAEH;;IAED,IAAIV,OAAO,CAAC7S,iBAAZ,EAA+B;MAC3B,OAAO+S,IAAP;IACH;;IAED,OAAOA,IAAI,CAACI,GAAL,CAAS/Q,QAAT,EAAP;EACH;;EAEDnG,aAAa,GAAG;IACZjB,MAAM,EAAE;MACJyE,KAAK,EAAE,EADH;MAEJ1E,IAAI,EAAE;IAFF,CADI;IAKZG,QAAQ,EAAE,IALE;IAMZC,WAAW,EAAE,IAND;IAOZC,MAAM,EAAE,MAPI;IAQZC,UAAU,EAAE,IARA;IASZsE,OAAO,EAAE,IATG;IAUZnE,WAAW,EAAE,KAVD;IAWZC,UAAU,EAAE;EAXA,CAAhB;EAcAS,eAAe,GAAGoD,iBAAiB,GAAGE,MAAtC;EAEAwT,OAAO,CAACS,OAAR,GAAkBtX,OAAO,CAAC,gBAAD,CAAP,CAA0BsX,OAA5C;EACAT,OAAO,CAACJ,QAAR,GAAmBA,QAAnB;EACAI,OAAO,CAACU,cAAR,GAAyB7Y,UAAU,CAAC6Y,cAApC;EACAV,OAAO,CAACtY,UAAR,GAAqByG,YAAY,CAAC,EAAD,EAAKzG,UAAL,CAAjC;EACAsY,OAAO,CAACC,OAAR,GAAkB,KAAlB;EACAD,OAAO,CAAC/W,aAAR,GAAwBA,aAAxB;EACA+W,OAAO,CAAC9W,eAAR,GAA0BA,eAA1B;AACH,CAjjFA,GAAD;AAkjFA"},"metadata":{},"sourceType":"script"}