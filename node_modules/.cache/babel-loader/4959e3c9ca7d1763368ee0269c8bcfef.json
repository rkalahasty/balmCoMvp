{"ast":null,"code":"\"use strict\";\n\nconst {\n  addNwsapi\n} = require(\"../helpers/selectors\");\n\nconst {\n  HTML_NS\n} = require(\"../helpers/namespaces\");\n\nconst {\n  mixin,\n  memoizeQuery\n} = require(\"../../utils\");\n\nconst idlUtils = require(\"../generated/utils\");\n\nconst NodeImpl = require(\"./Node-impl\").implementation;\n\nconst ParentNodeImpl = require(\"./ParentNode-impl\").implementation;\n\nconst ChildNodeImpl = require(\"./ChildNode-impl\").implementation;\n\nconst attributes = require(\"../attributes\");\n\nconst namedPropertiesWindow = require(\"../named-properties-window\");\n\nconst NODE_TYPE = require(\"../node-type\");\n\nconst {\n  parseFragment\n} = require(\"../../browser/parser\");\n\nconst InnerHTMLImpl = require(\"../domparsing/InnerHTML-impl\").implementation;\n\nconst {\n  fragmentSerialization\n} = require(\"../domparsing/serialization\");\n\nconst {\n  domSymbolTree\n} = require(\"../helpers/internal-constants\");\n\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\n\nconst DOMTokenList = require(\"../generated/DOMTokenList\");\n\nconst NamedNodeMap = require(\"../generated/NamedNodeMap\");\n\nconst validateNames = require(\"../helpers/validate-names\");\n\nconst {\n  asciiLowercase,\n  asciiUppercase\n} = require(\"../helpers/strings\");\n\nconst {\n  listOfElementsWithQualifiedName,\n  listOfElementsWithNamespaceAndLocalName,\n  listOfElementsWithClassNames\n} = require(\"../node\");\n\nconst SlotableMixinImpl = require(\"./Slotable-impl\").implementation;\n\nconst NonDocumentTypeChildNode = require(\"./NonDocumentTypeChildNode-impl\").implementation;\n\nconst ShadowRoot = require(\"../generated/ShadowRoot\");\n\nconst Text = require(\"../generated/Text\");\n\nconst {\n  isValidHostElementName\n} = require(\"../helpers/shadow-dom\");\n\nconst {\n  isValidCustomElementName,\n  lookupCEDefinition\n} = require(\"../helpers/custom-elements\");\n\nfunction attachId(id, elm, doc) {\n  if (id && elm && doc) {\n    if (!doc._ids[id]) {\n      doc._ids[id] = [];\n    }\n\n    doc._ids[id].push(elm);\n  }\n}\n\nfunction detachId(id, elm, doc) {\n  if (id && elm && doc) {\n    if (doc._ids && doc._ids[id]) {\n      const elms = doc._ids[id];\n\n      for (let i = 0; i < elms.length; i++) {\n        if (elms[i] === elm) {\n          elms.splice(i, 1);\n          --i;\n        }\n      }\n\n      if (elms.length === 0) {\n        delete doc._ids[id];\n      }\n    }\n  }\n}\n\nclass ElementImpl extends NodeImpl {\n  constructor(globalObject, args, privateData) {\n    super(globalObject, args, privateData);\n\n    this._initSlotableMixin();\n\n    this._namespaceURI = privateData.namespace;\n    this._prefix = privateData.prefix;\n    this._localName = privateData.localName;\n    this._ceState = privateData.ceState;\n    this._ceDefinition = privateData.ceDefinition;\n    this._isValue = privateData.isValue;\n    this._shadowRoot = null;\n    this._ceReactionQueue = [];\n    this.nodeType = NODE_TYPE.ELEMENT_NODE;\n    this.scrollTop = 0;\n    this.scrollLeft = 0;\n    this._attributeList = []; // Used for caching.\n\n    this._attributesByNameMap = new Map();\n    this._attributes = NamedNodeMap.createImpl(this._globalObject, [], {\n      element: this\n    });\n    this._cachedTagName = null;\n  }\n\n  _attach() {\n    namedPropertiesWindow.nodeAttachedToDocument(this);\n    const id = this.getAttributeNS(null, \"id\");\n\n    if (id) {\n      attachId(id, this, this._ownerDocument);\n    }\n\n    super._attach();\n  }\n\n  _detach() {\n    super._detach();\n\n    namedPropertiesWindow.nodeDetachedFromDocument(this);\n    const id = this.getAttributeNS(null, \"id\");\n\n    if (id) {\n      detachId(id, this, this._ownerDocument);\n    }\n  }\n\n  _attrModified(name, value, oldValue) {\n    this._modified();\n\n    namedPropertiesWindow.elementAttributeModified(this, name, value, oldValue);\n\n    if (name === \"id\" && this._attached) {\n      const doc = this._ownerDocument;\n      detachId(oldValue, this, doc);\n      attachId(value, this, doc);\n    } // update classList\n\n\n    if (name === \"class\" && this._classList !== undefined) {\n      this._classList.attrModified();\n    }\n\n    this._attrModifiedSlotableMixin(name, value, oldValue);\n  }\n\n  get namespaceURI() {\n    return this._namespaceURI;\n  }\n\n  get prefix() {\n    return this._prefix;\n  }\n\n  get localName() {\n    return this._localName;\n  }\n\n  get _qualifiedName() {\n    return this._prefix !== null ? this._prefix + \":\" + this._localName : this._localName;\n  }\n\n  get tagName() {\n    // This getter can be a hotpath in getComputedStyle.\n    // All these are invariants during the instance lifetime so we can safely cache the computed tagName.\n    // We could create it during construction but since we already identified this as potentially slow we do it lazily.\n    if (this._cachedTagName === null) {\n      if (this.namespaceURI === HTML_NS && this._ownerDocument._parsingMode === \"html\") {\n        this._cachedTagName = asciiUppercase(this._qualifiedName);\n      } else {\n        this._cachedTagName = this._qualifiedName;\n      }\n    }\n\n    return this._cachedTagName;\n  }\n\n  get attributes() {\n    return this._attributes;\n  } // https://w3c.github.io/DOM-Parsing/#dom-element-outerhtml\n\n\n  get outerHTML() {\n    // TODO: maybe parse5 can give us a hook where it serializes the node itself too:\n    // https://github.com/inikulin/parse5/issues/230\n    // Alternatively, if we can create a virtual node in domSymbolTree, that'd also work.\n    // It's currently prevented by the fact that a node can't be duplicated in the same tree.\n    // Then we could get rid of all the code for childNodesForSerializing.\n    return fragmentSerialization({\n      childNodesForSerializing: [this],\n      _ownerDocument: this._ownerDocument\n    }, {\n      requireWellFormed: true,\n      globalObject: this._globalObject\n    });\n  }\n\n  set outerHTML(markup) {\n    let parent = domSymbolTree.parent(this);\n    const document = this._ownerDocument;\n\n    if (!parent) {\n      return;\n    }\n\n    if (parent.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n      throw DOMException.create(this._globalObject, [\"Modifications are not allowed for this document\", \"NoModificationAllowedError\"]);\n    }\n\n    if (parent.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      parent = document.createElementNS(HTML_NS, \"body\");\n    }\n\n    const fragment = parseFragment(markup, parent);\n    const contextObjectParent = domSymbolTree.parent(this);\n\n    contextObjectParent._replace(fragment, this);\n  }\n\n  get classList() {\n    if (this._classList === undefined) {\n      this._classList = DOMTokenList.createImpl(this._globalObject, [], {\n        element: this,\n        attributeLocalName: \"class\"\n      });\n    }\n\n    return this._classList;\n  }\n\n  hasAttributes() {\n    return attributes.hasAttributes(this);\n  }\n\n  getAttributeNames() {\n    return attributes.attributeNames(this);\n  }\n\n  getAttribute(name) {\n    const attr = attributes.getAttributeByName(this, name);\n\n    if (!attr) {\n      return null;\n    }\n\n    return attr._value;\n  }\n\n  getAttributeNS(namespace, localName) {\n    const attr = attributes.getAttributeByNameNS(this, namespace, localName);\n\n    if (!attr) {\n      return null;\n    }\n\n    return attr._value;\n  }\n\n  setAttribute(name, value) {\n    validateNames.name(this._globalObject, name);\n\n    if (this._namespaceURI === HTML_NS && this._ownerDocument._parsingMode === \"html\") {\n      name = asciiLowercase(name);\n    }\n\n    const attribute = attributes.getAttributeByName(this, name);\n\n    if (attribute === null) {\n      const newAttr = this._ownerDocument._createAttribute({\n        localName: name,\n        value\n      });\n\n      attributes.appendAttribute(this, newAttr);\n      return;\n    }\n\n    attributes.changeAttribute(this, attribute, value);\n  }\n\n  setAttributeNS(namespace, name, value) {\n    const extracted = validateNames.validateAndExtract(this._globalObject, namespace, name); // Because of widespread use of this method internally, e.g. to manually implement attribute/content reflection, we\n    // centralize the conversion to a string here, so that all call sites don't have to do it.\n\n    value = `${value}`;\n    attributes.setAttributeValue(this, extracted.localName, value, extracted.prefix, extracted.namespace);\n  }\n\n  removeAttribute(name) {\n    attributes.removeAttributeByName(this, name);\n  }\n\n  removeAttributeNS(namespace, localName) {\n    attributes.removeAttributeByNameNS(this, namespace, localName);\n  }\n\n  toggleAttribute(qualifiedName, force) {\n    validateNames.name(this._globalObject, qualifiedName);\n\n    if (this._namespaceURI === HTML_NS && this._ownerDocument._parsingMode === \"html\") {\n      qualifiedName = asciiLowercase(qualifiedName);\n    }\n\n    const attribute = attributes.getAttributeByName(this, qualifiedName);\n\n    if (attribute === null) {\n      if (force === undefined || force === true) {\n        const newAttr = this._ownerDocument._createAttribute({\n          localName: qualifiedName,\n          value: \"\"\n        });\n\n        attributes.appendAttribute(this, newAttr);\n        return true;\n      }\n\n      return false;\n    }\n\n    if (force === undefined || force === false) {\n      attributes.removeAttributeByName(this, qualifiedName);\n      return false;\n    }\n\n    return true;\n  }\n\n  hasAttribute(name) {\n    if (this._namespaceURI === HTML_NS && this._ownerDocument._parsingMode === \"html\") {\n      name = asciiLowercase(name);\n    }\n\n    return attributes.hasAttributeByName(this, name);\n  }\n\n  hasAttributeNS(namespace, localName) {\n    if (namespace === \"\") {\n      namespace = null;\n    }\n\n    return attributes.hasAttributeByNameNS(this, namespace, localName);\n  }\n\n  getAttributeNode(name) {\n    return attributes.getAttributeByName(this, name);\n  }\n\n  getAttributeNodeNS(namespace, localName) {\n    return attributes.getAttributeByNameNS(this, namespace, localName);\n  }\n\n  setAttributeNode(attr) {\n    // eslint-disable-next-line no-restricted-properties\n    return attributes.setAttribute(this, attr);\n  }\n\n  setAttributeNodeNS(attr) {\n    // eslint-disable-next-line no-restricted-properties\n    return attributes.setAttribute(this, attr);\n  }\n\n  removeAttributeNode(attr) {\n    // eslint-disable-next-line no-restricted-properties\n    if (!attributes.hasAttribute(this, attr)) {\n      throw DOMException.create(this._globalObject, [\"Tried to remove an attribute that was not present\", \"NotFoundError\"]);\n    } // eslint-disable-next-line no-restricted-properties\n\n\n    attributes.removeAttribute(this, attr);\n    return attr;\n  }\n\n  getBoundingClientRect() {\n    return {\n      x: 0,\n      y: 0,\n      bottom: 0,\n      height: 0,\n      left: 0,\n      right: 0,\n      top: 0,\n      width: 0\n    };\n  }\n\n  getClientRects() {\n    return [];\n  }\n\n  get scrollWidth() {\n    return 0;\n  }\n\n  get scrollHeight() {\n    return 0;\n  }\n\n  get clientTop() {\n    return 0;\n  }\n\n  get clientLeft() {\n    return 0;\n  }\n\n  get clientWidth() {\n    return 0;\n  }\n\n  get clientHeight() {\n    return 0;\n  } // https://dom.spec.whatwg.org/#dom-element-attachshadow\n\n\n  attachShadow(init) {\n    const {\n      _ownerDocument,\n      _namespaceURI,\n      _localName,\n      _isValue\n    } = this;\n\n    if (this.namespaceURI !== HTML_NS) {\n      throw DOMException.create(this._globalObject, [\"This element does not support attachShadow. This element is not part of the HTML namespace.\", \"NotSupportedError\"]);\n    }\n\n    if (!isValidHostElementName(_localName) && !isValidCustomElementName(_localName)) {\n      const message = \"This element does not support attachShadow. This element is not a custom element nor \" + \"a standard element supporting a shadow root.\";\n      throw DOMException.create(this._globalObject, [message, \"NotSupportedError\"]);\n    }\n\n    if (isValidCustomElementName(_localName) || _isValue) {\n      const definition = lookupCEDefinition(_ownerDocument, _namespaceURI, _localName, _isValue);\n\n      if (definition && definition.disableShadow) {\n        throw DOMException.create(this._globalObject, [\"Shadow root cannot be create on a custom element with disabled shadow\", \"NotSupportedError\"]);\n      }\n    }\n\n    if (this._shadowRoot !== null) {\n      throw DOMException.create(this._globalObject, [\"Shadow root cannot be created on a host which already hosts a shadow tree.\", \"NotSupportedError\"]);\n    }\n\n    const shadow = ShadowRoot.createImpl(this._globalObject, [], {\n      ownerDocument: this.ownerDocument,\n      mode: init.mode,\n      host: this\n    });\n    this._shadowRoot = shadow;\n    return shadow;\n  } // https://dom.spec.whatwg.org/#dom-element-shadowroot\n\n\n  get shadowRoot() {\n    const shadow = this._shadowRoot;\n\n    if (shadow === null || shadow.mode === \"closed\") {\n      return null;\n    }\n\n    return shadow;\n  } // https://dom.spec.whatwg.org/#insert-adjacent\n\n\n  _insertAdjacent(element, where, node) {\n    where = asciiLowercase(where);\n\n    if (where === \"beforebegin\") {\n      if (element.parentNode === null) {\n        return null;\n      }\n\n      return element.parentNode._preInsert(node, element);\n    }\n\n    if (where === \"afterbegin\") {\n      return element._preInsert(node, element.firstChild);\n    }\n\n    if (where === \"beforeend\") {\n      return element._preInsert(node, null);\n    }\n\n    if (where === \"afterend\") {\n      if (element.parentNode === null) {\n        return null;\n      }\n\n      return element.parentNode._preInsert(node, element.nextSibling);\n    }\n\n    throw DOMException.create(this._globalObject, ['Must provide one of \"beforebegin\", \"afterbegin\", \"beforeend\", or \"afterend\".', \"SyntaxError\"]);\n  }\n\n  insertAdjacentElement(where, element) {\n    return this._insertAdjacent(this, where, element);\n  }\n\n  insertAdjacentText(where, data) {\n    const text = Text.createImpl(this._globalObject, [], {\n      data,\n      ownerDocument: this._ownerDocument\n    });\n\n    this._insertAdjacent(this, where, text);\n  } // https://w3c.github.io/DOM-Parsing/#dom-element-insertadjacenthtml\n\n\n  insertAdjacentHTML(position, text) {\n    position = asciiLowercase(position);\n    let context;\n\n    switch (position) {\n      case \"beforebegin\":\n      case \"afterend\":\n        {\n          context = this.parentNode;\n\n          if (context === null || context.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n            throw DOMException.create(this._globalObject, [\"Cannot insert HTML adjacent to parent-less nodes or children of document nodes.\", \"NoModificationAllowedError\"]);\n          }\n\n          break;\n        }\n\n      case \"afterbegin\":\n      case \"beforeend\":\n        {\n          context = this;\n          break;\n        }\n\n      default:\n        {\n          throw DOMException.create(this._globalObject, ['Must provide one of \"beforebegin\", \"afterbegin\", \"beforeend\", or \"afterend\".', \"SyntaxError\"]);\n        }\n    }\n\n    if (context.nodeType !== NODE_TYPE.ELEMENT_NODE || context._ownerDocument._parsingMode === \"html\" && context._localName === \"html\" && context._namespaceURI === HTML_NS) {\n      context = context._ownerDocument.createElement(\"body\");\n    }\n\n    const fragment = parseFragment(text, context);\n\n    switch (position) {\n      case \"beforebegin\":\n        {\n          this.parentNode._insert(fragment, this);\n\n          break;\n        }\n\n      case \"afterbegin\":\n        {\n          this._insert(fragment, this.firstChild);\n\n          break;\n        }\n\n      case \"beforeend\":\n        {\n          this._append(fragment);\n\n          break;\n        }\n\n      case \"afterend\":\n        {\n          this.parentNode._insert(fragment, this.nextSibling);\n\n          break;\n        }\n    }\n  }\n\n  closest(selectors) {\n    const matcher = addNwsapi(this);\n    return matcher.closest(selectors, idlUtils.wrapperForImpl(this));\n  }\n\n}\n\nmixin(ElementImpl.prototype, NonDocumentTypeChildNode.prototype);\nmixin(ElementImpl.prototype, ParentNodeImpl.prototype);\nmixin(ElementImpl.prototype, ChildNodeImpl.prototype);\nmixin(ElementImpl.prototype, SlotableMixinImpl.prototype);\nmixin(ElementImpl.prototype, InnerHTMLImpl.prototype);\nElementImpl.prototype.getElementsByTagName = memoizeQuery(function (qualifiedName) {\n  return listOfElementsWithQualifiedName(qualifiedName, this);\n});\nElementImpl.prototype.getElementsByTagNameNS = memoizeQuery(function (namespace, localName) {\n  return listOfElementsWithNamespaceAndLocalName(namespace, localName, this);\n});\nElementImpl.prototype.getElementsByClassName = memoizeQuery(function (classNames) {\n  return listOfElementsWithClassNames(classNames, this);\n});\n\nElementImpl.prototype.matches = function (selectors) {\n  const matcher = addNwsapi(this);\n  return matcher.match(selectors, idlUtils.wrapperForImpl(this));\n};\n\nElementImpl.prototype.webkitMatchesSelector = ElementImpl.prototype.matches;\nmodule.exports = {\n  implementation: ElementImpl\n};","map":{"version":3,"names":["addNwsapi","require","HTML_NS","mixin","memoizeQuery","idlUtils","NodeImpl","implementation","ParentNodeImpl","ChildNodeImpl","attributes","namedPropertiesWindow","NODE_TYPE","parseFragment","InnerHTMLImpl","fragmentSerialization","domSymbolTree","DOMException","DOMTokenList","NamedNodeMap","validateNames","asciiLowercase","asciiUppercase","listOfElementsWithQualifiedName","listOfElementsWithNamespaceAndLocalName","listOfElementsWithClassNames","SlotableMixinImpl","NonDocumentTypeChildNode","ShadowRoot","Text","isValidHostElementName","isValidCustomElementName","lookupCEDefinition","attachId","id","elm","doc","_ids","push","detachId","elms","i","length","splice","ElementImpl","constructor","globalObject","args","privateData","_initSlotableMixin","_namespaceURI","namespace","_prefix","prefix","_localName","localName","_ceState","ceState","_ceDefinition","ceDefinition","_isValue","isValue","_shadowRoot","_ceReactionQueue","nodeType","ELEMENT_NODE","scrollTop","scrollLeft","_attributeList","_attributesByNameMap","Map","_attributes","createImpl","_globalObject","element","_cachedTagName","_attach","nodeAttachedToDocument","getAttributeNS","_ownerDocument","_detach","nodeDetachedFromDocument","_attrModified","name","value","oldValue","_modified","elementAttributeModified","_attached","_classList","undefined","attrModified","_attrModifiedSlotableMixin","namespaceURI","_qualifiedName","tagName","_parsingMode","outerHTML","childNodesForSerializing","requireWellFormed","markup","parent","document","DOCUMENT_NODE","create","DOCUMENT_FRAGMENT_NODE","createElementNS","fragment","contextObjectParent","_replace","classList","attributeLocalName","hasAttributes","getAttributeNames","attributeNames","getAttribute","attr","getAttributeByName","_value","getAttributeByNameNS","setAttribute","attribute","newAttr","_createAttribute","appendAttribute","changeAttribute","setAttributeNS","extracted","validateAndExtract","setAttributeValue","removeAttribute","removeAttributeByName","removeAttributeNS","removeAttributeByNameNS","toggleAttribute","qualifiedName","force","hasAttribute","hasAttributeByName","hasAttributeNS","hasAttributeByNameNS","getAttributeNode","getAttributeNodeNS","setAttributeNode","setAttributeNodeNS","removeAttributeNode","getBoundingClientRect","x","y","bottom","height","left","right","top","width","getClientRects","scrollWidth","scrollHeight","clientTop","clientLeft","clientWidth","clientHeight","attachShadow","init","message","definition","disableShadow","shadow","ownerDocument","mode","host","shadowRoot","_insertAdjacent","where","node","parentNode","_preInsert","firstChild","nextSibling","insertAdjacentElement","insertAdjacentText","data","text","insertAdjacentHTML","position","context","createElement","_insert","_append","closest","selectors","matcher","wrapperForImpl","prototype","getElementsByTagName","getElementsByTagNameNS","getElementsByClassName","classNames","matches","match","webkitMatchesSelector","module","exports"],"sources":["C:/Users/17033/balmco/node_modules/jsdom/lib/jsdom/living/nodes/Element-impl.js"],"sourcesContent":["\"use strict\";\nconst { addNwsapi } = require(\"../helpers/selectors\");\nconst { HTML_NS } = require(\"../helpers/namespaces\");\nconst { mixin, memoizeQuery } = require(\"../../utils\");\nconst idlUtils = require(\"../generated/utils\");\nconst NodeImpl = require(\"./Node-impl\").implementation;\nconst ParentNodeImpl = require(\"./ParentNode-impl\").implementation;\nconst ChildNodeImpl = require(\"./ChildNode-impl\").implementation;\nconst attributes = require(\"../attributes\");\nconst namedPropertiesWindow = require(\"../named-properties-window\");\nconst NODE_TYPE = require(\"../node-type\");\nconst { parseFragment } = require(\"../../browser/parser\");\nconst InnerHTMLImpl = require(\"../domparsing/InnerHTML-impl\").implementation;\nconst { fragmentSerialization } = require(\"../domparsing/serialization\");\nconst { domSymbolTree } = require(\"../helpers/internal-constants\");\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\nconst DOMTokenList = require(\"../generated/DOMTokenList\");\nconst NamedNodeMap = require(\"../generated/NamedNodeMap\");\nconst validateNames = require(\"../helpers/validate-names\");\nconst { asciiLowercase, asciiUppercase } = require(\"../helpers/strings\");\nconst { listOfElementsWithQualifiedName, listOfElementsWithNamespaceAndLocalName,\n  listOfElementsWithClassNames } = require(\"../node\");\nconst SlotableMixinImpl = require(\"./Slotable-impl\").implementation;\nconst NonDocumentTypeChildNode = require(\"./NonDocumentTypeChildNode-impl\").implementation;\nconst ShadowRoot = require(\"../generated/ShadowRoot\");\nconst Text = require(\"../generated/Text\");\nconst { isValidHostElementName } = require(\"../helpers/shadow-dom\");\nconst { isValidCustomElementName, lookupCEDefinition } = require(\"../helpers/custom-elements\");\n\nfunction attachId(id, elm, doc) {\n  if (id && elm && doc) {\n    if (!doc._ids[id]) {\n      doc._ids[id] = [];\n    }\n    doc._ids[id].push(elm);\n  }\n}\n\nfunction detachId(id, elm, doc) {\n  if (id && elm && doc) {\n    if (doc._ids && doc._ids[id]) {\n      const elms = doc._ids[id];\n      for (let i = 0; i < elms.length; i++) {\n        if (elms[i] === elm) {\n          elms.splice(i, 1);\n          --i;\n        }\n      }\n      if (elms.length === 0) {\n        delete doc._ids[id];\n      }\n    }\n  }\n}\n\nclass ElementImpl extends NodeImpl {\n  constructor(globalObject, args, privateData) {\n    super(globalObject, args, privateData);\n\n    this._initSlotableMixin();\n\n    this._namespaceURI = privateData.namespace;\n    this._prefix = privateData.prefix;\n    this._localName = privateData.localName;\n    this._ceState = privateData.ceState;\n    this._ceDefinition = privateData.ceDefinition;\n    this._isValue = privateData.isValue;\n\n    this._shadowRoot = null;\n    this._ceReactionQueue = [];\n\n    this.nodeType = NODE_TYPE.ELEMENT_NODE;\n    this.scrollTop = 0;\n    this.scrollLeft = 0;\n\n    this._attributeList = [];\n    // Used for caching.\n    this._attributesByNameMap = new Map();\n    this._attributes = NamedNodeMap.createImpl(this._globalObject, [], {\n      element: this\n    });\n\n    this._cachedTagName = null;\n  }\n\n  _attach() {\n    namedPropertiesWindow.nodeAttachedToDocument(this);\n\n    const id = this.getAttributeNS(null, \"id\");\n    if (id) {\n      attachId(id, this, this._ownerDocument);\n    }\n\n    super._attach();\n  }\n\n  _detach() {\n    super._detach();\n\n    namedPropertiesWindow.nodeDetachedFromDocument(this);\n\n    const id = this.getAttributeNS(null, \"id\");\n    if (id) {\n      detachId(id, this, this._ownerDocument);\n    }\n  }\n\n  _attrModified(name, value, oldValue) {\n    this._modified();\n    namedPropertiesWindow.elementAttributeModified(this, name, value, oldValue);\n\n    if (name === \"id\" && this._attached) {\n      const doc = this._ownerDocument;\n      detachId(oldValue, this, doc);\n      attachId(value, this, doc);\n    }\n\n    // update classList\n    if (name === \"class\" && this._classList !== undefined) {\n      this._classList.attrModified();\n    }\n\n    this._attrModifiedSlotableMixin(name, value, oldValue);\n  }\n\n  get namespaceURI() {\n    return this._namespaceURI;\n  }\n  get prefix() {\n    return this._prefix;\n  }\n  get localName() {\n    return this._localName;\n  }\n  get _qualifiedName() {\n    return this._prefix !== null ? this._prefix + \":\" + this._localName : this._localName;\n  }\n  get tagName() {\n    // This getter can be a hotpath in getComputedStyle.\n    // All these are invariants during the instance lifetime so we can safely cache the computed tagName.\n    // We could create it during construction but since we already identified this as potentially slow we do it lazily.\n    if (this._cachedTagName === null) {\n      if (this.namespaceURI === HTML_NS && this._ownerDocument._parsingMode === \"html\") {\n        this._cachedTagName = asciiUppercase(this._qualifiedName);\n      } else {\n        this._cachedTagName = this._qualifiedName;\n      }\n    }\n    return this._cachedTagName;\n  }\n\n  get attributes() {\n    return this._attributes;\n  }\n\n  // https://w3c.github.io/DOM-Parsing/#dom-element-outerhtml\n  get outerHTML() {\n    // TODO: maybe parse5 can give us a hook where it serializes the node itself too:\n    // https://github.com/inikulin/parse5/issues/230\n    // Alternatively, if we can create a virtual node in domSymbolTree, that'd also work.\n    // It's currently prevented by the fact that a node can't be duplicated in the same tree.\n    // Then we could get rid of all the code for childNodesForSerializing.\n    return fragmentSerialization({ childNodesForSerializing: [this], _ownerDocument: this._ownerDocument }, {\n      requireWellFormed: true,\n      globalObject: this._globalObject\n    });\n  }\n  set outerHTML(markup) {\n    let parent = domSymbolTree.parent(this);\n    const document = this._ownerDocument;\n\n    if (!parent) {\n      return;\n    }\n\n    if (parent.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n      throw DOMException.create(this._globalObject, [\n        \"Modifications are not allowed for this document\",\n        \"NoModificationAllowedError\"\n      ]);\n    }\n\n    if (parent.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      parent = document.createElementNS(HTML_NS, \"body\");\n    }\n\n    const fragment = parseFragment(markup, parent);\n\n    const contextObjectParent = domSymbolTree.parent(this);\n    contextObjectParent._replace(fragment, this);\n  }\n\n  get classList() {\n    if (this._classList === undefined) {\n      this._classList = DOMTokenList.createImpl(this._globalObject, [], {\n        element: this,\n        attributeLocalName: \"class\"\n      });\n    }\n    return this._classList;\n  }\n\n  hasAttributes() {\n    return attributes.hasAttributes(this);\n  }\n\n  getAttributeNames() {\n    return attributes.attributeNames(this);\n  }\n\n  getAttribute(name) {\n    const attr = attributes.getAttributeByName(this, name);\n    if (!attr) {\n      return null;\n    }\n    return attr._value;\n  }\n\n  getAttributeNS(namespace, localName) {\n    const attr = attributes.getAttributeByNameNS(this, namespace, localName);\n    if (!attr) {\n      return null;\n    }\n    return attr._value;\n  }\n\n  setAttribute(name, value) {\n    validateNames.name(this._globalObject, name);\n\n    if (this._namespaceURI === HTML_NS && this._ownerDocument._parsingMode === \"html\") {\n      name = asciiLowercase(name);\n    }\n\n    const attribute = attributes.getAttributeByName(this, name);\n\n    if (attribute === null) {\n      const newAttr = this._ownerDocument._createAttribute({\n        localName: name,\n        value\n      });\n      attributes.appendAttribute(this, newAttr);\n      return;\n    }\n\n    attributes.changeAttribute(this, attribute, value);\n  }\n\n  setAttributeNS(namespace, name, value) {\n    const extracted = validateNames.validateAndExtract(this._globalObject, namespace, name);\n\n    // Because of widespread use of this method internally, e.g. to manually implement attribute/content reflection, we\n    // centralize the conversion to a string here, so that all call sites don't have to do it.\n    value = `${value}`;\n\n    attributes.setAttributeValue(this, extracted.localName, value, extracted.prefix, extracted.namespace);\n  }\n\n  removeAttribute(name) {\n    attributes.removeAttributeByName(this, name);\n  }\n\n  removeAttributeNS(namespace, localName) {\n    attributes.removeAttributeByNameNS(this, namespace, localName);\n  }\n\n  toggleAttribute(qualifiedName, force) {\n    validateNames.name(this._globalObject, qualifiedName);\n\n    if (this._namespaceURI === HTML_NS && this._ownerDocument._parsingMode === \"html\") {\n      qualifiedName = asciiLowercase(qualifiedName);\n    }\n\n    const attribute = attributes.getAttributeByName(this, qualifiedName);\n\n    if (attribute === null) {\n      if (force === undefined || force === true) {\n        const newAttr = this._ownerDocument._createAttribute({\n          localName: qualifiedName,\n          value: \"\"\n        });\n        attributes.appendAttribute(this, newAttr);\n        return true;\n      }\n      return false;\n    }\n\n    if (force === undefined || force === false) {\n      attributes.removeAttributeByName(this, qualifiedName);\n      return false;\n    }\n\n    return true;\n  }\n\n  hasAttribute(name) {\n    if (this._namespaceURI === HTML_NS && this._ownerDocument._parsingMode === \"html\") {\n      name = asciiLowercase(name);\n    }\n\n    return attributes.hasAttributeByName(this, name);\n  }\n\n  hasAttributeNS(namespace, localName) {\n    if (namespace === \"\") {\n      namespace = null;\n    }\n\n    return attributes.hasAttributeByNameNS(this, namespace, localName);\n  }\n\n  getAttributeNode(name) {\n    return attributes.getAttributeByName(this, name);\n  }\n\n  getAttributeNodeNS(namespace, localName) {\n    return attributes.getAttributeByNameNS(this, namespace, localName);\n  }\n\n  setAttributeNode(attr) {\n    // eslint-disable-next-line no-restricted-properties\n    return attributes.setAttribute(this, attr);\n  }\n\n  setAttributeNodeNS(attr) {\n    // eslint-disable-next-line no-restricted-properties\n    return attributes.setAttribute(this, attr);\n  }\n\n  removeAttributeNode(attr) {\n    // eslint-disable-next-line no-restricted-properties\n    if (!attributes.hasAttribute(this, attr)) {\n      throw DOMException.create(this._globalObject, [\n        \"Tried to remove an attribute that was not present\",\n        \"NotFoundError\"\n      ]);\n    }\n\n    // eslint-disable-next-line no-restricted-properties\n    attributes.removeAttribute(this, attr);\n\n    return attr;\n  }\n\n  getBoundingClientRect() {\n    return {\n      x: 0,\n      y: 0,\n      bottom: 0,\n      height: 0,\n      left: 0,\n      right: 0,\n      top: 0,\n      width: 0\n    };\n  }\n\n  getClientRects() {\n    return [];\n  }\n\n  get scrollWidth() {\n    return 0;\n  }\n\n  get scrollHeight() {\n    return 0;\n  }\n\n  get clientTop() {\n    return 0;\n  }\n\n  get clientLeft() {\n    return 0;\n  }\n\n  get clientWidth() {\n    return 0;\n  }\n\n  get clientHeight() {\n    return 0;\n  }\n\n  // https://dom.spec.whatwg.org/#dom-element-attachshadow\n  attachShadow(init) {\n    const { _ownerDocument, _namespaceURI, _localName, _isValue } = this;\n\n    if (this.namespaceURI !== HTML_NS) {\n      throw DOMException.create(this._globalObject, [\n        \"This element does not support attachShadow. This element is not part of the HTML namespace.\",\n        \"NotSupportedError\"\n      ]);\n    }\n\n    if (!isValidHostElementName(_localName) && !isValidCustomElementName(_localName)) {\n      const message = \"This element does not support attachShadow. This element is not a custom element nor \" +\n        \"a standard element supporting a shadow root.\";\n      throw DOMException.create(this._globalObject, [message, \"NotSupportedError\"]);\n    }\n\n    if (isValidCustomElementName(_localName) || _isValue) {\n      const definition = lookupCEDefinition(_ownerDocument, _namespaceURI, _localName, _isValue);\n\n      if (definition && definition.disableShadow) {\n        throw DOMException.create(this._globalObject, [\n          \"Shadow root cannot be create on a custom element with disabled shadow\",\n          \"NotSupportedError\"\n        ]);\n      }\n    }\n\n    if (this._shadowRoot !== null) {\n      throw DOMException.create(this._globalObject, [\n        \"Shadow root cannot be created on a host which already hosts a shadow tree.\",\n        \"NotSupportedError\"\n      ]);\n    }\n\n    const shadow = ShadowRoot.createImpl(this._globalObject, [], {\n      ownerDocument: this.ownerDocument,\n      mode: init.mode,\n      host: this\n    });\n\n    this._shadowRoot = shadow;\n\n    return shadow;\n  }\n\n  // https://dom.spec.whatwg.org/#dom-element-shadowroot\n  get shadowRoot() {\n    const shadow = this._shadowRoot;\n\n    if (shadow === null || shadow.mode === \"closed\") {\n      return null;\n    }\n\n    return shadow;\n  }\n\n  // https://dom.spec.whatwg.org/#insert-adjacent\n  _insertAdjacent(element, where, node) {\n    where = asciiLowercase(where);\n\n    if (where === \"beforebegin\") {\n      if (element.parentNode === null) {\n        return null;\n      }\n      return element.parentNode._preInsert(node, element);\n    }\n    if (where === \"afterbegin\") {\n      return element._preInsert(node, element.firstChild);\n    }\n    if (where === \"beforeend\") {\n      return element._preInsert(node, null);\n    }\n    if (where === \"afterend\") {\n      if (element.parentNode === null) {\n        return null;\n      }\n      return element.parentNode._preInsert(node, element.nextSibling);\n    }\n\n    throw DOMException.create(this._globalObject, [\n      'Must provide one of \"beforebegin\", \"afterbegin\", \"beforeend\", or \"afterend\".',\n      \"SyntaxError\"\n    ]);\n  }\n\n  insertAdjacentElement(where, element) {\n    return this._insertAdjacent(this, where, element);\n  }\n\n  insertAdjacentText(where, data) {\n    const text = Text.createImpl(this._globalObject, [], { data, ownerDocument: this._ownerDocument });\n\n    this._insertAdjacent(this, where, text);\n  }\n\n  // https://w3c.github.io/DOM-Parsing/#dom-element-insertadjacenthtml\n  insertAdjacentHTML(position, text) {\n    position = asciiLowercase(position);\n\n    let context;\n    switch (position) {\n      case \"beforebegin\":\n      case \"afterend\": {\n        context = this.parentNode;\n        if (context === null || context.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n          throw DOMException.create(this._globalObject, [\n            \"Cannot insert HTML adjacent to parent-less nodes or children of document nodes.\",\n            \"NoModificationAllowedError\"\n          ]);\n        }\n        break;\n      }\n      case \"afterbegin\":\n      case \"beforeend\": {\n        context = this;\n        break;\n      }\n      default: {\n        throw DOMException.create(this._globalObject, [\n          'Must provide one of \"beforebegin\", \"afterbegin\", \"beforeend\", or \"afterend\".',\n          \"SyntaxError\"\n        ]);\n      }\n    }\n\n    if (\n      context.nodeType !== NODE_TYPE.ELEMENT_NODE ||\n      (\n        context._ownerDocument._parsingMode === \"html\" &&\n        context._localName === \"html\" &&\n        context._namespaceURI === HTML_NS\n      )\n    ) {\n      context = context._ownerDocument.createElement(\"body\");\n    }\n\n    const fragment = parseFragment(text, context);\n\n    switch (position) {\n      case \"beforebegin\": {\n        this.parentNode._insert(fragment, this);\n        break;\n      }\n      case \"afterbegin\": {\n        this._insert(fragment, this.firstChild);\n        break;\n      }\n      case \"beforeend\": {\n        this._append(fragment);\n        break;\n      }\n      case \"afterend\": {\n        this.parentNode._insert(fragment, this.nextSibling);\n        break;\n      }\n    }\n  }\n\n  closest(selectors) {\n    const matcher = addNwsapi(this);\n    return matcher.closest(selectors, idlUtils.wrapperForImpl(this));\n  }\n}\n\nmixin(ElementImpl.prototype, NonDocumentTypeChildNode.prototype);\nmixin(ElementImpl.prototype, ParentNodeImpl.prototype);\nmixin(ElementImpl.prototype, ChildNodeImpl.prototype);\nmixin(ElementImpl.prototype, SlotableMixinImpl.prototype);\nmixin(ElementImpl.prototype, InnerHTMLImpl.prototype);\n\nElementImpl.prototype.getElementsByTagName = memoizeQuery(function (qualifiedName) {\n  return listOfElementsWithQualifiedName(qualifiedName, this);\n});\n\nElementImpl.prototype.getElementsByTagNameNS = memoizeQuery(function (namespace, localName) {\n  return listOfElementsWithNamespaceAndLocalName(namespace, localName, this);\n});\n\nElementImpl.prototype.getElementsByClassName = memoizeQuery(function (classNames) {\n  return listOfElementsWithClassNames(classNames, this);\n});\n\nElementImpl.prototype.matches = function (selectors) {\n  const matcher = addNwsapi(this);\n\n  return matcher.match(selectors, idlUtils.wrapperForImpl(this));\n};\n\nElementImpl.prototype.webkitMatchesSelector = ElementImpl.prototype.matches;\n\nmodule.exports = {\n  implementation: ElementImpl\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}