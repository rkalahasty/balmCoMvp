{"ast":null,"code":"'use strict';\n/**\n * @module symbol-tree\n * @author Joris van der Wel <joris@jorisvanderwel.com>\n */\n\nconst SymbolTreeNode = require('./SymbolTreeNode');\n\nconst TreePosition = require('./TreePosition');\n\nconst TreeIterator = require('./TreeIterator');\n\nfunction returnTrue() {\n  return true;\n}\n\nfunction reverseArrayIndex(array, reverseIndex) {\n  return array[array.length - 1 - reverseIndex]; // no need to check `index >= 0`\n}\n\nclass SymbolTree {\n  /**\n   * @constructor\n   * @alias module:symbol-tree\n   * @param {string} [description='SymbolTree data'] Description used for the Symbol\n   */\n  constructor(description) {\n    this.symbol = Symbol(description || 'SymbolTree data');\n  }\n  /**\n   * You can use this function to (optionally) initialize an object right after its creation,\n   * to take advantage of V8's fast properties. Also useful if you would like to\n   * freeze your object.\n   *\n   * `O(1)`\n   *\n   * @method\n   * @alias module:symbol-tree#initialize\n   * @param {Object} object\n   * @return {Object} object\n   */\n\n\n  initialize(object) {\n    this._node(object);\n\n    return object;\n  }\n\n  _node(object) {\n    if (!object) {\n      return null;\n    }\n\n    const node = object[this.symbol];\n\n    if (node) {\n      return node;\n    }\n\n    return object[this.symbol] = new SymbolTreeNode();\n  }\n  /**\n   * Returns `true` if the object has any children. Otherwise it returns `false`.\n   *\n   * * `O(1)`\n   *\n   * @method hasChildren\n   * @memberOf module:symbol-tree#\n   * @param {Object} object\n   * @return {Boolean}\n   */\n\n\n  hasChildren(object) {\n    return this._node(object).hasChildren;\n  }\n  /**\n   * Returns the first child of the given object.\n   *\n   * * `O(1)`\n   *\n   * @method firstChild\n   * @memberOf module:symbol-tree#\n   * @param {Object} object\n   * @return {Object}\n   */\n\n\n  firstChild(object) {\n    return this._node(object).firstChild;\n  }\n  /**\n   * Returns the last child of the given object.\n   *\n   * * `O(1)`\n   *\n   * @method lastChild\n   * @memberOf module:symbol-tree#\n   * @param {Object} object\n   * @return {Object}\n   */\n\n\n  lastChild(object) {\n    return this._node(object).lastChild;\n  }\n  /**\n   * Returns the previous sibling of the given object.\n   *\n   * * `O(1)`\n   *\n   * @method previousSibling\n   * @memberOf module:symbol-tree#\n   * @param {Object} object\n   * @return {Object}\n   */\n\n\n  previousSibling(object) {\n    return this._node(object).previousSibling;\n  }\n  /**\n   * Returns the next sibling of the given object.\n   *\n   * * `O(1)`\n   *\n   * @method nextSibling\n   * @memberOf module:symbol-tree#\n   * @param {Object} object\n   * @return {Object}\n   */\n\n\n  nextSibling(object) {\n    return this._node(object).nextSibling;\n  }\n  /**\n   * Return the parent of the given object.\n   *\n   * * `O(1)`\n   *\n   * @method parent\n   * @memberOf module:symbol-tree#\n   * @param {Object} object\n   * @return {Object}\n   */\n\n\n  parent(object) {\n    return this._node(object).parent;\n  }\n  /**\n   * Find the inclusive descendant that is last in tree order of the given object.\n   *\n   * * `O(n)` (worst case) where `n` is the depth of the subtree of `object`\n   *\n   * @method lastInclusiveDescendant\n   * @memberOf module:symbol-tree#\n   * @param {Object} object\n   * @return {Object}\n   */\n\n\n  lastInclusiveDescendant(object) {\n    let lastChild;\n    let current = object;\n\n    while (lastChild = this._node(current).lastChild) {\n      current = lastChild;\n    }\n\n    return current;\n  }\n  /**\n   * Find the preceding object (A) of the given object (B).\n   * An object A is preceding an object B if A and B are in the same tree\n   * and A comes before B in tree order.\n   *\n   * * `O(n)` (worst case)\n   * * `O(1)` (amortized when walking the entire tree)\n   *\n   * @method preceding\n   * @memberOf module:symbol-tree#\n   * @param {Object} object\n   * @param {Object} [options]\n   * @param {Object} [options.root] If set, `root` must be an inclusive ancestor\n   *        of the return value (or else null is returned). This check _assumes_\n   *        that `root` is also an inclusive ancestor of the given `object`\n   * @return {?Object}\n   */\n\n\n  preceding(object, options) {\n    const treeRoot = options && options.root;\n\n    if (object === treeRoot) {\n      return null;\n    }\n\n    const previousSibling = this._node(object).previousSibling;\n\n    if (previousSibling) {\n      return this.lastInclusiveDescendant(previousSibling);\n    } // if there is no previous sibling return the parent (might be null)\n\n\n    return this._node(object).parent;\n  }\n  /**\n   * Find the following object (A) of the given object (B).\n   * An object A is following an object B if A and B are in the same tree\n   * and A comes after B in tree order.\n   *\n   * * `O(n)` (worst case) where `n` is the amount of objects in the entire tree\n   * * `O(1)` (amortized when walking the entire tree)\n   *\n   * @method following\n   * @memberOf module:symbol-tree#\n   * @param {!Object} object\n   * @param {Object} [options]\n   * @param {Object} [options.root] If set, `root` must be an inclusive ancestor\n   *        of the return value (or else null is returned). This check _assumes_\n   *        that `root` is also an inclusive ancestor of the given `object`\n   * @param {Boolean} [options.skipChildren=false] If set, ignore the children of `object`\n   * @return {?Object}\n   */\n\n\n  following(object, options) {\n    const treeRoot = options && options.root;\n    const skipChildren = options && options.skipChildren;\n\n    const firstChild = !skipChildren && this._node(object).firstChild;\n\n    if (firstChild) {\n      return firstChild;\n    }\n\n    let current = object;\n\n    do {\n      if (current === treeRoot) {\n        return null;\n      }\n\n      const nextSibling = this._node(current).nextSibling;\n\n      if (nextSibling) {\n        return nextSibling;\n      }\n\n      current = this._node(current).parent;\n    } while (current);\n\n    return null;\n  }\n  /**\n   * Append all children of the given object to an array.\n   *\n   * * `O(n)` where `n` is the amount of children of the given `parent`\n   *\n   * @method childrenToArray\n   * @memberOf module:symbol-tree#\n   * @param {Object} parent\n   * @param {Object} [options]\n   * @param {Object[]} [options.array=[]]\n   * @param {Function} [options.filter] Function to test each object before it is added to the array.\n   *                            Invoked with arguments (object). Should return `true` if an object\n   *                            is to be included.\n   * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\n   * @return {Object[]}\n   */\n\n\n  childrenToArray(parent, options) {\n    const array = options && options.array || [];\n    const filter = options && options.filter || returnTrue;\n    const thisArg = options && options.thisArg || undefined;\n\n    const parentNode = this._node(parent);\n\n    let object = parentNode.firstChild;\n    let index = 0;\n\n    while (object) {\n      const node = this._node(object);\n\n      node.setCachedIndex(parentNode, index);\n\n      if (filter.call(thisArg, object)) {\n        array.push(object);\n      }\n\n      object = node.nextSibling;\n      ++index;\n    }\n\n    return array;\n  }\n  /**\n   * Append all inclusive ancestors of the given object to an array.\n   *\n   * * `O(n)` where `n` is the amount of ancestors of the given `object`\n   *\n   * @method ancestorsToArray\n   * @memberOf module:symbol-tree#\n   * @param {Object} object\n   * @param {Object} [options]\n   * @param {Object[]} [options.array=[]]\n   * @param {Function} [options.filter] Function to test each object before it is added to the array.\n   *                            Invoked with arguments (object). Should return `true` if an object\n   *                            is to be included.\n   * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\n   * @return {Object[]}\n   */\n\n\n  ancestorsToArray(object, options) {\n    const array = options && options.array || [];\n    const filter = options && options.filter || returnTrue;\n    const thisArg = options && options.thisArg || undefined;\n    let ancestor = object;\n\n    while (ancestor) {\n      if (filter.call(thisArg, ancestor)) {\n        array.push(ancestor);\n      }\n\n      ancestor = this._node(ancestor).parent;\n    }\n\n    return array;\n  }\n  /**\n   * Append all descendants of the given object to an array (in tree order).\n   *\n   * * `O(n)` where `n` is the amount of objects in the sub-tree of the given `object`\n   *\n   * @method treeToArray\n   * @memberOf module:symbol-tree#\n   * @param {Object} root\n   * @param {Object} [options]\n   * @param {Object[]} [options.array=[]]\n   * @param {Function} [options.filter] Function to test each object before it is added to the array.\n   *                            Invoked with arguments (object). Should return `true` if an object\n   *                            is to be included.\n   * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\n   * @return {Object[]}\n   */\n\n\n  treeToArray(root, options) {\n    const array = options && options.array || [];\n    const filter = options && options.filter || returnTrue;\n    const thisArg = options && options.thisArg || undefined;\n    let object = root;\n\n    while (object) {\n      if (filter.call(thisArg, object)) {\n        array.push(object);\n      }\n\n      object = this.following(object, {\n        root: root\n      });\n    }\n\n    return array;\n  }\n  /**\n   * Iterate over all children of the given object\n   *\n   * * `O(1)` for a single iteration\n   *\n   * @method childrenIterator\n   * @memberOf module:symbol-tree#\n   * @param {Object} parent\n   * @param {Object} [options]\n   * @param {Boolean} [options.reverse=false]\n   * @return {Object} An iterable iterator (ES6)\n   */\n\n\n  childrenIterator(parent, options) {\n    const reverse = options && options.reverse;\n\n    const parentNode = this._node(parent);\n\n    return new TreeIterator(this, parent, reverse ? parentNode.lastChild : parentNode.firstChild, reverse ? TreeIterator.PREV : TreeIterator.NEXT);\n  }\n  /**\n   * Iterate over all the previous siblings of the given object. (in reverse tree order)\n   *\n   * * `O(1)` for a single iteration\n   *\n   * @method previousSiblingsIterator\n   * @memberOf module:symbol-tree#\n   * @param {Object} object\n   * @return {Object} An iterable iterator (ES6)\n   */\n\n\n  previousSiblingsIterator(object) {\n    return new TreeIterator(this, object, this._node(object).previousSibling, TreeIterator.PREV);\n  }\n  /**\n   * Iterate over all the next siblings of the given object. (in tree order)\n   *\n   * * `O(1)` for a single iteration\n   *\n   * @method nextSiblingsIterator\n   * @memberOf module:symbol-tree#\n   * @param {Object} object\n   * @return {Object} An iterable iterator (ES6)\n   */\n\n\n  nextSiblingsIterator(object) {\n    return new TreeIterator(this, object, this._node(object).nextSibling, TreeIterator.NEXT);\n  }\n  /**\n   * Iterate over all inclusive ancestors of the given object\n   *\n   * * `O(1)` for a single iteration\n   *\n   * @method ancestorsIterator\n   * @memberOf module:symbol-tree#\n   * @param {Object} object\n   * @return {Object} An iterable iterator (ES6)\n   */\n\n\n  ancestorsIterator(object) {\n    return new TreeIterator(this, object, object, TreeIterator.PARENT);\n  }\n  /**\n   * Iterate over all descendants of the given object (in tree order).\n   *\n   * Where `n` is the amount of objects in the sub-tree of the given `root`:\n   *\n   * * `O(n)` (worst case for a single iteration)\n   * * `O(n)` (amortized, when completing the iterator)\n   *\n   * @method treeIterator\n   * @memberOf module:symbol-tree#\n   * @param {Object} root\n   * @param {Object} options\n   * @param {Boolean} [options.reverse=false]\n   * @return {Object} An iterable iterator (ES6)\n   */\n\n\n  treeIterator(root, options) {\n    const reverse = options && options.reverse;\n    return new TreeIterator(this, root, reverse ? this.lastInclusiveDescendant(root) : root, reverse ? TreeIterator.PRECEDING : TreeIterator.FOLLOWING);\n  }\n  /**\n   * Find the index of the given object (the number of preceding siblings).\n   *\n   * * `O(n)` where `n` is the amount of preceding siblings\n   * * `O(1)` (amortized, if the tree is not modified)\n   *\n   * @method index\n   * @memberOf module:symbol-tree#\n   * @param {Object} child\n   * @return {Number} The number of preceding siblings, or -1 if the object has no parent\n   */\n\n\n  index(child) {\n    const childNode = this._node(child);\n\n    const parentNode = this._node(childNode.parent);\n\n    if (!parentNode) {\n      // In principal, you could also find out the number of preceding siblings\n      // for objects that do not have a parent. This method limits itself only to\n      // objects that have a parent because that lets us optimize more.\n      return -1;\n    }\n\n    let currentIndex = childNode.getCachedIndex(parentNode);\n\n    if (currentIndex >= 0) {\n      return currentIndex;\n    }\n\n    currentIndex = 0;\n    let object = parentNode.firstChild;\n\n    if (parentNode.childIndexCachedUpTo) {\n      const cachedUpToNode = this._node(parentNode.childIndexCachedUpTo);\n\n      object = cachedUpToNode.nextSibling;\n      currentIndex = cachedUpToNode.getCachedIndex(parentNode) + 1;\n    }\n\n    while (object) {\n      const node = this._node(object);\n\n      node.setCachedIndex(parentNode, currentIndex);\n\n      if (object === child) {\n        break;\n      }\n\n      ++currentIndex;\n      object = node.nextSibling;\n    }\n\n    parentNode.childIndexCachedUpTo = child;\n    return currentIndex;\n  }\n  /**\n   * Calculate the number of children.\n   *\n   * * `O(n)` where `n` is the amount of children\n   * * `O(1)` (amortized, if the tree is not modified)\n   *\n   * @method childrenCount\n   * @memberOf module:symbol-tree#\n   * @param {Object} parent\n   * @return {Number}\n   */\n\n\n  childrenCount(parent) {\n    const parentNode = this._node(parent);\n\n    if (!parentNode.lastChild) {\n      return 0;\n    }\n\n    return this.index(parentNode.lastChild) + 1;\n  }\n  /**\n   * Compare the position of an object relative to another object. A bit set is returned:\n   *\n   * <ul>\n   *     <li>DISCONNECTED : 1</li>\n   *     <li>PRECEDING : 2</li>\n   *     <li>FOLLOWING : 4</li>\n   *     <li>CONTAINS : 8</li>\n   *     <li>CONTAINED_BY : 16</li>\n   * </ul>\n   *\n   * The semantics are the same as compareDocumentPosition in DOM, with the exception that\n   * DISCONNECTED never occurs with any other bit.\n   *\n   * where `n` and `m` are the amount of ancestors of `left` and `right`;\n   * where `o` is the amount of children of the lowest common ancestor of `left` and `right`:\n   *\n   * * `O(n + m + o)` (worst case)\n   * * `O(n + m)` (amortized, if the tree is not modified)\n   *\n   * @method compareTreePosition\n   * @memberOf module:symbol-tree#\n   * @param {Object} left\n   * @param {Object} right\n   * @return {Number}\n   */\n\n\n  compareTreePosition(left, right) {\n    // In DOM terms:\n    // left = reference / context object\n    // right = other\n    if (left === right) {\n      return 0;\n    }\n    /* jshint -W016 */\n\n\n    const leftAncestors = [];\n    {\n      // inclusive\n      let leftAncestor = left;\n\n      while (leftAncestor) {\n        if (leftAncestor === right) {\n          return TreePosition.CONTAINS | TreePosition.PRECEDING; // other is ancestor of reference\n        }\n\n        leftAncestors.push(leftAncestor);\n        leftAncestor = this.parent(leftAncestor);\n      }\n    }\n    const rightAncestors = [];\n    {\n      let rightAncestor = right;\n\n      while (rightAncestor) {\n        if (rightAncestor === left) {\n          return TreePosition.CONTAINED_BY | TreePosition.FOLLOWING;\n        }\n\n        rightAncestors.push(rightAncestor);\n        rightAncestor = this.parent(rightAncestor);\n      }\n    }\n    const root = reverseArrayIndex(leftAncestors, 0);\n\n    if (!root || root !== reverseArrayIndex(rightAncestors, 0)) {\n      // note: unlike DOM, preceding / following is not set here\n      return TreePosition.DISCONNECTED;\n    } // find the lowest common ancestor\n\n\n    let commonAncestorIndex = 0;\n    const ancestorsMinLength = Math.min(leftAncestors.length, rightAncestors.length);\n\n    for (let i = 0; i < ancestorsMinLength; ++i) {\n      const leftAncestor = reverseArrayIndex(leftAncestors, i);\n      const rightAncestor = reverseArrayIndex(rightAncestors, i);\n\n      if (leftAncestor !== rightAncestor) {\n        break;\n      }\n\n      commonAncestorIndex = i;\n    } // indexes within the common ancestor\n\n\n    const leftIndex = this.index(reverseArrayIndex(leftAncestors, commonAncestorIndex + 1));\n    const rightIndex = this.index(reverseArrayIndex(rightAncestors, commonAncestorIndex + 1));\n    return rightIndex < leftIndex ? TreePosition.PRECEDING : TreePosition.FOLLOWING;\n  }\n  /**\n   * Remove the object from this tree.\n   * Has no effect if already removed.\n   *\n   * * `O(1)`\n   *\n   * @method remove\n   * @memberOf module:symbol-tree#\n   * @param {Object} removeObject\n   * @return {Object} removeObject\n   */\n\n\n  remove(removeObject) {\n    const removeNode = this._node(removeObject);\n\n    const parentNode = this._node(removeNode.parent);\n\n    const prevNode = this._node(removeNode.previousSibling);\n\n    const nextNode = this._node(removeNode.nextSibling);\n\n    if (parentNode) {\n      if (parentNode.firstChild === removeObject) {\n        parentNode.firstChild = removeNode.nextSibling;\n      }\n\n      if (parentNode.lastChild === removeObject) {\n        parentNode.lastChild = removeNode.previousSibling;\n      }\n    }\n\n    if (prevNode) {\n      prevNode.nextSibling = removeNode.nextSibling;\n    }\n\n    if (nextNode) {\n      nextNode.previousSibling = removeNode.previousSibling;\n    }\n\n    removeNode.parent = null;\n    removeNode.previousSibling = null;\n    removeNode.nextSibling = null;\n    removeNode.cachedIndex = -1;\n    removeNode.cachedIndexVersion = NaN;\n\n    if (parentNode) {\n      parentNode.childrenChanged();\n    }\n\n    return removeObject;\n  }\n  /**\n   * Insert the given object before the reference object.\n   * `newObject` is now the previous sibling of `referenceObject`.\n   *\n   * * `O(1)`\n   *\n   * @method insertBefore\n   * @memberOf module:symbol-tree#\n   * @param {Object} referenceObject\n   * @param {Object} newObject\n   * @throws {Error} If the newObject is already present in this SymbolTree\n   * @return {Object} newObject\n   */\n\n\n  insertBefore(referenceObject, newObject) {\n    const referenceNode = this._node(referenceObject);\n\n    const prevNode = this._node(referenceNode.previousSibling);\n\n    const newNode = this._node(newObject);\n\n    const parentNode = this._node(referenceNode.parent);\n\n    if (newNode.isAttached) {\n      throw Error('Given object is already present in this SymbolTree, remove it first');\n    }\n\n    newNode.parent = referenceNode.parent;\n    newNode.previousSibling = referenceNode.previousSibling;\n    newNode.nextSibling = referenceObject;\n    referenceNode.previousSibling = newObject;\n\n    if (prevNode) {\n      prevNode.nextSibling = newObject;\n    }\n\n    if (parentNode && parentNode.firstChild === referenceObject) {\n      parentNode.firstChild = newObject;\n    }\n\n    if (parentNode) {\n      parentNode.childrenChanged();\n    }\n\n    return newObject;\n  }\n  /**\n   * Insert the given object after the reference object.\n   * `newObject` is now the next sibling of `referenceObject`.\n   *\n   * * `O(1)`\n   *\n   * @method insertAfter\n   * @memberOf module:symbol-tree#\n   * @param {Object} referenceObject\n   * @param {Object} newObject\n   * @throws {Error} If the newObject is already present in this SymbolTree\n   * @return {Object} newObject\n   */\n\n\n  insertAfter(referenceObject, newObject) {\n    const referenceNode = this._node(referenceObject);\n\n    const nextNode = this._node(referenceNode.nextSibling);\n\n    const newNode = this._node(newObject);\n\n    const parentNode = this._node(referenceNode.parent);\n\n    if (newNode.isAttached) {\n      throw Error('Given object is already present in this SymbolTree, remove it first');\n    }\n\n    newNode.parent = referenceNode.parent;\n    newNode.previousSibling = referenceObject;\n    newNode.nextSibling = referenceNode.nextSibling;\n    referenceNode.nextSibling = newObject;\n\n    if (nextNode) {\n      nextNode.previousSibling = newObject;\n    }\n\n    if (parentNode && parentNode.lastChild === referenceObject) {\n      parentNode.lastChild = newObject;\n    }\n\n    if (parentNode) {\n      parentNode.childrenChanged();\n    }\n\n    return newObject;\n  }\n  /**\n   * Insert the given object as the first child of the given reference object.\n   * `newObject` is now the first child of `referenceObject`.\n   *\n   * * `O(1)`\n   *\n   * @method prependChild\n   * @memberOf module:symbol-tree#\n   * @param {Object} referenceObject\n   * @param {Object} newObject\n   * @throws {Error} If the newObject is already present in this SymbolTree\n   * @return {Object} newObject\n   */\n\n\n  prependChild(referenceObject, newObject) {\n    const referenceNode = this._node(referenceObject);\n\n    const newNode = this._node(newObject);\n\n    if (newNode.isAttached) {\n      throw Error('Given object is already present in this SymbolTree, remove it first');\n    }\n\n    if (referenceNode.hasChildren) {\n      this.insertBefore(referenceNode.firstChild, newObject);\n    } else {\n      newNode.parent = referenceObject;\n      referenceNode.firstChild = newObject;\n      referenceNode.lastChild = newObject;\n      referenceNode.childrenChanged();\n    }\n\n    return newObject;\n  }\n  /**\n   * Insert the given object as the last child of the given reference object.\n   * `newObject` is now the last child of `referenceObject`.\n   *\n   * * `O(1)`\n   *\n   * @method appendChild\n   * @memberOf module:symbol-tree#\n   * @param {Object} referenceObject\n   * @param {Object} newObject\n   * @throws {Error} If the newObject is already present in this SymbolTree\n   * @return {Object} newObject\n   */\n\n\n  appendChild(referenceObject, newObject) {\n    const referenceNode = this._node(referenceObject);\n\n    const newNode = this._node(newObject);\n\n    if (newNode.isAttached) {\n      throw Error('Given object is already present in this SymbolTree, remove it first');\n    }\n\n    if (referenceNode.hasChildren) {\n      this.insertAfter(referenceNode.lastChild, newObject);\n    } else {\n      newNode.parent = referenceObject;\n      referenceNode.firstChild = newObject;\n      referenceNode.lastChild = newObject;\n      referenceNode.childrenChanged();\n    }\n\n    return newObject;\n  }\n\n}\n\nmodule.exports = SymbolTree;\nSymbolTree.TreePosition = TreePosition;","map":{"version":3,"names":["SymbolTreeNode","require","TreePosition","TreeIterator","returnTrue","reverseArrayIndex","array","reverseIndex","length","SymbolTree","constructor","description","symbol","Symbol","initialize","object","_node","node","hasChildren","firstChild","lastChild","previousSibling","nextSibling","parent","lastInclusiveDescendant","current","preceding","options","treeRoot","root","following","skipChildren","childrenToArray","filter","thisArg","undefined","parentNode","index","setCachedIndex","call","push","ancestorsToArray","ancestor","treeToArray","childrenIterator","reverse","PREV","NEXT","previousSiblingsIterator","nextSiblingsIterator","ancestorsIterator","PARENT","treeIterator","PRECEDING","FOLLOWING","child","childNode","currentIndex","getCachedIndex","childIndexCachedUpTo","cachedUpToNode","childrenCount","compareTreePosition","left","right","leftAncestors","leftAncestor","CONTAINS","rightAncestors","rightAncestor","CONTAINED_BY","DISCONNECTED","commonAncestorIndex","ancestorsMinLength","Math","min","i","leftIndex","rightIndex","remove","removeObject","removeNode","prevNode","nextNode","cachedIndex","cachedIndexVersion","NaN","childrenChanged","insertBefore","referenceObject","newObject","referenceNode","newNode","isAttached","Error","insertAfter","prependChild","appendChild","module","exports"],"sources":["C:/Users/17033/balmco/node_modules/symbol-tree/lib/SymbolTree.js"],"sourcesContent":["'use strict';\n\n/**\n * @module symbol-tree\n * @author Joris van der Wel <joris@jorisvanderwel.com>\n */\n\nconst SymbolTreeNode = require('./SymbolTreeNode');\nconst TreePosition = require('./TreePosition');\nconst TreeIterator = require('./TreeIterator');\n\nfunction returnTrue() {\n        return true;\n}\n\nfunction reverseArrayIndex(array, reverseIndex) {\n        return array[array.length - 1 - reverseIndex]; // no need to check `index >= 0`\n}\n\nclass SymbolTree {\n\n        /**\n         * @constructor\n         * @alias module:symbol-tree\n         * @param {string} [description='SymbolTree data'] Description used for the Symbol\n         */\n        constructor(description) {\n                this.symbol = Symbol(description || 'SymbolTree data');\n        }\n\n        /**\n         * You can use this function to (optionally) initialize an object right after its creation,\n         * to take advantage of V8's fast properties. Also useful if you would like to\n         * freeze your object.\n         *\n         * `O(1)`\n         *\n         * @method\n         * @alias module:symbol-tree#initialize\n         * @param {Object} object\n         * @return {Object} object\n         */\n        initialize(object) {\n                this._node(object);\n\n                return object;\n        }\n\n        _node(object) {\n                if (!object) {\n                        return null;\n                }\n\n                const node = object[this.symbol];\n\n                if (node) {\n                        return node;\n                }\n\n                return (object[this.symbol] = new SymbolTreeNode());\n        }\n\n        /**\n         * Returns `true` if the object has any children. Otherwise it returns `false`.\n         *\n         * * `O(1)`\n         *\n         * @method hasChildren\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Boolean}\n         */\n        hasChildren(object) {\n                return this._node(object).hasChildren;\n        }\n\n        /**\n         * Returns the first child of the given object.\n         *\n         * * `O(1)`\n         *\n         * @method firstChild\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object}\n         */\n        firstChild(object) {\n                return this._node(object).firstChild;\n        }\n\n        /**\n         * Returns the last child of the given object.\n         *\n         * * `O(1)`\n         *\n         * @method lastChild\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object}\n         */\n        lastChild(object) {\n                return this._node(object).lastChild;\n        }\n\n        /**\n         * Returns the previous sibling of the given object.\n         *\n         * * `O(1)`\n         *\n         * @method previousSibling\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object}\n         */\n        previousSibling(object) {\n                return this._node(object).previousSibling;\n        }\n\n        /**\n         * Returns the next sibling of the given object.\n         *\n         * * `O(1)`\n         *\n         * @method nextSibling\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object}\n         */\n        nextSibling(object) {\n                return this._node(object).nextSibling;\n        }\n\n        /**\n         * Return the parent of the given object.\n         *\n         * * `O(1)`\n         *\n         * @method parent\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object}\n         */\n        parent(object) {\n                return this._node(object).parent;\n        }\n\n        /**\n         * Find the inclusive descendant that is last in tree order of the given object.\n         *\n         * * `O(n)` (worst case) where `n` is the depth of the subtree of `object`\n         *\n         * @method lastInclusiveDescendant\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object}\n         */\n        lastInclusiveDescendant(object) {\n                let lastChild;\n                let current = object;\n\n                while ((lastChild = this._node(current).lastChild)) {\n                        current = lastChild;\n                }\n\n                return current;\n        }\n\n        /**\n         * Find the preceding object (A) of the given object (B).\n         * An object A is preceding an object B if A and B are in the same tree\n         * and A comes before B in tree order.\n         *\n         * * `O(n)` (worst case)\n         * * `O(1)` (amortized when walking the entire tree)\n         *\n         * @method preceding\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @param {Object} [options]\n         * @param {Object} [options.root] If set, `root` must be an inclusive ancestor\n         *        of the return value (or else null is returned). This check _assumes_\n         *        that `root` is also an inclusive ancestor of the given `object`\n         * @return {?Object}\n         */\n        preceding(object, options) {\n                const treeRoot = options && options.root;\n\n                if (object === treeRoot) {\n                        return null;\n                }\n\n                const previousSibling = this._node(object).previousSibling;\n\n                if (previousSibling) {\n                        return this.lastInclusiveDescendant(previousSibling);\n                }\n\n                // if there is no previous sibling return the parent (might be null)\n                return this._node(object).parent;\n        }\n\n        /**\n         * Find the following object (A) of the given object (B).\n         * An object A is following an object B if A and B are in the same tree\n         * and A comes after B in tree order.\n         *\n         * * `O(n)` (worst case) where `n` is the amount of objects in the entire tree\n         * * `O(1)` (amortized when walking the entire tree)\n         *\n         * @method following\n         * @memberOf module:symbol-tree#\n         * @param {!Object} object\n         * @param {Object} [options]\n         * @param {Object} [options.root] If set, `root` must be an inclusive ancestor\n         *        of the return value (or else null is returned). This check _assumes_\n         *        that `root` is also an inclusive ancestor of the given `object`\n         * @param {Boolean} [options.skipChildren=false] If set, ignore the children of `object`\n         * @return {?Object}\n         */\n        following(object, options) {\n                const treeRoot = options && options.root;\n                const skipChildren = options && options.skipChildren;\n\n                const firstChild = !skipChildren && this._node(object).firstChild;\n\n                if (firstChild) {\n                        return firstChild;\n                }\n\n                let current = object;\n\n                do {\n                        if (current === treeRoot) {\n                                return null;\n                        }\n\n                        const nextSibling = this._node(current).nextSibling;\n\n                        if (nextSibling) {\n                                return nextSibling;\n                        }\n\n                        current = this._node(current).parent;\n                } while (current);\n\n                return null;\n        }\n\n        /**\n         * Append all children of the given object to an array.\n         *\n         * * `O(n)` where `n` is the amount of children of the given `parent`\n         *\n         * @method childrenToArray\n         * @memberOf module:symbol-tree#\n         * @param {Object} parent\n         * @param {Object} [options]\n         * @param {Object[]} [options.array=[]]\n         * @param {Function} [options.filter] Function to test each object before it is added to the array.\n         *                            Invoked with arguments (object). Should return `true` if an object\n         *                            is to be included.\n         * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\n         * @return {Object[]}\n         */\n        childrenToArray(parent, options) {\n                const array   = (options && options.array) || [];\n                const filter  = (options && options.filter) || returnTrue;\n                const thisArg = (options && options.thisArg) || undefined;\n\n                const parentNode = this._node(parent);\n                let object = parentNode.firstChild;\n                let index = 0;\n\n                while (object) {\n                        const node = this._node(object);\n                        node.setCachedIndex(parentNode, index);\n\n                        if (filter.call(thisArg, object)) {\n                                array.push(object);\n                        }\n\n                        object = node.nextSibling;\n                        ++index;\n                }\n\n                return array;\n        }\n\n        /**\n         * Append all inclusive ancestors of the given object to an array.\n         *\n         * * `O(n)` where `n` is the amount of ancestors of the given `object`\n         *\n         * @method ancestorsToArray\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @param {Object} [options]\n         * @param {Object[]} [options.array=[]]\n         * @param {Function} [options.filter] Function to test each object before it is added to the array.\n         *                            Invoked with arguments (object). Should return `true` if an object\n         *                            is to be included.\n         * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\n         * @return {Object[]}\n         */\n        ancestorsToArray(object, options) {\n                const array   = (options && options.array) || [];\n                const filter  = (options && options.filter) || returnTrue;\n                const thisArg = (options && options.thisArg) || undefined;\n\n                let ancestor = object;\n\n                while (ancestor) {\n                        if (filter.call(thisArg, ancestor)) {\n                                array.push(ancestor);\n                        }\n                        ancestor = this._node(ancestor).parent;\n                }\n\n                return array;\n        }\n\n        /**\n         * Append all descendants of the given object to an array (in tree order).\n         *\n         * * `O(n)` where `n` is the amount of objects in the sub-tree of the given `object`\n         *\n         * @method treeToArray\n         * @memberOf module:symbol-tree#\n         * @param {Object} root\n         * @param {Object} [options]\n         * @param {Object[]} [options.array=[]]\n         * @param {Function} [options.filter] Function to test each object before it is added to the array.\n         *                            Invoked with arguments (object). Should return `true` if an object\n         *                            is to be included.\n         * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\n         * @return {Object[]}\n         */\n        treeToArray(root, options) {\n                const array   = (options && options.array) || [];\n                const filter  = (options && options.filter) || returnTrue;\n                const thisArg = (options && options.thisArg) || undefined;\n\n                let object = root;\n\n                while (object) {\n                        if (filter.call(thisArg, object)) {\n                                array.push(object);\n                        }\n                        object = this.following(object, {root: root});\n                }\n\n                return array;\n        }\n\n        /**\n         * Iterate over all children of the given object\n         *\n         * * `O(1)` for a single iteration\n         *\n         * @method childrenIterator\n         * @memberOf module:symbol-tree#\n         * @param {Object} parent\n         * @param {Object} [options]\n         * @param {Boolean} [options.reverse=false]\n         * @return {Object} An iterable iterator (ES6)\n         */\n        childrenIterator(parent, options) {\n                const reverse = options && options.reverse;\n                const parentNode = this._node(parent);\n\n                return new TreeIterator(\n                        this,\n                        parent,\n                        reverse ? parentNode.lastChild : parentNode.firstChild,\n                        reverse ? TreeIterator.PREV : TreeIterator.NEXT\n                );\n        }\n\n        /**\n         * Iterate over all the previous siblings of the given object. (in reverse tree order)\n         *\n         * * `O(1)` for a single iteration\n         *\n         * @method previousSiblingsIterator\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object} An iterable iterator (ES6)\n         */\n        previousSiblingsIterator(object) {\n                return new TreeIterator(\n                        this,\n                        object,\n                        this._node(object).previousSibling,\n                        TreeIterator.PREV\n                );\n        }\n\n        /**\n         * Iterate over all the next siblings of the given object. (in tree order)\n         *\n         * * `O(1)` for a single iteration\n         *\n         * @method nextSiblingsIterator\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object} An iterable iterator (ES6)\n         */\n        nextSiblingsIterator(object) {\n                return new TreeIterator(\n                        this,\n                        object,\n                        this._node(object).nextSibling,\n                        TreeIterator.NEXT\n                );\n        }\n\n        /**\n         * Iterate over all inclusive ancestors of the given object\n         *\n         * * `O(1)` for a single iteration\n         *\n         * @method ancestorsIterator\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object} An iterable iterator (ES6)\n         */\n        ancestorsIterator(object) {\n                return new TreeIterator(\n                        this,\n                        object,\n                        object,\n                        TreeIterator.PARENT\n                );\n        }\n\n        /**\n         * Iterate over all descendants of the given object (in tree order).\n         *\n         * Where `n` is the amount of objects in the sub-tree of the given `root`:\n         *\n         * * `O(n)` (worst case for a single iteration)\n         * * `O(n)` (amortized, when completing the iterator)\n         *\n         * @method treeIterator\n         * @memberOf module:symbol-tree#\n         * @param {Object} root\n         * @param {Object} options\n         * @param {Boolean} [options.reverse=false]\n         * @return {Object} An iterable iterator (ES6)\n         */\n        treeIterator(root, options) {\n                const reverse = options && options.reverse;\n\n                return new TreeIterator(\n                        this,\n                        root,\n                        reverse ? this.lastInclusiveDescendant(root) : root,\n                        reverse ? TreeIterator.PRECEDING : TreeIterator.FOLLOWING\n                );\n        }\n\n        /**\n         * Find the index of the given object (the number of preceding siblings).\n         *\n         * * `O(n)` where `n` is the amount of preceding siblings\n         * * `O(1)` (amortized, if the tree is not modified)\n         *\n         * @method index\n         * @memberOf module:symbol-tree#\n         * @param {Object} child\n         * @return {Number} The number of preceding siblings, or -1 if the object has no parent\n         */\n        index(child) {\n                const childNode = this._node(child);\n                const parentNode = this._node(childNode.parent);\n\n                if (!parentNode) {\n                        // In principal, you could also find out the number of preceding siblings\n                        // for objects that do not have a parent. This method limits itself only to\n                        // objects that have a parent because that lets us optimize more.\n                        return -1;\n                }\n\n                let currentIndex = childNode.getCachedIndex(parentNode);\n\n                if (currentIndex >= 0) {\n                        return currentIndex;\n                }\n\n                currentIndex = 0;\n                let object = parentNode.firstChild;\n\n                if (parentNode.childIndexCachedUpTo) {\n                        const cachedUpToNode = this._node(parentNode.childIndexCachedUpTo);\n                        object = cachedUpToNode.nextSibling;\n                        currentIndex = cachedUpToNode.getCachedIndex(parentNode) + 1;\n                }\n\n                while (object) {\n                        const node = this._node(object);\n                        node.setCachedIndex(parentNode, currentIndex);\n\n                        if (object === child) {\n                                break;\n                        }\n\n                        ++currentIndex;\n                        object = node.nextSibling;\n                }\n\n                parentNode.childIndexCachedUpTo = child;\n\n                return currentIndex;\n        }\n\n        /**\n         * Calculate the number of children.\n         *\n         * * `O(n)` where `n` is the amount of children\n         * * `O(1)` (amortized, if the tree is not modified)\n         *\n         * @method childrenCount\n         * @memberOf module:symbol-tree#\n         * @param {Object} parent\n         * @return {Number}\n         */\n        childrenCount(parent) {\n                const parentNode = this._node(parent);\n\n                if (!parentNode.lastChild) {\n                        return 0;\n                }\n\n                return this.index(parentNode.lastChild) + 1;\n        }\n\n        /**\n         * Compare the position of an object relative to another object. A bit set is returned:\n         *\n         * <ul>\n         *     <li>DISCONNECTED : 1</li>\n         *     <li>PRECEDING : 2</li>\n         *     <li>FOLLOWING : 4</li>\n         *     <li>CONTAINS : 8</li>\n         *     <li>CONTAINED_BY : 16</li>\n         * </ul>\n         *\n         * The semantics are the same as compareDocumentPosition in DOM, with the exception that\n         * DISCONNECTED never occurs with any other bit.\n         *\n         * where `n` and `m` are the amount of ancestors of `left` and `right`;\n         * where `o` is the amount of children of the lowest common ancestor of `left` and `right`:\n         *\n         * * `O(n + m + o)` (worst case)\n         * * `O(n + m)` (amortized, if the tree is not modified)\n         *\n         * @method compareTreePosition\n         * @memberOf module:symbol-tree#\n         * @param {Object} left\n         * @param {Object} right\n         * @return {Number}\n         */\n        compareTreePosition(left, right) {\n                // In DOM terms:\n                // left = reference / context object\n                // right = other\n\n                if (left === right) {\n                        return 0;\n                }\n\n                /* jshint -W016 */\n\n                const leftAncestors = []; { // inclusive\n                        let leftAncestor = left;\n\n                        while (leftAncestor) {\n                                if (leftAncestor === right) {\n                                        return TreePosition.CONTAINS | TreePosition.PRECEDING;\n                                        // other is ancestor of reference\n                                }\n\n                                leftAncestors.push(leftAncestor);\n                                leftAncestor = this.parent(leftAncestor);\n                        }\n                }\n\n\n                const rightAncestors = []; {\n                        let rightAncestor = right;\n\n                        while (rightAncestor) {\n                                if (rightAncestor === left) {\n                                        return TreePosition.CONTAINED_BY | TreePosition.FOLLOWING;\n                                }\n\n                                rightAncestors.push(rightAncestor);\n                                rightAncestor = this.parent(rightAncestor);\n                        }\n                }\n\n\n                const root = reverseArrayIndex(leftAncestors, 0);\n\n                if (!root || root !== reverseArrayIndex(rightAncestors, 0)) {\n                        // note: unlike DOM, preceding / following is not set here\n                        return TreePosition.DISCONNECTED;\n                }\n\n                // find the lowest common ancestor\n                let commonAncestorIndex = 0;\n                const ancestorsMinLength = Math.min(leftAncestors.length, rightAncestors.length);\n\n                for (let i = 0; i < ancestorsMinLength; ++i) {\n                        const leftAncestor  = reverseArrayIndex(leftAncestors, i);\n                        const rightAncestor = reverseArrayIndex(rightAncestors, i);\n\n                        if (leftAncestor !== rightAncestor) {\n                                break;\n                        }\n\n                        commonAncestorIndex = i;\n                }\n\n                // indexes within the common ancestor\n                const leftIndex  = this.index(reverseArrayIndex(leftAncestors, commonAncestorIndex + 1));\n                const rightIndex = this.index(reverseArrayIndex(rightAncestors, commonAncestorIndex + 1));\n\n                return rightIndex < leftIndex\n                        ? TreePosition.PRECEDING\n                        : TreePosition.FOLLOWING;\n        }\n\n        /**\n         * Remove the object from this tree.\n         * Has no effect if already removed.\n         *\n         * * `O(1)`\n         *\n         * @method remove\n         * @memberOf module:symbol-tree#\n         * @param {Object} removeObject\n         * @return {Object} removeObject\n         */\n        remove(removeObject) {\n                const removeNode = this._node(removeObject);\n                const parentNode = this._node(removeNode.parent);\n                const prevNode = this._node(removeNode.previousSibling);\n                const nextNode = this._node(removeNode.nextSibling);\n\n                if (parentNode) {\n                        if (parentNode.firstChild === removeObject) {\n                                parentNode.firstChild = removeNode.nextSibling;\n                        }\n\n                        if (parentNode.lastChild === removeObject) {\n                                parentNode.lastChild = removeNode.previousSibling;\n                        }\n                }\n\n                if (prevNode) {\n                        prevNode.nextSibling = removeNode.nextSibling;\n                }\n\n                if (nextNode) {\n                        nextNode.previousSibling = removeNode.previousSibling;\n                }\n\n                removeNode.parent = null;\n                removeNode.previousSibling = null;\n                removeNode.nextSibling = null;\n                removeNode.cachedIndex = -1;\n                removeNode.cachedIndexVersion = NaN;\n\n                if (parentNode) {\n                        parentNode.childrenChanged();\n                }\n\n                return removeObject;\n        }\n\n        /**\n         * Insert the given object before the reference object.\n         * `newObject` is now the previous sibling of `referenceObject`.\n         *\n         * * `O(1)`\n         *\n         * @method insertBefore\n         * @memberOf module:symbol-tree#\n         * @param {Object} referenceObject\n         * @param {Object} newObject\n         * @throws {Error} If the newObject is already present in this SymbolTree\n         * @return {Object} newObject\n         */\n        insertBefore(referenceObject, newObject) {\n                const referenceNode = this._node(referenceObject);\n                const prevNode = this._node(referenceNode.previousSibling);\n                const newNode = this._node(newObject);\n                const parentNode = this._node(referenceNode.parent);\n\n                if (newNode.isAttached) {\n                        throw Error('Given object is already present in this SymbolTree, remove it first');\n                }\n\n                newNode.parent = referenceNode.parent;\n                newNode.previousSibling = referenceNode.previousSibling;\n                newNode.nextSibling = referenceObject;\n                referenceNode.previousSibling = newObject;\n\n                if (prevNode) {\n                        prevNode.nextSibling = newObject;\n                }\n\n                if (parentNode && parentNode.firstChild === referenceObject) {\n                        parentNode.firstChild = newObject;\n                }\n\n                if (parentNode) {\n                        parentNode.childrenChanged();\n                }\n\n                return newObject;\n        }\n\n        /**\n         * Insert the given object after the reference object.\n         * `newObject` is now the next sibling of `referenceObject`.\n         *\n         * * `O(1)`\n         *\n         * @method insertAfter\n         * @memberOf module:symbol-tree#\n         * @param {Object} referenceObject\n         * @param {Object} newObject\n         * @throws {Error} If the newObject is already present in this SymbolTree\n         * @return {Object} newObject\n         */\n        insertAfter(referenceObject, newObject) {\n                const referenceNode = this._node(referenceObject);\n                const nextNode = this._node(referenceNode.nextSibling);\n                const newNode = this._node(newObject);\n                const parentNode = this._node(referenceNode.parent);\n\n                if (newNode.isAttached) {\n                        throw Error('Given object is already present in this SymbolTree, remove it first');\n                }\n\n                newNode.parent = referenceNode.parent;\n                newNode.previousSibling = referenceObject;\n                newNode.nextSibling = referenceNode.nextSibling;\n                referenceNode.nextSibling = newObject;\n\n                if (nextNode) {\n                        nextNode.previousSibling = newObject;\n                }\n\n                if (parentNode && parentNode.lastChild === referenceObject) {\n                        parentNode.lastChild = newObject;\n                }\n\n                if (parentNode) {\n                        parentNode.childrenChanged();\n                }\n\n                return newObject;\n        }\n\n        /**\n         * Insert the given object as the first child of the given reference object.\n         * `newObject` is now the first child of `referenceObject`.\n         *\n         * * `O(1)`\n         *\n         * @method prependChild\n         * @memberOf module:symbol-tree#\n         * @param {Object} referenceObject\n         * @param {Object} newObject\n         * @throws {Error} If the newObject is already present in this SymbolTree\n         * @return {Object} newObject\n         */\n        prependChild(referenceObject, newObject) {\n                const referenceNode = this._node(referenceObject);\n                const newNode = this._node(newObject);\n\n                if (newNode.isAttached) {\n                        throw Error('Given object is already present in this SymbolTree, remove it first');\n                }\n\n                if (referenceNode.hasChildren) {\n                        this.insertBefore(referenceNode.firstChild, newObject);\n                }\n                else {\n                        newNode.parent = referenceObject;\n                        referenceNode.firstChild = newObject;\n                        referenceNode.lastChild = newObject;\n                        referenceNode.childrenChanged();\n                }\n\n                return newObject;\n        }\n\n        /**\n         * Insert the given object as the last child of the given reference object.\n         * `newObject` is now the last child of `referenceObject`.\n         *\n         * * `O(1)`\n         *\n         * @method appendChild\n         * @memberOf module:symbol-tree#\n         * @param {Object} referenceObject\n         * @param {Object} newObject\n         * @throws {Error} If the newObject is already present in this SymbolTree\n         * @return {Object} newObject\n         */\n        appendChild(referenceObject, newObject) {\n                const referenceNode = this._node(referenceObject);\n                const newNode = this._node(newObject);\n\n                if (newNode.isAttached) {\n                        throw Error('Given object is already present in this SymbolTree, remove it first');\n                }\n\n                if (referenceNode.hasChildren) {\n                        this.insertAfter(referenceNode.lastChild, newObject);\n                }\n                else {\n                        newNode.parent = referenceObject;\n                        referenceNode.firstChild = newObject;\n                        referenceNode.lastChild = newObject;\n                        referenceNode.childrenChanged();\n                }\n\n                return newObject;\n        }\n}\n\nmodule.exports = SymbolTree;\nSymbolTree.TreePosition = TreePosition;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}