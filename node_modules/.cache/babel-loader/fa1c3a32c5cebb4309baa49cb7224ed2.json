{"ast":null,"code":"\"use strict\"; // This files implements the calculation of the offset between the global monotonic clock and UNIX time. This value is\n// known as |t1| in the calculation of \"time origin timestamp\" in the spec. This value needs to be calculated once and\n// can be used in all subsequent Performance instances.\n//\n// However, if the clock is not fast enough, the export is undefined to signify that we should use Date.now() to get the\n// time origin timestamp with millisecond accuracy, per spec.\n\nconst {\n  getGlobalMonotonicClockMS\n} = require(\"./global-monotonic-clock\");\n\nconst clockIsAccurate = require(\"./clock-is-accurate\"); // This function assumes the clock is accurate.\n\n\nfunction calculateClockOffset() {\n  const start = Date.now();\n  let cur = start; // Limit the iterations, just in case we're running in an environment where Date.now() has been mocked and is\n  // constant.\n\n  for (let i = 0; i < 1e6 && cur === start; i++) {\n    cur = Date.now();\n  } // At this point |cur| \"just\" became equal to the next millisecond -- the unseen digits after |cur| are approximately\n  // all 0, and |cur| is the closest to the actual value of the UNIX time. Now, get the current global monotonic clock\n  // value and do the remaining calculations.\n\n\n  return cur - getGlobalMonotonicClockMS();\n}\n\nif (clockIsAccurate) {\n  // Warm up the function.\n  calculateClockOffset();\n  calculateClockOffset();\n  calculateClockOffset();\n  module.exports = calculateClockOffset;\n} else {\n  module.exports = undefined;\n}","map":{"version":3,"names":["getGlobalMonotonicClockMS","require","clockIsAccurate","calculateClockOffset","start","Date","now","cur","i","module","exports","undefined"],"sources":["C:/Users/17033/balmco/node_modules/w3c-hr-time/lib/calculate-clock-offset.js"],"sourcesContent":["\"use strict\";\n\n// This files implements the calculation of the offset between the global monotonic clock and UNIX time. This value is\n// known as |t1| in the calculation of \"time origin timestamp\" in the spec. This value needs to be calculated once and\n// can be used in all subsequent Performance instances.\n//\n// However, if the clock is not fast enough, the export is undefined to signify that we should use Date.now() to get the\n// time origin timestamp with millisecond accuracy, per spec.\n\nconst { getGlobalMonotonicClockMS } = require(\"./global-monotonic-clock\");\nconst clockIsAccurate = require(\"./clock-is-accurate\");\n\n// This function assumes the clock is accurate.\nfunction calculateClockOffset() {\n  const start = Date.now();\n  let cur = start;\n  // Limit the iterations, just in case we're running in an environment where Date.now() has been mocked and is\n  // constant.\n  for (let i = 0; i < 1e6 && cur === start; i++) {\n    cur = Date.now();\n  }\n\n  // At this point |cur| \"just\" became equal to the next millisecond -- the unseen digits after |cur| are approximately\n  // all 0, and |cur| is the closest to the actual value of the UNIX time. Now, get the current global monotonic clock\n  // value and do the remaining calculations.\n\n  return cur - getGlobalMonotonicClockMS();\n}\n\nif (clockIsAccurate) {\n  // Warm up the function.\n  calculateClockOffset();\n  calculateClockOffset();\n  calculateClockOffset();\n\n  module.exports = calculateClockOffset;\n} else {\n  module.exports = undefined;\n}\n"],"mappings":"AAAA,a,CAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM;EAAEA;AAAF,IAAgCC,OAAO,CAAC,0BAAD,CAA7C;;AACA,MAAMC,eAAe,GAAGD,OAAO,CAAC,qBAAD,CAA/B,C,CAEA;;;AACA,SAASE,oBAAT,GAAgC;EAC9B,MAAMC,KAAK,GAAGC,IAAI,CAACC,GAAL,EAAd;EACA,IAAIC,GAAG,GAAGH,KAAV,CAF8B,CAG9B;EACA;;EACA,KAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,GAAJ,IAAWD,GAAG,KAAKH,KAAnC,EAA0CI,CAAC,EAA3C,EAA+C;IAC7CD,GAAG,GAAGF,IAAI,CAACC,GAAL,EAAN;EACD,CAP6B,CAS9B;EACA;EACA;;;EAEA,OAAOC,GAAG,GAAGP,yBAAyB,EAAtC;AACD;;AAED,IAAIE,eAAJ,EAAqB;EACnB;EACAC,oBAAoB;EACpBA,oBAAoB;EACpBA,oBAAoB;EAEpBM,MAAM,CAACC,OAAP,GAAiBP,oBAAjB;AACD,CAPD,MAOO;EACLM,MAAM,CAACC,OAAP,GAAiBC,SAAjB;AACD"},"metadata":{},"sourceType":"script"}