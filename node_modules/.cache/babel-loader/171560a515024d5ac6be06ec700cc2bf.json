{"ast":null,"code":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\n\nconst notImplemented = require(\"../../browser/not-implemented\");\n\nconst idlUtils = require(\"../generated/utils\");\n\nconst {\n  Canvas\n} = require(\"../../utils\");\n\nclass HTMLCanvasElementImpl extends HTMLElementImpl {\n  _attrModified(name, value, oldValue) {\n    if (this._canvas && (name === \"width\" || name === \"height\")) {\n      this._canvas[name] = parseInt(value);\n    }\n\n    super._attrModified(name, value, oldValue);\n  }\n\n  _getCanvas() {\n    if (Canvas && !this._canvas) {\n      this._canvas = Canvas.createCanvas(this.width, this.height);\n    }\n\n    return this._canvas;\n  }\n\n  getContext(contextId) {\n    const canvas = this._getCanvas();\n\n    if (canvas) {\n      if (!this._context) {\n        this._context = canvas.getContext(contextId) || null;\n\n        if (this._context) {\n          // Override the native canvas reference with our wrapper. This is the\n          // reason why we need to locally cache _context, since each call to\n          // canvas.getContext(contextId) would replace this reference again.\n          // Perhaps in the longer term, a better solution would be to create a\n          // full wrapper for the Context object as well.\n          this._context.canvas = idlUtils.wrapperForImpl(this);\n          wrapNodeCanvasMethod(this._context, \"createPattern\");\n          wrapNodeCanvasMethod(this._context, \"drawImage\");\n        }\n      }\n\n      return this._context;\n    }\n\n    notImplemented(\"HTMLCanvasElement.prototype.getContext (without installing the canvas npm package)\", this._ownerDocument._defaultView);\n    return null;\n  }\n\n  toDataURL() {\n    const canvas = this._getCanvas();\n\n    if (canvas) {\n      return canvas.toDataURL(...arguments);\n    }\n\n    notImplemented(\"HTMLCanvasElement.prototype.toDataURL (without installing the canvas npm package)\", this._ownerDocument._defaultView);\n    return null;\n  }\n\n  toBlob(callback, type, qualityArgument) {\n    const window = this._ownerDocument._defaultView;\n\n    const canvas = this._getCanvas();\n\n    if (canvas) {\n      const options = {};\n\n      switch (type) {\n        case \"image/jpg\":\n        case \"image/jpeg\":\n          type = \"image/jpeg\";\n          options.quality = qualityArgument;\n          break;\n\n        default:\n          type = \"image/png\";\n      }\n\n      canvas.toBuffer((err, buff) => {\n        if (err) {\n          throw err;\n        }\n\n        callback(new window.Blob([buff], {\n          type\n        }));\n      }, type, options);\n    } else {\n      notImplemented(\"HTMLCanvasElement.prototype.toBlob (without installing the canvas npm package)\", window);\n    }\n  }\n\n  get width() {\n    const parsed = parseInt(this.getAttributeNS(null, \"width\"));\n    return isNaN(parsed) || parsed < 0 || parsed > 2147483647 ? 300 : parsed;\n  }\n\n  set width(v) {\n    v = v > 2147483647 ? 300 : v;\n    this.setAttributeNS(null, \"width\", String(v));\n  }\n\n  get height() {\n    const parsed = parseInt(this.getAttributeNS(null, \"height\"));\n    return isNaN(parsed) || parsed < 0 || parsed > 2147483647 ? 150 : parsed;\n  }\n\n  set height(v) {\n    v = v > 2147483647 ? 150 : v;\n    this.setAttributeNS(null, \"height\", String(v));\n  }\n\n} // We need to wrap the methods that receive an image or canvas object\n// (luckily, always as the first argument), so that these objects can be\n// unwrapped an the expected types passed.\n\n\nfunction wrapNodeCanvasMethod(ctx, name) {\n  const prev = ctx[name];\n\n  ctx[name] = function (image) {\n    const impl = idlUtils.implForWrapper(image);\n\n    if (impl) {\n      if (impl instanceof HTMLCanvasElementImpl && !impl._canvas) {\n        impl._getCanvas();\n      }\n\n      image = impl._image || impl._canvas;\n    }\n\n    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      rest[_key - 1] = arguments[_key];\n    }\n\n    return prev.call(ctx, image, ...rest);\n  };\n}\n\nmodule.exports = {\n  implementation: HTMLCanvasElementImpl\n};","map":{"version":3,"names":["HTMLElementImpl","require","implementation","notImplemented","idlUtils","Canvas","HTMLCanvasElementImpl","_attrModified","name","value","oldValue","_canvas","parseInt","_getCanvas","createCanvas","width","height","getContext","contextId","canvas","_context","wrapperForImpl","wrapNodeCanvasMethod","_ownerDocument","_defaultView","toDataURL","toBlob","callback","type","qualityArgument","window","options","quality","toBuffer","err","buff","Blob","parsed","getAttributeNS","isNaN","v","setAttributeNS","String","ctx","prev","image","impl","implForWrapper","_image","rest","call","module","exports"],"sources":["C:/Users/17033/balmco/node_modules/jsdom/lib/jsdom/living/nodes/HTMLCanvasElement-impl.js"],"sourcesContent":["\"use strict\";\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst notImplemented = require(\"../../browser/not-implemented\");\nconst idlUtils = require(\"../generated/utils\");\nconst { Canvas } = require(\"../../utils\");\n\nclass HTMLCanvasElementImpl extends HTMLElementImpl {\n  _attrModified(name, value, oldValue) {\n    if (this._canvas && (name === \"width\" || name === \"height\")) {\n      this._canvas[name] = parseInt(value);\n    }\n\n    super._attrModified(name, value, oldValue);\n  }\n\n  _getCanvas() {\n    if (Canvas && !this._canvas) {\n      this._canvas = Canvas.createCanvas(this.width, this.height);\n    }\n    return this._canvas;\n  }\n\n  getContext(contextId) {\n    const canvas = this._getCanvas();\n    if (canvas) {\n      if (!this._context) {\n        this._context = canvas.getContext(contextId) || null;\n        if (this._context) {\n          // Override the native canvas reference with our wrapper. This is the\n          // reason why we need to locally cache _context, since each call to\n          // canvas.getContext(contextId) would replace this reference again.\n          // Perhaps in the longer term, a better solution would be to create a\n          // full wrapper for the Context object as well.\n          this._context.canvas = idlUtils.wrapperForImpl(this);\n          wrapNodeCanvasMethod(this._context, \"createPattern\");\n          wrapNodeCanvasMethod(this._context, \"drawImage\");\n        }\n      }\n      return this._context;\n    }\n\n    notImplemented(\n      \"HTMLCanvasElement.prototype.getContext (without installing the canvas npm package)\",\n      this._ownerDocument._defaultView\n    );\n    return null;\n  }\n\n  toDataURL(...args) {\n    const canvas = this._getCanvas();\n    if (canvas) {\n      return canvas.toDataURL(...args);\n    }\n\n    notImplemented(\n      \"HTMLCanvasElement.prototype.toDataURL (without installing the canvas npm package)\",\n      this._ownerDocument._defaultView\n    );\n    return null;\n  }\n\n  toBlob(callback, type, qualityArgument) {\n    const window = this._ownerDocument._defaultView;\n    const canvas = this._getCanvas();\n    if (canvas) {\n      const options = {};\n      switch (type) {\n        case \"image/jpg\":\n        case \"image/jpeg\":\n          type = \"image/jpeg\";\n          options.quality = qualityArgument;\n          break;\n        default:\n          type = \"image/png\";\n      }\n      canvas.toBuffer((err, buff) => {\n        if (err) {\n          throw err;\n        }\n        callback(new window.Blob([buff], { type }));\n      }, type, options);\n    } else {\n      notImplemented(\n        \"HTMLCanvasElement.prototype.toBlob (without installing the canvas npm package)\",\n        window\n      );\n    }\n  }\n\n  get width() {\n    const parsed = parseInt(this.getAttributeNS(null, \"width\"));\n    return isNaN(parsed) || parsed < 0 || parsed > 2147483647 ? 300 : parsed;\n  }\n\n  set width(v) {\n    v = v > 2147483647 ? 300 : v;\n    this.setAttributeNS(null, \"width\", String(v));\n  }\n\n  get height() {\n    const parsed = parseInt(this.getAttributeNS(null, \"height\"));\n    return isNaN(parsed) || parsed < 0 || parsed > 2147483647 ? 150 : parsed;\n  }\n\n  set height(v) {\n    v = v > 2147483647 ? 150 : v;\n    this.setAttributeNS(null, \"height\", String(v));\n  }\n}\n\n// We need to wrap the methods that receive an image or canvas object\n// (luckily, always as the first argument), so that these objects can be\n// unwrapped an the expected types passed.\nfunction wrapNodeCanvasMethod(ctx, name) {\n  const prev = ctx[name];\n  ctx[name] = function (image, ...rest) {\n    const impl = idlUtils.implForWrapper(image);\n    if (impl) {\n      if (impl instanceof HTMLCanvasElementImpl && !impl._canvas) {\n        impl._getCanvas();\n      }\n      image = impl._image || impl._canvas;\n    }\n    return prev.call(ctx, image, ...rest);\n  };\n}\n\nmodule.exports = {\n  implementation: HTMLCanvasElementImpl\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}