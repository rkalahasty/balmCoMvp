{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ed5 = require(\"xmlchars/xml/1.0/ed5\");\n\nconst ed2 = require(\"xmlchars/xml/1.1/ed2\");\n\nconst NSed3 = require(\"xmlchars/xmlns/1.0/ed3\");\n\nvar isS = ed5.isS;\nvar isChar10 = ed5.isChar;\nvar isNameStartChar = ed5.isNameStartChar;\nvar isNameChar = ed5.isNameChar;\nvar S_LIST = ed5.S_LIST;\nvar NAME_RE = ed5.NAME_RE;\nvar isChar11 = ed2.isChar;\nvar isNCNameStartChar = NSed3.isNCNameStartChar;\nvar isNCNameChar = NSed3.isNCNameChar;\nvar NC_NAME_RE = NSed3.NC_NAME_RE;\nconst XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\nconst XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\";\nconst rootNS = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  __proto__: null,\n  xml: XML_NAMESPACE,\n  xmlns: XMLNS_NAMESPACE\n};\nconst XML_ENTITIES = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  __proto__: null,\n  amp: \"&\",\n  gt: \">\",\n  lt: \"<\",\n  quot: \"\\\"\",\n  apos: \"'\"\n}; // EOC: end-of-chunk\n\nconst EOC = -1;\nconst NL_LIKE = -2;\nconst S_BEGIN = 0; // Initial state.\n\nconst S_BEGIN_WHITESPACE = 1; // leading whitespace\n\nconst S_DOCTYPE = 2; // <!DOCTYPE\n\nconst S_DOCTYPE_QUOTE = 3; // <!DOCTYPE \"//blah\n\nconst S_DTD = 4; // <!DOCTYPE \"//blah\" [ ...\n\nconst S_DTD_QUOTED = 5; // <!DOCTYPE \"//blah\" [ \"foo\n\nconst S_DTD_OPEN_WAKA = 6;\nconst S_DTD_OPEN_WAKA_BANG = 7;\nconst S_DTD_COMMENT = 8; // <!--\n\nconst S_DTD_COMMENT_ENDING = 9; // <!-- blah -\n\nconst S_DTD_COMMENT_ENDED = 10; // <!-- blah --\n\nconst S_DTD_PI = 11; // <?\n\nconst S_DTD_PI_ENDING = 12; // <?hi \"there\" ?\n\nconst S_TEXT = 13; // general stuff\n\nconst S_ENTITY = 14; // &amp and such\n\nconst S_OPEN_WAKA = 15; // <\n\nconst S_OPEN_WAKA_BANG = 16; // <!...\n\nconst S_COMMENT = 17; // <!--\n\nconst S_COMMENT_ENDING = 18; // <!-- blah -\n\nconst S_COMMENT_ENDED = 19; // <!-- blah --\n\nconst S_CDATA = 20; // <![CDATA[ something\n\nconst S_CDATA_ENDING = 21; // ]\n\nconst S_CDATA_ENDING_2 = 22; // ]]\n\nconst S_PI_FIRST_CHAR = 23; // <?hi, first char\n\nconst S_PI_REST = 24; // <?hi, rest of the name\n\nconst S_PI_BODY = 25; // <?hi there\n\nconst S_PI_ENDING = 26; // <?hi \"there\" ?\n\nconst S_XML_DECL_NAME_START = 27; // <?xml\n\nconst S_XML_DECL_NAME = 28; // <?xml foo\n\nconst S_XML_DECL_EQ = 29; // <?xml foo=\n\nconst S_XML_DECL_VALUE_START = 30; // <?xml foo=\n\nconst S_XML_DECL_VALUE = 31; // <?xml foo=\"bar\"\n\nconst S_XML_DECL_SEPARATOR = 32; // <?xml foo=\"bar\"\n\nconst S_XML_DECL_ENDING = 33; // <?xml ... ?\n\nconst S_OPEN_TAG = 34; // <strong\n\nconst S_OPEN_TAG_SLASH = 35; // <strong /\n\nconst S_ATTRIB = 36; // <a\n\nconst S_ATTRIB_NAME = 37; // <a foo\n\nconst S_ATTRIB_NAME_SAW_WHITE = 38; // <a foo _\n\nconst S_ATTRIB_VALUE = 39; // <a foo=\n\nconst S_ATTRIB_VALUE_QUOTED = 40; // <a foo=\"bar\n\nconst S_ATTRIB_VALUE_CLOSED = 41; // <a foo=\"bar\"\n\nconst S_ATTRIB_VALUE_UNQUOTED = 42; // <a foo=bar\n\nconst S_CLOSE_TAG = 43; // </a\n\nconst S_CLOSE_TAG_SAW_WHITE = 44; // </a   >\n\nconst TAB = 9;\nconst NL = 0xA;\nconst CR = 0xD;\nconst SPACE = 0x20;\nconst BANG = 0x21;\nconst DQUOTE = 0x22;\nconst AMP = 0x26;\nconst SQUOTE = 0x27;\nconst MINUS = 0x2D;\nconst FORWARD_SLASH = 0x2F;\nconst SEMICOLON = 0x3B;\nconst LESS = 0x3C;\nconst EQUAL = 0x3D;\nconst GREATER = 0x3E;\nconst QUESTION = 0x3F;\nconst OPEN_BRACKET = 0x5B;\nconst CLOSE_BRACKET = 0x5D;\nconst NEL = 0x85;\nconst LS = 0x2028; // Line Separator\n\nconst isQuote = c => c === DQUOTE || c === SQUOTE;\n\nconst QUOTES = [DQUOTE, SQUOTE];\nconst DOCTYPE_TERMINATOR = [...QUOTES, OPEN_BRACKET, GREATER];\nconst DTD_TERMINATOR = [...QUOTES, LESS, CLOSE_BRACKET];\nconst XML_DECL_NAME_TERMINATOR = [EQUAL, QUESTION, ...S_LIST];\nconst ATTRIB_VALUE_UNQUOTED_TERMINATOR = [...S_LIST, GREATER, AMP, LESS];\n\nfunction nsPairCheck(parser, prefix, uri) {\n  switch (prefix) {\n    case \"xml\":\n      if (uri !== XML_NAMESPACE) {\n        parser.fail(`xml prefix must be bound to ${XML_NAMESPACE}.`);\n      }\n\n      break;\n\n    case \"xmlns\":\n      if (uri !== XMLNS_NAMESPACE) {\n        parser.fail(`xmlns prefix must be bound to ${XMLNS_NAMESPACE}.`);\n      }\n\n      break;\n\n    default:\n  }\n\n  switch (uri) {\n    case XMLNS_NAMESPACE:\n      parser.fail(prefix === \"\" ? `the default namespace may not be set to ${uri}.` : `may not assign a prefix (even \"xmlns\") to the URI \\\n${XMLNS_NAMESPACE}.`);\n      break;\n\n    case XML_NAMESPACE:\n      switch (prefix) {\n        case \"xml\":\n          // Assinging the XML namespace to \"xml\" is fine.\n          break;\n\n        case \"\":\n          parser.fail(`the default namespace may not be set to ${uri}.`);\n          break;\n\n        default:\n          parser.fail(\"may not assign the xml namespace to another prefix.\");\n      }\n\n      break;\n\n    default:\n  }\n}\n\nfunction nsMappingCheck(parser, mapping) {\n  for (const local of Object.keys(mapping)) {\n    nsPairCheck(parser, local, mapping[local]);\n  }\n}\n\nconst isNCName = name => NC_NAME_RE.test(name);\n\nconst isName = name => NAME_RE.test(name);\n\nconst FORBIDDEN_START = 0;\nconst FORBIDDEN_BRACKET = 1;\nconst FORBIDDEN_BRACKET_BRACKET = 2;\n/**\n * The list of supported events.\n */\n\nexports.EVENTS = [\"xmldecl\", \"text\", \"processinginstruction\", \"doctype\", \"comment\", \"opentagstart\", \"attribute\", \"opentag\", \"closetag\", \"cdata\", \"error\", \"end\", \"ready\"];\nconst EVENT_NAME_TO_HANDLER_NAME = {\n  xmldecl: \"xmldeclHandler\",\n  text: \"textHandler\",\n  processinginstruction: \"piHandler\",\n  doctype: \"doctypeHandler\",\n  comment: \"commentHandler\",\n  opentagstart: \"openTagStartHandler\",\n  attribute: \"attributeHandler\",\n  opentag: \"openTagHandler\",\n  closetag: \"closeTagHandler\",\n  cdata: \"cdataHandler\",\n  error: \"errorHandler\",\n  end: \"endHandler\",\n  ready: \"readyHandler\"\n};\n\nclass SaxesParser {\n  /**\n   * @param opt The parser options.\n   */\n  constructor(opt) {\n    this.opt = opt !== null && opt !== void 0 ? opt : {};\n    this.fragmentOpt = !!this.opt.fragment;\n    const xmlnsOpt = this.xmlnsOpt = !!this.opt.xmlns;\n    this.trackPosition = this.opt.position !== false;\n    this.fileName = this.opt.fileName;\n\n    if (xmlnsOpt) {\n      // This is the function we use to perform name checks on PIs and entities.\n      // When namespaces are used, colons are not allowed in PI target names or\n      // entity names. So the check depends on whether namespaces are used. See:\n      //\n      // https://www.w3.org/XML/xml-names-19990114-errata.html\n      // NE08\n      //\n      this.nameStartCheck = isNCNameStartChar;\n      this.nameCheck = isNCNameChar;\n      this.isName = isNCName; // eslint-disable-next-line @typescript-eslint/unbound-method\n\n      this.processAttribs = this.processAttribsNS; // eslint-disable-next-line @typescript-eslint/unbound-method\n\n      this.pushAttrib = this.pushAttribNS; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      this.ns = Object.assign({\n        __proto__: null\n      }, rootNS);\n      const additional = this.opt.additionalNamespaces;\n\n      if (additional != null) {\n        nsMappingCheck(this, additional);\n        Object.assign(this.ns, additional);\n      }\n    } else {\n      this.nameStartCheck = isNameStartChar;\n      this.nameCheck = isNameChar;\n      this.isName = isName; // eslint-disable-next-line @typescript-eslint/unbound-method\n\n      this.processAttribs = this.processAttribsPlain; // eslint-disable-next-line @typescript-eslint/unbound-method\n\n      this.pushAttrib = this.pushAttribPlain;\n    } //\n    // The order of the members in this table needs to correspond to the state\n    // numbers given to the states that correspond to the methods being recorded\n    // here.\n    //\n\n\n    this.stateTable = [\n    /* eslint-disable @typescript-eslint/unbound-method */\n    this.sBegin, this.sBeginWhitespace, this.sDoctype, this.sDoctypeQuote, this.sDTD, this.sDTDQuoted, this.sDTDOpenWaka, this.sDTDOpenWakaBang, this.sDTDComment, this.sDTDCommentEnding, this.sDTDCommentEnded, this.sDTDPI, this.sDTDPIEnding, this.sText, this.sEntity, this.sOpenWaka, this.sOpenWakaBang, this.sComment, this.sCommentEnding, this.sCommentEnded, this.sCData, this.sCDataEnding, this.sCDataEnding2, this.sPIFirstChar, this.sPIRest, this.sPIBody, this.sPIEnding, this.sXMLDeclNameStart, this.sXMLDeclName, this.sXMLDeclEq, this.sXMLDeclValueStart, this.sXMLDeclValue, this.sXMLDeclSeparator, this.sXMLDeclEnding, this.sOpenTag, this.sOpenTagSlash, this.sAttrib, this.sAttribName, this.sAttribNameSawWhite, this.sAttribValue, this.sAttribValueQuoted, this.sAttribValueClosed, this.sAttribValueUnquoted, this.sCloseTag, this.sCloseTagSawWhite];\n\n    this._init();\n  }\n  /**\n   * Indicates whether or not the parser is closed. If ``true``, wait for\n   * the ``ready`` event to write again.\n   */\n\n\n  get closed() {\n    return this._closed;\n  }\n\n  _init() {\n    var _a;\n\n    this.openWakaBang = \"\";\n    this.text = \"\";\n    this.name = \"\";\n    this.piTarget = \"\";\n    this.entity = \"\";\n    this.q = null;\n    this.tags = [];\n    this.tag = null;\n    this.topNS = null;\n    this.chunk = \"\";\n    this.chunkPosition = 0;\n    this.i = 0;\n    this.prevI = 0;\n    this.carriedFromPrevious = undefined;\n    this.forbiddenState = FORBIDDEN_START;\n    this.attribList = []; // The logic is organized so as to minimize the need to check\n    // this.opt.fragment while parsing.\n\n    const {\n      fragmentOpt\n    } = this;\n    this.state = fragmentOpt ? S_TEXT : S_BEGIN; // We want these to be all true if we are dealing with a fragment.\n\n    this.reportedTextBeforeRoot = this.reportedTextAfterRoot = this.closedRoot = this.sawRoot = fragmentOpt; // An XML declaration is intially possible only when parsing whole\n    // documents.\n\n    this.xmlDeclPossible = !fragmentOpt;\n    this.xmlDeclExpects = [\"version\"];\n    this.entityReturnState = undefined;\n    let {\n      defaultXMLVersion\n    } = this.opt;\n\n    if (defaultXMLVersion === undefined) {\n      if (this.opt.forceXMLVersion === true) {\n        throw new Error(\"forceXMLVersion set but defaultXMLVersion is not set\");\n      }\n\n      defaultXMLVersion = \"1.0\";\n    }\n\n    this.setXMLVersion(defaultXMLVersion);\n    this.positionAtNewLine = 0;\n    this.doctype = false;\n    this._closed = false;\n    this.xmlDecl = {\n      version: undefined,\n      encoding: undefined,\n      standalone: undefined\n    };\n    this.line = 1;\n    this.column = 0;\n    this.ENTITIES = Object.create(XML_ENTITIES); // eslint-disable-next-line no-unused-expressions\n\n    (_a = this.readyHandler) === null || _a === void 0 ? void 0 : _a.call(this);\n  }\n  /**\n   * The stream position the parser is currently looking at. This field is\n   * zero-based.\n   *\n   * This field is not based on counting Unicode characters but is to be\n   * interpreted as a plain index into a JavaScript string.\n   */\n\n\n  get position() {\n    return this.chunkPosition + this.i;\n  }\n  /**\n   * The column number of the next character to be read by the parser.  *\n   * This field is zero-based. (The first column in a line is 0.)\n   *\n   * This field reports the index at which the next character would be in the\n   * line if the line were represented as a JavaScript string.  Note that this\n   * *can* be different to a count based on the number of *Unicode characters*\n   * due to how JavaScript handles astral plane characters.\n   *\n   * See [[column]] for a number that corresponds to a count of Unicode\n   * characters.\n   */\n\n\n  get columnIndex() {\n    return this.position - this.positionAtNewLine;\n  }\n  /**\n   * Set an event listener on an event. The parser supports one handler per\n   * event type. If you try to set an event handler over an existing handler,\n   * the old handler is silently overwritten.\n   *\n   * @param name The event to listen to.\n   *\n   * @param handler The handler to set.\n   */\n\n\n  on(name, handler) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this[EVENT_NAME_TO_HANDLER_NAME[name]] = handler;\n  }\n  /**\n   * Unset an event handler.\n   *\n   * @parma name The event to stop listening to.\n   */\n\n\n  off(name) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this[EVENT_NAME_TO_HANDLER_NAME[name]] = undefined;\n  }\n  /**\n   * Make an error object. The error object will have a message that contains\n   * the ``fileName`` option passed at the creation of the parser. If position\n   * tracking was turned on, it will also have line and column number\n   * information.\n   *\n   * @param message The message describing the error to report.\n   *\n   * @returns An error object with a properly formatted message.\n   */\n\n\n  makeError(message) {\n    var _a;\n\n    let msg = (_a = this.fileName) !== null && _a !== void 0 ? _a : \"\";\n\n    if (this.trackPosition) {\n      if (msg.length > 0) {\n        msg += \":\";\n      }\n\n      msg += `${this.line}:${this.column}`;\n    }\n\n    if (msg.length > 0) {\n      msg += \": \";\n    }\n\n    return new Error(msg + message);\n  }\n  /**\n   * Report a parsing error. This method is made public so that client code may\n   * check for issues that are outside the scope of this project and can report\n   * errors.\n   *\n   * @param message The error to report.\n   *\n   * @returns this\n   */\n\n\n  fail(message) {\n    const err = this.makeError(message);\n    const handler = this.errorHandler;\n\n    if (handler === undefined) {\n      throw err;\n    } else {\n      handler(err);\n    }\n\n    return this;\n  }\n  /**\n   * Write a XML data to the parser.\n   *\n   * @param chunk The XML data to write.\n   *\n   * @returns this\n   */\n\n\n  write(chunk) {\n    if (this.closed) {\n      return this.fail(\"cannot write after close; assign an onready handler.\");\n    }\n\n    let end = false;\n\n    if (chunk === null) {\n      // We cannot return immediately because carriedFromPrevious may need\n      // processing.\n      end = true;\n      chunk = \"\";\n    } else if (typeof chunk === \"object\") {\n      chunk = chunk.toString();\n    } // We checked if performing a pre-decomposition of the string into an array\n    // of single complete characters (``Array.from(chunk)``) would be faster\n    // than the current repeated calls to ``charCodeAt``. As of August 2018, it\n    // isn't. (There may be Node-specific code that would perform faster than\n    // ``Array.from`` but don't want to be dependent on Node.)\n\n\n    if (this.carriedFromPrevious !== undefined) {\n      // The previous chunk had char we must carry over.\n      chunk = `${this.carriedFromPrevious}${chunk}`;\n      this.carriedFromPrevious = undefined;\n    }\n\n    let limit = chunk.length;\n    const lastCode = chunk.charCodeAt(limit - 1);\n\n    if (!end && ( // A trailing CR or surrogate must be carried over to the next\n    // chunk.\n    lastCode === CR || lastCode >= 0xD800 && lastCode <= 0xDBFF)) {\n      // The chunk ends with a character that must be carried over. We cannot\n      // know how to handle it until we get the next chunk or the end of the\n      // stream. So save it for later.\n      this.carriedFromPrevious = chunk[limit - 1];\n      limit--;\n      chunk = chunk.slice(0, limit);\n    }\n\n    const {\n      stateTable\n    } = this;\n    this.chunk = chunk;\n    this.i = 0;\n\n    while (this.i < limit) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      stateTable[this.state].call(this);\n    }\n\n    this.chunkPosition += limit;\n    return end ? this.end() : this;\n  }\n  /**\n   * Close the current stream. Perform final well-formedness checks and reset\n   * the parser tstate.\n   *\n   * @returns this\n   */\n\n\n  close() {\n    return this.write(null);\n  }\n  /**\n   * Get a single code point out of the current chunk. This updates the current\n   * position if we do position tracking.\n   *\n   * This is the algorithm to use for XML 1.0.\n   *\n   * @returns The character read.\n   */\n\n\n  getCode10() {\n    const {\n      chunk,\n      i\n    } = this;\n    this.prevI = i; // Yes, we do this instead of doing this.i++. Doing it this way, we do not\n    // read this.i again, which is a bit faster.\n\n    this.i = i + 1;\n\n    if (i >= chunk.length) {\n      return EOC;\n    } // Using charCodeAt and handling the surrogates ourselves is faster\n    // than using codePointAt.\n\n\n    const code = chunk.charCodeAt(i);\n    this.column++;\n\n    if (code < 0xD800) {\n      if (code >= SPACE || code === TAB) {\n        return code;\n      }\n\n      switch (code) {\n        case NL:\n          this.line++;\n          this.column = 0;\n          this.positionAtNewLine = this.position;\n          return NL;\n\n        case CR:\n          // We may get NaN if we read past the end of the chunk, which is fine.\n          if (chunk.charCodeAt(i + 1) === NL) {\n            // A \\r\\n sequence is converted to \\n so we have to skip over the\n            // next character. We already know it has a size of 1 so ++ is fine\n            // here.\n            this.i = i + 2;\n          } // Otherwise, a \\r is just converted to \\n, so we don't have to skip\n          // ahead.\n          // In either case, \\r becomes \\n.\n\n\n          this.line++;\n          this.column = 0;\n          this.positionAtNewLine = this.position;\n          return NL_LIKE;\n\n        default:\n          // If we get here, then code < SPACE and it is not NL CR or TAB.\n          this.fail(\"disallowed character.\");\n          return code;\n      }\n    }\n\n    if (code > 0xDBFF) {\n      // This is a specialized version of isChar10 that takes into account\n      // that in this context code > 0xDBFF and code <= 0xFFFF. So it does not\n      // test cases that don't need testing.\n      if (!(code >= 0xE000 && code <= 0xFFFD)) {\n        this.fail(\"disallowed character.\");\n      }\n\n      return code;\n    }\n\n    const final = 0x10000 + (code - 0xD800) * 0x400 + (chunk.charCodeAt(i + 1) - 0xDC00);\n    this.i = i + 2; // This is a specialized version of isChar10 that takes into account that in\n    // this context necessarily final >= 0x10000.\n\n    if (final > 0x10FFFF) {\n      this.fail(\"disallowed character.\");\n    }\n\n    return final;\n  }\n  /**\n   * Get a single code point out of the current chunk. This updates the current\n   * position if we do position tracking.\n   *\n   * This is the algorithm to use for XML 1.1.\n   *\n   * @returns {number} The character read.\n   */\n\n\n  getCode11() {\n    const {\n      chunk,\n      i\n    } = this;\n    this.prevI = i; // Yes, we do this instead of doing this.i++. Doing it this way, we do not\n    // read this.i again, which is a bit faster.\n\n    this.i = i + 1;\n\n    if (i >= chunk.length) {\n      return EOC;\n    } // Using charCodeAt and handling the surrogates ourselves is faster\n    // than using codePointAt.\n\n\n    const code = chunk.charCodeAt(i);\n    this.column++;\n\n    if (code < 0xD800) {\n      if (code > 0x1F && code < 0x7F || code > 0x9F && code !== LS || code === TAB) {\n        return code;\n      }\n\n      switch (code) {\n        case NL:\n          // 0xA\n          this.line++;\n          this.column = 0;\n          this.positionAtNewLine = this.position;\n          return NL;\n\n        case CR:\n          {\n            // 0xD\n            // We may get NaN if we read past the end of the chunk, which is\n            // fine.\n            const next = chunk.charCodeAt(i + 1);\n\n            if (next === NL || next === NEL) {\n              // A CR NL or CR NEL sequence is converted to NL so we have to skip\n              // over the next character. We already know it has a size of 1.\n              this.i = i + 2;\n            } // Otherwise, a CR is just converted to NL, no skip.\n\n          }\n\n        /* yes, fall through */\n\n        case NEL: // 0x85\n\n        case LS:\n          // Ox2028\n          this.line++;\n          this.column = 0;\n          this.positionAtNewLine = this.position;\n          return NL_LIKE;\n\n        default:\n          this.fail(\"disallowed character.\");\n          return code;\n      }\n    }\n\n    if (code > 0xDBFF) {\n      // This is a specialized version of isCharAndNotRestricted that takes into\n      // account that in this context code > 0xDBFF and code <= 0xFFFF. So it\n      // does not test cases that don't need testing.\n      if (!(code >= 0xE000 && code <= 0xFFFD)) {\n        this.fail(\"disallowed character.\");\n      }\n\n      return code;\n    }\n\n    const final = 0x10000 + (code - 0xD800) * 0x400 + (chunk.charCodeAt(i + 1) - 0xDC00);\n    this.i = i + 2; // This is a specialized version of isCharAndNotRestricted that takes into\n    // account that in this context necessarily final >= 0x10000.\n\n    if (final > 0x10FFFF) {\n      this.fail(\"disallowed character.\");\n    }\n\n    return final;\n  }\n  /**\n   * Like ``getCode`` but with the return value normalized so that ``NL`` is\n   * returned for ``NL_LIKE``.\n   */\n\n\n  getCodeNorm() {\n    const c = this.getCode();\n    return c === NL_LIKE ? NL : c;\n  }\n\n  unget() {\n    this.i = this.prevI;\n    this.column--;\n  }\n  /**\n   * Capture characters into a buffer until encountering one of a set of\n   * characters.\n   *\n   * @param chars An array of codepoints. Encountering a character in the array\n   * ends the capture. (``chars`` may safely contain ``NL``.)\n   *\n   * @return The character code that made the capture end, or ``EOC`` if we hit\n   * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n   * instead.\n   */\n\n\n  captureTo(chars) {\n    let {\n      i: start\n    } = this;\n    const {\n      chunk\n    } = this; // eslint-disable-next-line no-constant-condition\n\n    while (true) {\n      const c = this.getCode();\n      const isNLLike = c === NL_LIKE;\n      const final = isNLLike ? NL : c;\n\n      if (final === EOC || chars.includes(final)) {\n        this.text += chunk.slice(start, this.prevI);\n        return final;\n      }\n\n      if (isNLLike) {\n        this.text += `${chunk.slice(start, this.prevI)}\\n`;\n        start = this.i;\n      }\n    }\n  }\n  /**\n   * Capture characters into a buffer until encountering a character.\n   *\n   * @param char The codepoint that ends the capture. **NOTE ``char`` MAY NOT\n   * CONTAIN ``NL``.** Passing ``NL`` will result in buggy behavior.\n   *\n   * @return ``true`` if we ran into the character. Otherwise, we ran into the\n   * end of the current chunk.\n   */\n\n\n  captureToChar(char) {\n    let {\n      i: start\n    } = this;\n    const {\n      chunk\n    } = this; // eslint-disable-next-line no-constant-condition\n\n    while (true) {\n      let c = this.getCode();\n\n      switch (c) {\n        case NL_LIKE:\n          this.text += `${chunk.slice(start, this.prevI)}\\n`;\n          start = this.i;\n          c = NL;\n          break;\n\n        case EOC:\n          this.text += chunk.slice(start);\n          return false;\n\n        default:\n      }\n\n      if (c === char) {\n        this.text += chunk.slice(start, this.prevI);\n        return true;\n      }\n    }\n  }\n  /**\n   * Capture characters that satisfy ``isNameChar`` into the ``name`` field of\n   * this parser.\n   *\n   * @return The character code that made the test fail, or ``EOC`` if we hit\n   * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n   * instead.\n   */\n\n\n  captureNameChars() {\n    const {\n      chunk,\n      i: start\n    } = this; // eslint-disable-next-line no-constant-condition\n\n    while (true) {\n      const c = this.getCode();\n\n      if (c === EOC) {\n        this.name += chunk.slice(start);\n        return EOC;\n      } // NL is not a name char so we don't have to test specifically for it.\n\n\n      if (!isNameChar(c)) {\n        this.name += chunk.slice(start, this.prevI);\n        return c === NL_LIKE ? NL : c;\n      }\n    }\n  }\n  /**\n   * Skip white spaces.\n   *\n   * @return The character that ended the skip, or ``EOC`` if we hit\n   * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n   * instead.\n   */\n\n\n  skipSpaces() {\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const c = this.getCodeNorm();\n\n      if (c === EOC || !isS(c)) {\n        return c;\n      }\n    }\n  }\n\n  setXMLVersion(version) {\n    this.currentXMLVersion = version;\n    /*  eslint-disable @typescript-eslint/unbound-method */\n\n    if (version === \"1.0\") {\n      this.isChar = isChar10;\n      this.getCode = this.getCode10;\n    } else {\n      this.isChar = isChar11;\n      this.getCode = this.getCode11;\n    }\n    /* eslint-enable @typescript-eslint/unbound-method */\n\n  } // STATE ENGINE METHODS\n  // This needs to be a state separate from S_BEGIN_WHITESPACE because we want\n  // to be sure never to come back to this state later.\n\n\n  sBegin() {\n    // We are essentially peeking at the first character of the chunk. Since\n    // S_BEGIN can be in effect only when we start working on the first chunk,\n    // the index at which we must look is necessarily 0. Note also that the\n    // following test does not depend on decoding surrogates.\n    // If the initial character is 0xFEFF, ignore it.\n    if (this.chunk.charCodeAt(0) === 0xFEFF) {\n      this.i++;\n      this.column++;\n    }\n\n    this.state = S_BEGIN_WHITESPACE;\n  }\n\n  sBeginWhitespace() {\n    // We need to know whether we've encountered spaces or not because as soon\n    // as we run into a space, an XML declaration is no longer possible. Rather\n    // than slow down skipSpaces even in places where we don't care whether it\n    // skipped anything or not, we check whether prevI is equal to the value of\n    // i from before we skip spaces.\n    const iBefore = this.i;\n    const c = this.skipSpaces();\n\n    if (this.prevI !== iBefore) {\n      this.xmlDeclPossible = false;\n    }\n\n    switch (c) {\n      case LESS:\n        this.state = S_OPEN_WAKA; // We could naively call closeText but in this state, it is not normal\n        // to have text be filled with any data.\n\n        if (this.text.length !== 0) {\n          throw new Error(\"no-empty text at start\");\n        }\n\n        break;\n\n      case EOC:\n        break;\n\n      default:\n        this.unget();\n        this.state = S_TEXT;\n        this.xmlDeclPossible = false;\n    }\n  }\n\n  sDoctype() {\n    var _a;\n\n    const c = this.captureTo(DOCTYPE_TERMINATOR);\n\n    switch (c) {\n      case GREATER:\n        {\n          // eslint-disable-next-line no-unused-expressions\n          (_a = this.doctypeHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n          this.text = \"\";\n          this.state = S_TEXT;\n          this.doctype = true; // just remember that we saw it.\n\n          break;\n        }\n\n      case EOC:\n        break;\n\n      default:\n        this.text += String.fromCodePoint(c);\n\n        if (c === OPEN_BRACKET) {\n          this.state = S_DTD;\n        } else if (isQuote(c)) {\n          this.state = S_DOCTYPE_QUOTE;\n          this.q = c;\n        }\n\n    }\n  }\n\n  sDoctypeQuote() {\n    const q = this.q;\n\n    if (this.captureToChar(q)) {\n      this.text += String.fromCodePoint(q);\n      this.q = null;\n      this.state = S_DOCTYPE;\n    }\n  }\n\n  sDTD() {\n    const c = this.captureTo(DTD_TERMINATOR);\n\n    if (c === EOC) {\n      return;\n    }\n\n    this.text += String.fromCodePoint(c);\n\n    if (c === CLOSE_BRACKET) {\n      this.state = S_DOCTYPE;\n    } else if (c === LESS) {\n      this.state = S_DTD_OPEN_WAKA;\n    } else if (isQuote(c)) {\n      this.state = S_DTD_QUOTED;\n      this.q = c;\n    }\n  }\n\n  sDTDQuoted() {\n    const q = this.q;\n\n    if (this.captureToChar(q)) {\n      this.text += String.fromCodePoint(q);\n      this.state = S_DTD;\n      this.q = null;\n    }\n  }\n\n  sDTDOpenWaka() {\n    const c = this.getCodeNorm();\n    this.text += String.fromCodePoint(c);\n\n    switch (c) {\n      case BANG:\n        this.state = S_DTD_OPEN_WAKA_BANG;\n        this.openWakaBang = \"\";\n        break;\n\n      case QUESTION:\n        this.state = S_DTD_PI;\n        break;\n\n      default:\n        this.state = S_DTD;\n    }\n  }\n\n  sDTDOpenWakaBang() {\n    const char = String.fromCodePoint(this.getCodeNorm());\n    const owb = this.openWakaBang += char;\n    this.text += char;\n\n    if (owb !== \"-\") {\n      this.state = owb === \"--\" ? S_DTD_COMMENT : S_DTD;\n      this.openWakaBang = \"\";\n    }\n  }\n\n  sDTDComment() {\n    if (this.captureToChar(MINUS)) {\n      this.text += \"-\";\n      this.state = S_DTD_COMMENT_ENDING;\n    }\n  }\n\n  sDTDCommentEnding() {\n    const c = this.getCodeNorm();\n    this.text += String.fromCodePoint(c);\n    this.state = c === MINUS ? S_DTD_COMMENT_ENDED : S_DTD_COMMENT;\n  }\n\n  sDTDCommentEnded() {\n    const c = this.getCodeNorm();\n    this.text += String.fromCodePoint(c);\n\n    if (c === GREATER) {\n      this.state = S_DTD;\n    } else {\n      this.fail(\"malformed comment.\"); // <!-- blah -- bloo --> will be recorded as\n      // a comment of \" blah -- bloo \"\n\n      this.state = S_DTD_COMMENT;\n    }\n  }\n\n  sDTDPI() {\n    if (this.captureToChar(QUESTION)) {\n      this.text += \"?\";\n      this.state = S_DTD_PI_ENDING;\n    }\n  }\n\n  sDTDPIEnding() {\n    const c = this.getCodeNorm();\n    this.text += String.fromCodePoint(c);\n\n    if (c === GREATER) {\n      this.state = S_DTD;\n    }\n  }\n\n  sText() {\n    //\n    // We did try a version of saxes where the S_TEXT state was split in two\n    // states: one for text inside the root element, and one for text\n    // outside. This was avoiding having to test this.tags.length to decide\n    // what implementation to actually use.\n    //\n    // Peformance testing on gigabyte-size files did not show any advantage to\n    // using the two states solution instead of the current one. Conversely, it\n    // made the code a bit more complicated elsewhere. For instance, a comment\n    // can appear before the root element so when a comment ended it was\n    // necessary to determine whether to return to the S_TEXT state or to the\n    // new text-outside-root state.\n    //\n    if (this.tags.length !== 0) {\n      this.handleTextInRoot();\n    } else {\n      this.handleTextOutsideRoot();\n    }\n  }\n\n  sEntity() {\n    // This is essentially a specialized version of captureToChar(SEMICOLON...)\n    let {\n      i: start\n    } = this;\n    const {\n      chunk\n    } = this; // eslint-disable-next-line no-labels, no-restricted-syntax\n\n    loop: // eslint-disable-next-line no-constant-condition\n    while (true) {\n      switch (this.getCode()) {\n        case NL_LIKE:\n          this.entity += `${chunk.slice(start, this.prevI)}\\n`;\n          start = this.i;\n          break;\n\n        case SEMICOLON:\n          {\n            const {\n              entityReturnState\n            } = this;\n            const entity = this.entity + chunk.slice(start, this.prevI);\n            this.state = entityReturnState;\n            let parsed;\n\n            if (entity === \"\") {\n              this.fail(\"empty entity name.\");\n              parsed = \"&;\";\n            } else {\n              parsed = this.parseEntity(entity);\n              this.entity = \"\";\n            }\n\n            if (entityReturnState !== S_TEXT || this.textHandler !== undefined) {\n              this.text += parsed;\n            } // eslint-disable-next-line no-labels\n\n\n            break loop;\n          }\n\n        case EOC:\n          this.entity += chunk.slice(start); // eslint-disable-next-line no-labels\n\n          break loop;\n\n        default:\n      }\n    }\n  }\n\n  sOpenWaka() {\n    // Reminder: a state handler is called with at least one character\n    // available in the current chunk. So the first call to get code inside of\n    // a state handler cannot return ``EOC``. That's why we don't test\n    // for it.\n    const c = this.getCode(); // either a /, ?, !, or text is coming next.\n\n    if (isNameStartChar(c)) {\n      this.state = S_OPEN_TAG;\n      this.unget();\n      this.xmlDeclPossible = false;\n    } else {\n      switch (c) {\n        case FORWARD_SLASH:\n          this.state = S_CLOSE_TAG;\n          this.xmlDeclPossible = false;\n          break;\n\n        case BANG:\n          this.state = S_OPEN_WAKA_BANG;\n          this.openWakaBang = \"\";\n          this.xmlDeclPossible = false;\n          break;\n\n        case QUESTION:\n          this.state = S_PI_FIRST_CHAR;\n          break;\n\n        default:\n          this.fail(\"disallowed character in tag name\");\n          this.state = S_TEXT;\n          this.xmlDeclPossible = false;\n      }\n    }\n  }\n\n  sOpenWakaBang() {\n    this.openWakaBang += String.fromCodePoint(this.getCodeNorm());\n\n    switch (this.openWakaBang) {\n      case \"[CDATA[\":\n        if (!this.sawRoot && !this.reportedTextBeforeRoot) {\n          this.fail(\"text data outside of root node.\");\n          this.reportedTextBeforeRoot = true;\n        }\n\n        if (this.closedRoot && !this.reportedTextAfterRoot) {\n          this.fail(\"text data outside of root node.\");\n          this.reportedTextAfterRoot = true;\n        }\n\n        this.state = S_CDATA;\n        this.openWakaBang = \"\";\n        break;\n\n      case \"--\":\n        this.state = S_COMMENT;\n        this.openWakaBang = \"\";\n        break;\n\n      case \"DOCTYPE\":\n        this.state = S_DOCTYPE;\n\n        if (this.doctype || this.sawRoot) {\n          this.fail(\"inappropriately located doctype declaration.\");\n        }\n\n        this.openWakaBang = \"\";\n        break;\n\n      default:\n        // 7 happens to be the maximum length of the string that can possibly\n        // match one of the cases above.\n        if (this.openWakaBang.length >= 7) {\n          this.fail(\"incorrect syntax.\");\n        }\n\n    }\n  }\n\n  sComment() {\n    if (this.captureToChar(MINUS)) {\n      this.state = S_COMMENT_ENDING;\n    }\n  }\n\n  sCommentEnding() {\n    var _a;\n\n    const c = this.getCodeNorm();\n\n    if (c === MINUS) {\n      this.state = S_COMMENT_ENDED; // eslint-disable-next-line no-unused-expressions\n\n      (_a = this.commentHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n      this.text = \"\";\n    } else {\n      this.text += `-${String.fromCodePoint(c)}`;\n      this.state = S_COMMENT;\n    }\n  }\n\n  sCommentEnded() {\n    const c = this.getCodeNorm();\n\n    if (c !== GREATER) {\n      this.fail(\"malformed comment.\"); // <!-- blah -- bloo --> will be recorded as\n      // a comment of \" blah -- bloo \"\n\n      this.text += `--${String.fromCodePoint(c)}`;\n      this.state = S_COMMENT;\n    } else {\n      this.state = S_TEXT;\n    }\n  }\n\n  sCData() {\n    if (this.captureToChar(CLOSE_BRACKET)) {\n      this.state = S_CDATA_ENDING;\n    }\n  }\n\n  sCDataEnding() {\n    const c = this.getCodeNorm();\n\n    if (c === CLOSE_BRACKET) {\n      this.state = S_CDATA_ENDING_2;\n    } else {\n      this.text += `]${String.fromCodePoint(c)}`;\n      this.state = S_CDATA;\n    }\n  }\n\n  sCDataEnding2() {\n    var _a;\n\n    const c = this.getCodeNorm();\n\n    switch (c) {\n      case GREATER:\n        {\n          // eslint-disable-next-line no-unused-expressions\n          (_a = this.cdataHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n          this.text = \"\";\n          this.state = S_TEXT;\n          break;\n        }\n\n      case CLOSE_BRACKET:\n        this.text += \"]\";\n        break;\n\n      default:\n        this.text += `]]${String.fromCodePoint(c)}`;\n        this.state = S_CDATA;\n    }\n  } // We need this separate state to check the first character fo the pi target\n  // with this.nameStartCheck which allows less characters than this.nameCheck.\n\n\n  sPIFirstChar() {\n    const c = this.getCodeNorm(); // This is first because in the case where the file is well-formed this is\n    // the branch taken. We optimize for well-formedness.\n\n    if (this.nameStartCheck(c)) {\n      this.piTarget += String.fromCodePoint(c);\n      this.state = S_PI_REST;\n    } else if (c === QUESTION || isS(c)) {\n      this.fail(\"processing instruction without a target.\");\n      this.state = c === QUESTION ? S_PI_ENDING : S_PI_BODY;\n    } else {\n      this.fail(\"disallowed character in processing instruction name.\");\n      this.piTarget += String.fromCodePoint(c);\n      this.state = S_PI_REST;\n    }\n  }\n\n  sPIRest() {\n    // Capture characters into a piTarget while ``this.nameCheck`` run on the\n    // character read returns true.\n    const {\n      chunk,\n      i: start\n    } = this; // eslint-disable-next-line no-constant-condition\n\n    while (true) {\n      const c = this.getCodeNorm();\n\n      if (c === EOC) {\n        this.piTarget += chunk.slice(start);\n        return;\n      } // NL cannot satisfy this.nameCheck so we don't have to test specifically\n      // for it.\n\n\n      if (!this.nameCheck(c)) {\n        this.piTarget += chunk.slice(start, this.prevI);\n        const isQuestion = c === QUESTION;\n\n        if (isQuestion || isS(c)) {\n          if (this.piTarget === \"xml\") {\n            if (!this.xmlDeclPossible) {\n              this.fail(\"an XML declaration must be at the start of the document.\");\n            }\n\n            this.state = isQuestion ? S_XML_DECL_ENDING : S_XML_DECL_NAME_START;\n          } else {\n            this.state = isQuestion ? S_PI_ENDING : S_PI_BODY;\n          }\n        } else {\n          this.fail(\"disallowed character in processing instruction name.\");\n          this.piTarget += String.fromCodePoint(c);\n        }\n\n        break;\n      }\n    }\n  }\n\n  sPIBody() {\n    if (this.text.length === 0) {\n      const c = this.getCodeNorm();\n\n      if (c === QUESTION) {\n        this.state = S_PI_ENDING;\n      } else if (!isS(c)) {\n        this.text = String.fromCodePoint(c);\n      }\n    } // The question mark character is not valid inside any of the XML\n    // declaration name/value pairs.\n    else if (this.captureToChar(QUESTION)) {\n      this.state = S_PI_ENDING;\n    }\n  }\n\n  sPIEnding() {\n    var _a;\n\n    const c = this.getCodeNorm();\n\n    if (c === GREATER) {\n      const {\n        piTarget\n      } = this;\n\n      if (piTarget.toLowerCase() === \"xml\") {\n        this.fail(\"the XML declaration must appear at the start of the document.\");\n      } // eslint-disable-next-line no-unused-expressions\n\n\n      (_a = this.piHandler) === null || _a === void 0 ? void 0 : _a.call(this, {\n        target: piTarget,\n        body: this.text\n      });\n      this.piTarget = this.text = \"\";\n      this.state = S_TEXT;\n    } else if (c === QUESTION) {\n      // We ran into ?? as part of a processing instruction. We initially took\n      // the first ? as a sign that the PI was ending, but it is not. So we have\n      // to add it to the body but we take the new ? as a sign that the PI is\n      // ending.\n      this.text += \"?\";\n    } else {\n      this.text += `?${String.fromCodePoint(c)}`;\n      this.state = S_PI_BODY;\n    }\n\n    this.xmlDeclPossible = false;\n  }\n\n  sXMLDeclNameStart() {\n    const c = this.skipSpaces(); // The question mark character is not valid inside any of the XML\n    // declaration name/value pairs.\n\n    if (c === QUESTION) {\n      // It is valid to go to S_XML_DECL_ENDING from this state.\n      this.state = S_XML_DECL_ENDING;\n      return;\n    }\n\n    if (c !== EOC) {\n      this.state = S_XML_DECL_NAME;\n      this.name = String.fromCodePoint(c);\n    }\n  }\n\n  sXMLDeclName() {\n    const c = this.captureTo(XML_DECL_NAME_TERMINATOR); // The question mark character is not valid inside any of the XML\n    // declaration name/value pairs.\n\n    if (c === QUESTION) {\n      this.state = S_XML_DECL_ENDING;\n      this.name += this.text;\n      this.text = \"\";\n      this.fail(\"XML declaration is incomplete.\");\n      return;\n    }\n\n    if (!(isS(c) || c === EQUAL)) {\n      return;\n    }\n\n    this.name += this.text;\n    this.text = \"\";\n\n    if (!this.xmlDeclExpects.includes(this.name)) {\n      switch (this.name.length) {\n        case 0:\n          this.fail(\"did not expect any more name/value pairs.\");\n          break;\n\n        case 1:\n          this.fail(`expected the name ${this.xmlDeclExpects[0]}.`);\n          break;\n\n        default:\n          this.fail(`expected one of ${this.xmlDeclExpects.join(\", \")}`);\n      }\n    }\n\n    this.state = c === EQUAL ? S_XML_DECL_VALUE_START : S_XML_DECL_EQ;\n  }\n\n  sXMLDeclEq() {\n    const c = this.getCodeNorm(); // The question mark character is not valid inside any of the XML\n    // declaration name/value pairs.\n\n    if (c === QUESTION) {\n      this.state = S_XML_DECL_ENDING;\n      this.fail(\"XML declaration is incomplete.\");\n      return;\n    }\n\n    if (isS(c)) {\n      return;\n    }\n\n    if (c !== EQUAL) {\n      this.fail(\"value required.\");\n    }\n\n    this.state = S_XML_DECL_VALUE_START;\n  }\n\n  sXMLDeclValueStart() {\n    const c = this.getCodeNorm(); // The question mark character is not valid inside any of the XML\n    // declaration name/value pairs.\n\n    if (c === QUESTION) {\n      this.state = S_XML_DECL_ENDING;\n      this.fail(\"XML declaration is incomplete.\");\n      return;\n    }\n\n    if (isS(c)) {\n      return;\n    }\n\n    if (!isQuote(c)) {\n      this.fail(\"value must be quoted.\");\n      this.q = SPACE;\n    } else {\n      this.q = c;\n    }\n\n    this.state = S_XML_DECL_VALUE;\n  }\n\n  sXMLDeclValue() {\n    const c = this.captureTo([this.q, QUESTION]); // The question mark character is not valid inside any of the XML\n    // declaration name/value pairs.\n\n    if (c === QUESTION) {\n      this.state = S_XML_DECL_ENDING;\n      this.text = \"\";\n      this.fail(\"XML declaration is incomplete.\");\n      return;\n    }\n\n    if (c === EOC) {\n      return;\n    }\n\n    const value = this.text;\n    this.text = \"\";\n\n    switch (this.name) {\n      case \"version\":\n        {\n          this.xmlDeclExpects = [\"encoding\", \"standalone\"];\n          const version = value;\n          this.xmlDecl.version = version; // This is the test specified by XML 1.0 but it is fine for XML 1.1.\n\n          if (!/^1\\.[0-9]+$/.test(version)) {\n            this.fail(\"version number must match /^1\\\\.[0-9]+$/.\");\n          } // When forceXMLVersion is set, the XML declaration is ignored.\n          else if (!this.opt.forceXMLVersion) {\n            this.setXMLVersion(version);\n          }\n\n          break;\n        }\n\n      case \"encoding\":\n        if (!/^[A-Za-z][A-Za-z0-9._-]*$/.test(value)) {\n          this.fail(\"encoding value must match \\\n/^[A-Za-z0-9][A-Za-z0-9._-]*$/.\");\n        }\n\n        this.xmlDeclExpects = [\"standalone\"];\n        this.xmlDecl.encoding = value;\n        break;\n\n      case \"standalone\":\n        if (value !== \"yes\" && value !== \"no\") {\n          this.fail(\"standalone value must match \\\"yes\\\" or \\\"no\\\".\");\n        }\n\n        this.xmlDeclExpects = [];\n        this.xmlDecl.standalone = value;\n        break;\n\n      default: // We don't need to raise an error here since we've already raised one\n      // when checking what name was expected.\n\n    }\n\n    this.name = \"\";\n    this.state = S_XML_DECL_SEPARATOR;\n  }\n\n  sXMLDeclSeparator() {\n    const c = this.getCodeNorm(); // The question mark character is not valid inside any of the XML\n    // declaration name/value pairs.\n\n    if (c === QUESTION) {\n      // It is valid to go to S_XML_DECL_ENDING from this state.\n      this.state = S_XML_DECL_ENDING;\n      return;\n    }\n\n    if (!isS(c)) {\n      this.fail(\"whitespace required.\");\n      this.unget();\n    }\n\n    this.state = S_XML_DECL_NAME_START;\n  }\n\n  sXMLDeclEnding() {\n    var _a;\n\n    const c = this.getCodeNorm();\n\n    if (c === GREATER) {\n      if (this.piTarget !== \"xml\") {\n        this.fail(\"processing instructions are not allowed before root.\");\n      } else if (this.name !== \"version\" && this.xmlDeclExpects.includes(\"version\")) {\n        this.fail(\"XML declaration must contain a version.\");\n      } // eslint-disable-next-line no-unused-expressions\n\n\n      (_a = this.xmldeclHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.xmlDecl);\n      this.name = \"\";\n      this.piTarget = this.text = \"\";\n      this.state = S_TEXT;\n    } else {\n      // We got here because the previous character was a ?, but the question\n      // mark character is not valid inside any of the XML declaration\n      // name/value pairs.\n      this.fail(\"The character ? is disallowed anywhere in XML declarations.\");\n    }\n\n    this.xmlDeclPossible = false;\n  }\n\n  sOpenTag() {\n    var _a;\n\n    const c = this.captureNameChars();\n\n    if (c === EOC) {\n      return;\n    }\n\n    const tag = this.tag = {\n      name: this.name,\n      attributes: Object.create(null)\n    };\n    this.name = \"\";\n\n    if (this.xmlnsOpt) {\n      this.topNS = tag.ns = Object.create(null);\n    } // eslint-disable-next-line no-unused-expressions\n\n\n    (_a = this.openTagStartHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n    this.sawRoot = true;\n\n    if (!this.fragmentOpt && this.closedRoot) {\n      this.fail(\"documents may contain only one root.\");\n    }\n\n    switch (c) {\n      case GREATER:\n        this.openTag();\n        break;\n\n      case FORWARD_SLASH:\n        this.state = S_OPEN_TAG_SLASH;\n        break;\n\n      default:\n        if (!isS(c)) {\n          this.fail(\"disallowed character in tag name.\");\n        }\n\n        this.state = S_ATTRIB;\n    }\n  }\n\n  sOpenTagSlash() {\n    if (this.getCode() === GREATER) {\n      this.openSelfClosingTag();\n    } else {\n      this.fail(\"forward-slash in opening tag not followed by >.\");\n      this.state = S_ATTRIB;\n    }\n  }\n\n  sAttrib() {\n    const c = this.skipSpaces();\n\n    if (c === EOC) {\n      return;\n    }\n\n    if (isNameStartChar(c)) {\n      this.unget();\n      this.state = S_ATTRIB_NAME;\n    } else if (c === GREATER) {\n      this.openTag();\n    } else if (c === FORWARD_SLASH) {\n      this.state = S_OPEN_TAG_SLASH;\n    } else {\n      this.fail(\"disallowed character in attribute name.\");\n    }\n  }\n\n  sAttribName() {\n    const c = this.captureNameChars();\n\n    if (c === EQUAL) {\n      this.state = S_ATTRIB_VALUE;\n    } else if (isS(c)) {\n      this.state = S_ATTRIB_NAME_SAW_WHITE;\n    } else if (c === GREATER) {\n      this.fail(\"attribute without value.\");\n      this.pushAttrib(this.name, this.name);\n      this.name = this.text = \"\";\n      this.openTag();\n    } else if (c !== EOC) {\n      this.fail(\"disallowed character in attribute name.\");\n    }\n  }\n\n  sAttribNameSawWhite() {\n    const c = this.skipSpaces();\n\n    switch (c) {\n      case EOC:\n        return;\n\n      case EQUAL:\n        this.state = S_ATTRIB_VALUE;\n        break;\n\n      default:\n        this.fail(\"attribute without value.\"); // Should we do this???\n        // this.tag.attributes[this.name] = \"\";\n\n        this.text = \"\";\n        this.name = \"\";\n\n        if (c === GREATER) {\n          this.openTag();\n        } else if (isNameStartChar(c)) {\n          this.unget();\n          this.state = S_ATTRIB_NAME;\n        } else {\n          this.fail(\"disallowed character in attribute name.\");\n          this.state = S_ATTRIB;\n        }\n\n    }\n  }\n\n  sAttribValue() {\n    const c = this.getCodeNorm();\n\n    if (isQuote(c)) {\n      this.q = c;\n      this.state = S_ATTRIB_VALUE_QUOTED;\n    } else if (!isS(c)) {\n      this.fail(\"unquoted attribute value.\");\n      this.state = S_ATTRIB_VALUE_UNQUOTED;\n      this.unget();\n    }\n  }\n\n  sAttribValueQuoted() {\n    // We deliberately do not use captureTo here. The specialized code we use\n    // here is faster than using captureTo.\n    const {\n      q,\n      chunk\n    } = this;\n    let {\n      i: start\n    } = this; // eslint-disable-next-line no-constant-condition\n\n    while (true) {\n      switch (this.getCode()) {\n        case q:\n          this.pushAttrib(this.name, this.text + chunk.slice(start, this.prevI));\n          this.name = this.text = \"\";\n          this.q = null;\n          this.state = S_ATTRIB_VALUE_CLOSED;\n          return;\n\n        case AMP:\n          this.text += chunk.slice(start, this.prevI);\n          this.state = S_ENTITY;\n          this.entityReturnState = S_ATTRIB_VALUE_QUOTED;\n          return;\n\n        case NL:\n        case NL_LIKE:\n        case TAB:\n          this.text += `${chunk.slice(start, this.prevI)} `;\n          start = this.i;\n          break;\n\n        case LESS:\n          this.text += chunk.slice(start, this.prevI);\n          this.fail(\"disallowed character.\");\n          return;\n\n        case EOC:\n          this.text += chunk.slice(start);\n          return;\n\n        default:\n      }\n    }\n  }\n\n  sAttribValueClosed() {\n    const c = this.getCodeNorm();\n\n    if (isS(c)) {\n      this.state = S_ATTRIB;\n    } else if (c === GREATER) {\n      this.openTag();\n    } else if (c === FORWARD_SLASH) {\n      this.state = S_OPEN_TAG_SLASH;\n    } else if (isNameStartChar(c)) {\n      this.fail(\"no whitespace between attributes.\");\n      this.unget();\n      this.state = S_ATTRIB_NAME;\n    } else {\n      this.fail(\"disallowed character in attribute name.\");\n    }\n  }\n\n  sAttribValueUnquoted() {\n    // We don't do anything regarding EOL or space handling for unquoted\n    // attributes. We already have failed by the time we get here, and the\n    // contract that saxes upholds states that upon failure, it is not safe to\n    // rely on the data passed to event handlers (other than\n    // ``onerror``). Passing \"bad\" data is not a problem.\n    const c = this.captureTo(ATTRIB_VALUE_UNQUOTED_TERMINATOR);\n\n    switch (c) {\n      case AMP:\n        this.state = S_ENTITY;\n        this.entityReturnState = S_ATTRIB_VALUE_UNQUOTED;\n        break;\n\n      case LESS:\n        this.fail(\"disallowed character.\");\n        break;\n\n      case EOC:\n        break;\n\n      default:\n        if (this.text.includes(\"]]>\")) {\n          this.fail(\"the string \\\"]]>\\\" is disallowed in char data.\");\n        }\n\n        this.pushAttrib(this.name, this.text);\n        this.name = this.text = \"\";\n\n        if (c === GREATER) {\n          this.openTag();\n        } else {\n          this.state = S_ATTRIB;\n        }\n\n    }\n  }\n\n  sCloseTag() {\n    const c = this.captureNameChars();\n\n    if (c === GREATER) {\n      this.closeTag();\n    } else if (isS(c)) {\n      this.state = S_CLOSE_TAG_SAW_WHITE;\n    } else if (c !== EOC) {\n      this.fail(\"disallowed character in closing tag.\");\n    }\n  }\n\n  sCloseTagSawWhite() {\n    switch (this.skipSpaces()) {\n      case GREATER:\n        this.closeTag();\n        break;\n\n      case EOC:\n        break;\n\n      default:\n        this.fail(\"disallowed character in closing tag.\");\n    }\n  } // END OF STATE ENGINE METHODS\n\n\n  handleTextInRoot() {\n    // This is essentially a specialized version of captureTo which is optimized\n    // for performing the ]]> check. A previous version of this code, checked\n    // ``this.text`` for the presence of ]]>. It simplified the code but was\n    // very costly when character data contained a lot of entities to be parsed.\n    //\n    // Since we are using a specialized loop, we also keep track of the presence\n    // of ]]> in text data. The sequence ]]> is forbidden to appear as-is.\n    //\n    let {\n      i: start,\n      forbiddenState\n    } = this;\n    const {\n      chunk,\n      textHandler: handler\n    } = this; // eslint-disable-next-line no-labels, no-restricted-syntax\n\n    scanLoop: // eslint-disable-next-line no-constant-condition\n    while (true) {\n      switch (this.getCode()) {\n        case LESS:\n          {\n            this.state = S_OPEN_WAKA;\n\n            if (handler !== undefined) {\n              const {\n                text\n              } = this;\n              const slice = chunk.slice(start, this.prevI);\n\n              if (text.length !== 0) {\n                handler(text + slice);\n                this.text = \"\";\n              } else if (slice.length !== 0) {\n                handler(slice);\n              }\n            }\n\n            forbiddenState = FORBIDDEN_START; // eslint-disable-next-line no-labels\n\n            break scanLoop;\n          }\n\n        case AMP:\n          this.state = S_ENTITY;\n          this.entityReturnState = S_TEXT;\n\n          if (handler !== undefined) {\n            this.text += chunk.slice(start, this.prevI);\n          }\n\n          forbiddenState = FORBIDDEN_START; // eslint-disable-next-line no-labels\n\n          break scanLoop;\n\n        case CLOSE_BRACKET:\n          switch (forbiddenState) {\n            case FORBIDDEN_START:\n              forbiddenState = FORBIDDEN_BRACKET;\n              break;\n\n            case FORBIDDEN_BRACKET:\n              forbiddenState = FORBIDDEN_BRACKET_BRACKET;\n              break;\n\n            case FORBIDDEN_BRACKET_BRACKET:\n              break;\n\n            default:\n              throw new Error(\"impossible state\");\n          }\n\n          break;\n\n        case GREATER:\n          if (forbiddenState === FORBIDDEN_BRACKET_BRACKET) {\n            this.fail(\"the string \\\"]]>\\\" is disallowed in char data.\");\n          }\n\n          forbiddenState = FORBIDDEN_START;\n          break;\n\n        case NL_LIKE:\n          if (handler !== undefined) {\n            this.text += `${chunk.slice(start, this.prevI)}\\n`;\n          }\n\n          start = this.i;\n          forbiddenState = FORBIDDEN_START;\n          break;\n\n        case EOC:\n          if (handler !== undefined) {\n            this.text += chunk.slice(start);\n          } // eslint-disable-next-line no-labels\n\n\n          break scanLoop;\n\n        default:\n          forbiddenState = FORBIDDEN_START;\n      }\n    }\n\n    this.forbiddenState = forbiddenState;\n  }\n\n  handleTextOutsideRoot() {\n    // This is essentially a specialized version of captureTo which is optimized\n    // for a specialized task. We keep track of the presence of non-space\n    // characters in the text since these are errors when appearing outside the\n    // document root element.\n    let {\n      i: start\n    } = this;\n    const {\n      chunk,\n      textHandler: handler\n    } = this;\n    let nonSpace = false; // eslint-disable-next-line no-labels, no-restricted-syntax\n\n    outRootLoop: // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const code = this.getCode();\n\n      switch (code) {\n        case LESS:\n          {\n            this.state = S_OPEN_WAKA;\n\n            if (handler !== undefined) {\n              const {\n                text\n              } = this;\n              const slice = chunk.slice(start, this.prevI);\n\n              if (text.length !== 0) {\n                handler(text + slice);\n                this.text = \"\";\n              } else if (slice.length !== 0) {\n                handler(slice);\n              }\n            } // eslint-disable-next-line no-labels\n\n\n            break outRootLoop;\n          }\n\n        case AMP:\n          this.state = S_ENTITY;\n          this.entityReturnState = S_TEXT;\n\n          if (handler !== undefined) {\n            this.text += chunk.slice(start, this.prevI);\n          }\n\n          nonSpace = true; // eslint-disable-next-line no-labels\n\n          break outRootLoop;\n\n        case NL_LIKE:\n          if (handler !== undefined) {\n            this.text += `${chunk.slice(start, this.prevI)}\\n`;\n          }\n\n          start = this.i;\n          break;\n\n        case EOC:\n          if (handler !== undefined) {\n            this.text += chunk.slice(start);\n          } // eslint-disable-next-line no-labels\n\n\n          break outRootLoop;\n\n        default:\n          if (!isS(code)) {\n            nonSpace = true;\n          }\n\n      }\n    }\n\n    if (!nonSpace) {\n      return;\n    } // We use the reportedTextBeforeRoot and reportedTextAfterRoot flags\n    // to avoid reporting errors for every single character that is out of\n    // place.\n\n\n    if (!this.sawRoot && !this.reportedTextBeforeRoot) {\n      this.fail(\"text data outside of root node.\");\n      this.reportedTextBeforeRoot = true;\n    }\n\n    if (this.closedRoot && !this.reportedTextAfterRoot) {\n      this.fail(\"text data outside of root node.\");\n      this.reportedTextAfterRoot = true;\n    }\n  }\n\n  pushAttribNS(name, value) {\n    var _a;\n\n    const {\n      prefix,\n      local\n    } = this.qname(name);\n    const attr = {\n      name,\n      prefix,\n      local,\n      value\n    };\n    this.attribList.push(attr); // eslint-disable-next-line no-unused-expressions\n\n    (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);\n\n    if (prefix === \"xmlns\") {\n      const trimmed = value.trim();\n\n      if (this.currentXMLVersion === \"1.0\" && trimmed === \"\") {\n        this.fail(\"invalid attempt to undefine prefix in XML 1.0\");\n      }\n\n      this.topNS[local] = trimmed;\n      nsPairCheck(this, local, trimmed);\n    } else if (name === \"xmlns\") {\n      const trimmed = value.trim();\n      this.topNS[\"\"] = trimmed;\n      nsPairCheck(this, \"\", trimmed);\n    }\n  }\n\n  pushAttribPlain(name, value) {\n    var _a;\n\n    const attr = {\n      name,\n      value\n    };\n    this.attribList.push(attr); // eslint-disable-next-line no-unused-expressions\n\n    (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);\n  }\n  /**\n   * End parsing. This performs final well-formedness checks and resets the\n   * parser to a clean state.\n   *\n   * @returns this\n   */\n\n\n  end() {\n    var _a, _b;\n\n    if (!this.sawRoot) {\n      this.fail(\"document must contain a root element.\");\n    }\n\n    const {\n      tags\n    } = this;\n\n    while (tags.length > 0) {\n      const tag = tags.pop();\n      this.fail(`unclosed tag: ${tag.name}`);\n    }\n\n    if (this.state !== S_BEGIN && this.state !== S_TEXT) {\n      this.fail(\"unexpected end.\");\n    }\n\n    const {\n      text\n    } = this;\n\n    if (text.length !== 0) {\n      // eslint-disable-next-line no-unused-expressions\n      (_a = this.textHandler) === null || _a === void 0 ? void 0 : _a.call(this, text);\n      this.text = \"\";\n    }\n\n    this._closed = true; // eslint-disable-next-line no-unused-expressions\n\n    (_b = this.endHandler) === null || _b === void 0 ? void 0 : _b.call(this);\n\n    this._init();\n\n    return this;\n  }\n  /**\n   * Resolve a namespace prefix.\n   *\n   * @param prefix The prefix to resolve.\n   *\n   * @returns The namespace URI or ``undefined`` if the prefix is not defined.\n   */\n\n\n  resolve(prefix) {\n    var _a, _b;\n\n    let uri = this.topNS[prefix];\n\n    if (uri !== undefined) {\n      return uri;\n    }\n\n    const {\n      tags\n    } = this;\n\n    for (let index = tags.length - 1; index >= 0; index--) {\n      uri = tags[index].ns[prefix];\n\n      if (uri !== undefined) {\n        return uri;\n      }\n    }\n\n    uri = this.ns[prefix];\n\n    if (uri !== undefined) {\n      return uri;\n    }\n\n    return (_b = (_a = this.opt).resolvePrefix) === null || _b === void 0 ? void 0 : _b.call(_a, prefix);\n  }\n  /**\n   * Parse a qname into its prefix and local name parts.\n   *\n   * @param name The name to parse\n   *\n   * @returns\n   */\n\n\n  qname(name) {\n    // This is faster than using name.split(\":\").\n    const colon = name.indexOf(\":\");\n\n    if (colon === -1) {\n      return {\n        prefix: \"\",\n        local: name\n      };\n    }\n\n    const local = name.slice(colon + 1);\n    const prefix = name.slice(0, colon);\n\n    if (prefix === \"\" || local === \"\" || local.includes(\":\")) {\n      this.fail(`malformed name: ${name}.`);\n    }\n\n    return {\n      prefix,\n      local\n    };\n  }\n\n  processAttribsNS() {\n    var _a;\n\n    const {\n      attribList\n    } = this;\n    const tag = this.tag;\n    {\n      // add namespace info to tag\n      const {\n        prefix,\n        local\n      } = this.qname(tag.name);\n      tag.prefix = prefix;\n      tag.local = local;\n      const uri = tag.uri = (_a = this.resolve(prefix)) !== null && _a !== void 0 ? _a : \"\";\n\n      if (prefix !== \"\") {\n        if (prefix === \"xmlns\") {\n          this.fail(\"tags may not have \\\"xmlns\\\" as prefix.\");\n        }\n\n        if (uri === \"\") {\n          this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);\n          tag.uri = prefix;\n        }\n      }\n    }\n\n    if (attribList.length === 0) {\n      return;\n    }\n\n    const {\n      attributes\n    } = tag;\n    const seen = new Set(); // Note: do not apply default ns to attributes:\n    //   http://www.w3.org/TR/REC-xml-names/#defaulting\n\n    for (const attr of attribList) {\n      const {\n        name,\n        prefix,\n        local\n      } = attr;\n      let uri;\n      let eqname;\n\n      if (prefix === \"\") {\n        uri = name === \"xmlns\" ? XMLNS_NAMESPACE : \"\";\n        eqname = name;\n      } else {\n        uri = this.resolve(prefix); // if there's any attributes with an undefined namespace,\n        // then fail on them now.\n\n        if (uri === undefined) {\n          this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);\n          uri = prefix;\n        }\n\n        eqname = `{${uri}}${local}`;\n      }\n\n      if (seen.has(eqname)) {\n        this.fail(`duplicate attribute: ${eqname}.`);\n      }\n\n      seen.add(eqname);\n      attr.uri = uri;\n      attributes[name] = attr;\n    }\n\n    this.attribList = [];\n  }\n\n  processAttribsPlain() {\n    const {\n      attribList\n    } = this; // eslint-disable-next-line prefer-destructuring\n\n    const attributes = this.tag.attributes;\n\n    for (const {\n      name,\n      value\n    } of attribList) {\n      if (attributes[name] !== undefined) {\n        this.fail(`duplicate attribute: ${name}.`);\n      }\n\n      attributes[name] = value;\n    }\n\n    this.attribList = [];\n  }\n  /**\n   * Handle a complete open tag. This parser code calls this once it has seen\n   * the whole tag. This method checks for well-formeness and then emits\n   * ``onopentag``.\n   */\n\n\n  openTag() {\n    var _a;\n\n    this.processAttribs();\n    const {\n      tags\n    } = this;\n    const tag = this.tag;\n    tag.isSelfClosing = false; // There cannot be any pending text here due to the onopentagstart that was\n    // necessarily emitted before we get here. So we do not check text.\n    // eslint-disable-next-line no-unused-expressions\n\n    (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n    tags.push(tag);\n    this.state = S_TEXT;\n    this.name = \"\";\n  }\n  /**\n   * Handle a complete self-closing tag. This parser code calls this once it has\n   * seen the whole tag. This method checks for well-formeness and then emits\n   * ``onopentag`` and ``onclosetag``.\n   */\n\n\n  openSelfClosingTag() {\n    var _a, _b, _c;\n\n    this.processAttribs();\n    const {\n      tags\n    } = this;\n    const tag = this.tag;\n    tag.isSelfClosing = true; // There cannot be any pending text here due to the onopentagstart that was\n    // necessarily emitted before we get here. So we do not check text.\n    // eslint-disable-next-line no-unused-expressions\n\n    (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag); // eslint-disable-next-line no-unused-expressions\n\n    (_b = this.closeTagHandler) === null || _b === void 0 ? void 0 : _b.call(this, tag);\n    const top = this.tag = (_c = tags[tags.length - 1]) !== null && _c !== void 0 ? _c : null;\n\n    if (top === null) {\n      this.closedRoot = true;\n    }\n\n    this.state = S_TEXT;\n    this.name = \"\";\n  }\n  /**\n   * Handle a complete close tag. This parser code calls this once it has seen\n   * the whole tag. This method checks for well-formeness and then emits\n   * ``onclosetag``.\n   */\n\n\n  closeTag() {\n    const {\n      tags,\n      name\n    } = this; // Our state after this will be S_TEXT, no matter what, and we can clear\n    // tagName now.\n\n    this.state = S_TEXT;\n    this.name = \"\";\n\n    if (name === \"\") {\n      this.fail(\"weird empty close tag.\");\n      this.text += \"</>\";\n      return;\n    }\n\n    const handler = this.closeTagHandler;\n    let l = tags.length;\n\n    while (l-- > 0) {\n      const tag = this.tag = tags.pop();\n      this.topNS = tag.ns; // eslint-disable-next-line no-unused-expressions\n\n      handler === null || handler === void 0 ? void 0 : handler(tag);\n\n      if (tag.name === name) {\n        break;\n      }\n\n      this.fail(\"unexpected close tag.\");\n    }\n\n    if (l === 0) {\n      this.closedRoot = true;\n    } else if (l < 0) {\n      this.fail(`unmatched closing tag: ${name}.`);\n      this.text += `</${name}>`;\n    }\n  }\n  /**\n   * Resolves an entity. Makes any necessary well-formedness checks.\n   *\n   * @param entity The entity to resolve.\n   *\n   * @returns The parsed entity.\n   */\n\n\n  parseEntity(entity) {\n    // startsWith would be significantly slower for this test.\n    // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with\n    if (entity[0] !== \"#\") {\n      const defined = this.ENTITIES[entity];\n\n      if (defined !== undefined) {\n        return defined;\n      }\n\n      this.fail(this.isName(entity) ? \"undefined entity.\" : \"disallowed character in entity name.\");\n      return `&${entity};`;\n    }\n\n    let num = NaN;\n\n    if (entity[1] === \"x\" && /^#x[0-9a-f]+$/i.test(entity)) {\n      num = parseInt(entity.slice(2), 16);\n    } else if (/^#[0-9]+$/.test(entity)) {\n      num = parseInt(entity.slice(1), 10);\n    } // The character reference is required to match the CHAR production.\n\n\n    if (!this.isChar(num)) {\n      this.fail(\"malformed character entity.\");\n      return `&${entity};`;\n    }\n\n    return String.fromCodePoint(num);\n  }\n\n}\n\nexports.SaxesParser = SaxesParser;","map":{"version":3,"mappings":"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","names":["isS","ed5","isChar10","isChar","isNameStartChar","isNameChar","S_LIST","NAME_RE","isChar11","ed2","isNCNameStartChar","NSed3","isNCNameChar","NC_NAME_RE","XML_NAMESPACE","XMLNS_NAMESPACE","rootNS","__proto__","xml","xmlns","XML_ENTITIES","amp","gt","lt","quot","apos","EOC","NL_LIKE","S_BEGIN","S_BEGIN_WHITESPACE","S_DOCTYPE","S_DOCTYPE_QUOTE","S_DTD","S_DTD_QUOTED","S_DTD_OPEN_WAKA","S_DTD_OPEN_WAKA_BANG","S_DTD_COMMENT","S_DTD_COMMENT_ENDING","S_DTD_COMMENT_ENDED","S_DTD_PI","S_DTD_PI_ENDING","S_TEXT","S_ENTITY","S_OPEN_WAKA","S_OPEN_WAKA_BANG","S_COMMENT","S_COMMENT_ENDING","S_COMMENT_ENDED","S_CDATA","S_CDATA_ENDING","S_CDATA_ENDING_2","S_PI_FIRST_CHAR","S_PI_REST","S_PI_BODY","S_PI_ENDING","S_XML_DECL_NAME_START","S_XML_DECL_NAME","S_XML_DECL_EQ","S_XML_DECL_VALUE_START","S_XML_DECL_VALUE","S_XML_DECL_SEPARATOR","S_XML_DECL_ENDING","S_OPEN_TAG","S_OPEN_TAG_SLASH","S_ATTRIB","S_ATTRIB_NAME","S_ATTRIB_NAME_SAW_WHITE","S_ATTRIB_VALUE","S_ATTRIB_VALUE_QUOTED","S_ATTRIB_VALUE_CLOSED","S_ATTRIB_VALUE_UNQUOTED","S_CLOSE_TAG","S_CLOSE_TAG_SAW_WHITE","TAB","NL","CR","SPACE","BANG","DQUOTE","AMP","SQUOTE","MINUS","FORWARD_SLASH","SEMICOLON","LESS","EQUAL","GREATER","QUESTION","OPEN_BRACKET","CLOSE_BRACKET","NEL","LS","isQuote","c","QUOTES","DOCTYPE_TERMINATOR","DTD_TERMINATOR","XML_DECL_NAME_TERMINATOR","ATTRIB_VALUE_UNQUOTED_TERMINATOR","nsPairCheck","parser","prefix","uri","fail","nsMappingCheck","mapping","local","Object","keys","isNCName","name","test","isName","FORBIDDEN_START","FORBIDDEN_BRACKET","FORBIDDEN_BRACKET_BRACKET","exports","EVENT_NAME_TO_HANDLER_NAME","xmldecl","text","processinginstruction","doctype","comment","opentagstart","attribute","opentag","closetag","cdata","error","end","ready","SaxesParser","constructor","opt","fragmentOpt","fragment","xmlnsOpt","trackPosition","position","fileName","nameStartCheck","nameCheck","processAttribs","processAttribsNS","pushAttrib","pushAttribNS","ns","additional","additionalNamespaces","assign","processAttribsPlain","pushAttribPlain","stateTable","sBegin","sBeginWhitespace","sDoctype","sDoctypeQuote","sDTD","sDTDQuoted","sDTDOpenWaka","sDTDOpenWakaBang","sDTDComment","sDTDCommentEnding","sDTDCommentEnded","sDTDPI","sDTDPIEnding","sText","sEntity","sOpenWaka","sOpenWakaBang","sComment","sCommentEnding","sCommentEnded","sCData","sCDataEnding","sCDataEnding2","sPIFirstChar","sPIRest","sPIBody","sPIEnding","sXMLDeclNameStart","sXMLDeclName","sXMLDeclEq","sXMLDeclValueStart","sXMLDeclValue","sXMLDeclSeparator","sXMLDeclEnding","sOpenTag","sOpenTagSlash","sAttrib","sAttribName","sAttribNameSawWhite","sAttribValue","sAttribValueQuoted","sAttribValueClosed","sAttribValueUnquoted","sCloseTag","sCloseTagSawWhite","_init","closed","_closed","openWakaBang","piTarget","entity","q","tags","tag","topNS","chunk","chunkPosition","i","prevI","carriedFromPrevious","undefined","forbiddenState","attribList","state","reportedTextBeforeRoot","reportedTextAfterRoot","closedRoot","sawRoot","xmlDeclPossible","xmlDeclExpects","entityReturnState","defaultXMLVersion","forceXMLVersion","Error","setXMLVersion","positionAtNewLine","xmlDecl","version","encoding","standalone","line","column","ENTITIES","create","readyHandler","_a","columnIndex","on","handler","off","makeError","message","msg","length","err","errorHandler","write","toString","limit","lastCode","charCodeAt","slice","call","close","getCode10","code","final","getCode11","next","getCodeNorm","getCode","unget","captureTo","chars","start","isNLLike","includes","captureToChar","char","captureNameChars","skipSpaces","currentXMLVersion","iBefore","doctypeHandler","String","fromCodePoint","owb","handleTextInRoot","handleTextOutsideRoot","loop","parsed","parseEntity","textHandler","commentHandler","cdataHandler","isQuestion","toLowerCase","piHandler","target","body","join","value","xmldeclHandler","attributes","openTagStartHandler","openTag","openSelfClosingTag","closeTag","scanLoop","nonSpace","outRootLoop","qname","attr","push","attributeHandler","trimmed","trim","pop","endHandler","_b","resolve","index","resolvePrefix","colon","indexOf","JSON","stringify","seen","Set","eqname","has","add","isSelfClosing","openTagHandler","closeTagHandler","top","_c","l","defined","num","NaN","parseInt"],"sources":["../../src/saxes.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}