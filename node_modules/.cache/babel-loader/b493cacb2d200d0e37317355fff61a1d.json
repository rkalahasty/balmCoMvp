{"ast":null,"code":"\"use strict\";\n\nconst HTTP_STATUS_CODES = require(\"http\").STATUS_CODES;\n\nconst {\n  spawnSync\n} = require(\"child_process\");\n\nconst {\n  URL\n} = require(\"whatwg-url\");\n\nconst whatwgEncoding = require(\"whatwg-encoding\");\n\nconst tough = require(\"tough-cookie\");\n\nconst MIMEType = require(\"whatwg-mimetype\");\n\nconst xhrUtils = require(\"./xhr-utils\");\n\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\n\nconst {\n  documentBaseURLSerialized\n} = require(\"../helpers/document-base-url\");\n\nconst {\n  asciiCaseInsensitiveMatch\n} = require(\"../helpers/strings\");\n\nconst idlUtils = require(\"../generated/utils\");\n\nconst Document = require(\"../generated/Document\");\n\nconst Blob = require(\"../generated/Blob\");\n\nconst FormData = require(\"../generated/FormData\");\n\nconst XMLHttpRequestEventTargetImpl = require(\"./XMLHttpRequestEventTarget-impl\").implementation;\n\nconst XMLHttpRequestUpload = require(\"../generated/XMLHttpRequestUpload\");\n\nconst ProgressEvent = require(\"../generated/ProgressEvent\");\n\nconst {\n  isArrayBuffer\n} = require(\"../generated/utils\");\n\nconst {\n  parseIntoDocument\n} = require(\"../../browser/parser\");\n\nconst {\n  fragmentSerialization\n} = require(\"../domparsing/serialization\");\n\nconst {\n  setupForSimpleEventAccessors\n} = require(\"../helpers/create-event-accessor\");\n\nconst {\n  parseJSONFromBytes\n} = require(\"../helpers/json\");\n\nconst {\n  fireAnEvent\n} = require(\"../helpers/events\");\n\nconst {\n  copyToArrayBufferInNewRealm\n} = require(\"../helpers/binary-data\");\n\nconst {\n  READY_STATES\n} = xhrUtils;\nconst syncWorkerFile = require.resolve ? require.resolve(\"./xhr-sync-worker.js\") : null;\nconst tokenRegexp = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/;\nconst fieldValueRegexp = /^[ \\t]*(?:[\\x21-\\x7E\\x80-\\xFF](?:[ \\t][\\x21-\\x7E\\x80-\\xFF])?)*[ \\t]*$/;\nconst forbiddenRequestHeaders = new Set([\"accept-charset\", \"accept-encoding\", \"access-control-request-headers\", \"access-control-request-method\", \"connection\", \"content-length\", \"cookie\", \"cookie2\", \"date\", \"dnt\", \"expect\", \"host\", \"keep-alive\", \"origin\", \"referer\", \"te\", \"trailer\", \"transfer-encoding\", \"upgrade\", \"via\"]);\nconst forbiddenResponseHeaders = new Set([\"set-cookie\", \"set-cookie2\"]);\nconst uniqueResponseHeaders = new Set([\"content-type\", \"content-length\", \"user-agent\", \"referer\", \"host\", \"authorization\", \"proxy-authorization\", \"if-modified-since\", \"if-unmodified-since\", \"from\", \"location\", \"max-forwards\"]);\nconst corsSafeResponseHeaders = new Set([\"cache-control\", \"content-language\", \"content-length\", \"content-type\", \"expires\", \"last-modified\", \"pragma\"]);\nconst allowedRequestMethods = new Set([\"OPTIONS\", \"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\"]);\nconst forbiddenRequestMethods = new Set([\"TRACK\", \"TRACE\", \"CONNECT\"]);\n\nclass XMLHttpRequestImpl extends XMLHttpRequestEventTargetImpl {\n  constructor(window) {\n    super(window); // Avoid running `_ownerDocument` getter multiple times in the constructor:\n\n    const {\n      _ownerDocument\n    } = this;\n    this.upload = XMLHttpRequestUpload.createImpl(window);\n    this.readyState = READY_STATES.UNSENT;\n    this.responseURL = \"\";\n    this.status = 0;\n    this.statusText = \"\";\n    this.flag = {\n      synchronous: false,\n      withCredentials: false,\n      mimeType: null,\n      auth: null,\n      method: undefined,\n      responseType: \"\",\n      requestHeaders: {},\n      referrer: _ownerDocument.URL,\n      uri: \"\",\n      timeout: 0,\n      body: undefined,\n      formData: false,\n      preflight: false,\n      requestManager: _ownerDocument._requestManager,\n      strictSSL: window._resourceLoader._strictSSL,\n      proxy: window._resourceLoader._proxy,\n      cookieJar: _ownerDocument._cookieJar,\n      encoding: _ownerDocument._encoding,\n      origin: window._origin,\n      userAgent: window.navigator.userAgent\n    };\n    this.properties = {\n      beforeSend: false,\n      send: false,\n      client: null,\n      timeoutStart: 0,\n      timeoutId: 0,\n      timeoutFn: null,\n      responseBuffer: null,\n      responseCache: null,\n      responseTextCache: null,\n      responseXMLCache: null,\n      responseHeaders: {},\n      filteredResponseHeaders: [],\n      error: \"\",\n      uploadComplete: false,\n      uploadListener: false,\n      // Signifies that we're calling abort() from xhr-utils.js because of a window shutdown.\n      // In that case the termination reason is \"fatal\", not \"end-user abort\".\n      abortError: false,\n      cookieJar: _ownerDocument._cookieJar,\n      bufferStepSize: 1 * 1024 * 1024,\n      // pre-allocate buffer increase step size. init value is 1MB\n      totalReceivedChunkSize: 0\n    };\n  }\n\n  get responseType() {\n    return this.flag.responseType;\n  }\n\n  set responseType(responseType) {\n    const {\n      flag\n    } = this;\n\n    if (this.readyState === READY_STATES.LOADING || this.readyState === READY_STATES.DONE) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    if (this.readyState === READY_STATES.OPENED && flag.synchronous) {\n      throw DOMException.create(this._globalObject, [\"The object does not support the operation or argument.\", \"InvalidAccessError\"]);\n    }\n\n    flag.responseType = responseType;\n  }\n\n  get response() {\n    const {\n      properties\n    } = this;\n\n    if (properties.responseCache) {\n      // Needed because of: https://github.com/jsdom/webidl2js/issues/149\n      return idlUtils.tryWrapperForImpl(properties.responseCache);\n    }\n\n    let res;\n    const responseBuffer = properties.responseBuffer ? properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) : null;\n\n    switch (this.responseType) {\n      case \"\":\n      case \"text\":\n        {\n          res = this.responseText;\n          break;\n        }\n\n      case \"arraybuffer\":\n        {\n          if (!responseBuffer) {\n            return null;\n          }\n\n          res = copyToArrayBufferInNewRealm(responseBuffer, this._globalObject);\n          break;\n        }\n\n      case \"blob\":\n        {\n          if (!responseBuffer) {\n            return null;\n          }\n\n          const contentType = finalMIMEType(this);\n          res = Blob.createImpl(this._globalObject, [[new Uint8Array(responseBuffer)], {\n            type: contentType || \"\"\n          }]);\n          break;\n        }\n\n      case \"document\":\n        {\n          res = this.responseXML;\n          break;\n        }\n\n      case \"json\":\n        {\n          if (this.readyState !== READY_STATES.DONE || !responseBuffer) {\n            res = null;\n          }\n\n          try {\n            res = parseJSONFromBytes(responseBuffer);\n          } catch (e) {\n            res = null;\n          }\n\n          break;\n        }\n    }\n\n    properties.responseCache = res; // Needed because of: https://github.com/jsdom/webidl2js/issues/149\n\n    return idlUtils.tryWrapperForImpl(res);\n  }\n\n  get responseText() {\n    const {\n      properties\n    } = this;\n\n    if (this.responseType !== \"\" && this.responseType !== \"text\") {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    if (this.readyState !== READY_STATES.LOADING && this.readyState !== READY_STATES.DONE) {\n      return \"\";\n    }\n\n    if (properties.responseTextCache) {\n      return properties.responseTextCache;\n    }\n\n    const responseBuffer = properties.responseBuffer ? properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) : null;\n\n    if (!responseBuffer) {\n      return \"\";\n    }\n\n    const fallbackEncoding = finalCharset(this) || whatwgEncoding.getBOMEncoding(responseBuffer) || \"UTF-8\";\n    const res = whatwgEncoding.decode(responseBuffer, fallbackEncoding);\n    properties.responseTextCache = res;\n    return res;\n  }\n\n  get responseXML() {\n    const {\n      flag,\n      properties\n    } = this;\n\n    if (this.responseType !== \"\" && this.responseType !== \"document\") {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    if (this.readyState !== READY_STATES.DONE) {\n      return null;\n    }\n\n    if (properties.responseXMLCache) {\n      return properties.responseXMLCache;\n    }\n\n    const responseBuffer = properties.responseBuffer ? properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) : null;\n\n    if (!responseBuffer) {\n      return null;\n    }\n\n    const contentType = finalMIMEType(this);\n    let isHTML = false;\n    let isXML = false;\n    const parsed = MIMEType.parse(contentType);\n\n    if (parsed) {\n      isHTML = parsed.isHTML();\n      isXML = parsed.isXML();\n\n      if (!isXML && !isHTML) {\n        return null;\n      }\n    }\n\n    if (this.responseType === \"\" && isHTML) {\n      return null;\n    }\n\n    const encoding = finalCharset(this) || whatwgEncoding.getBOMEncoding(responseBuffer) || \"UTF-8\";\n    const resText = whatwgEncoding.decode(responseBuffer, encoding);\n\n    if (!resText) {\n      return null;\n    }\n\n    const res = Document.createImpl(this._globalObject, [], {\n      options: {\n        url: flag.uri,\n        lastModified: new Date(getResponseHeader(this, \"last-modified\")),\n        parsingMode: isHTML ? \"html\" : \"xml\",\n        cookieJar: {\n          setCookieSync: () => undefined,\n          getCookieStringSync: () => \"\"\n        },\n        encoding,\n        parseOptions: this._ownerDocument._parseOptions\n      }\n    });\n\n    try {\n      parseIntoDocument(resText, res);\n    } catch (e) {\n      properties.responseXMLCache = null;\n      return null;\n    }\n\n    res.close();\n    properties.responseXMLCache = res;\n    return res;\n  }\n\n  get timeout() {\n    return this.flag.timeout;\n  }\n\n  set timeout(val) {\n    const {\n      flag,\n      properties\n    } = this;\n\n    if (flag.synchronous) {\n      throw DOMException.create(this._globalObject, [\"The object does not support the operation or argument.\", \"InvalidAccessError\"]);\n    }\n\n    flag.timeout = val;\n    clearTimeout(properties.timeoutId);\n\n    if (val > 0 && properties.timeoutFn) {\n      properties.timeoutId = setTimeout(properties.timeoutFn, Math.max(0, val - (new Date().getTime() - properties.timeoutStart)));\n    } else {\n      properties.timeoutFn = null;\n      properties.timeoutStart = 0;\n    }\n  }\n\n  get withCredentials() {\n    return this.flag.withCredentials;\n  }\n\n  set withCredentials(val) {\n    const {\n      flag,\n      properties\n    } = this;\n\n    if (!(this.readyState === READY_STATES.UNSENT || this.readyState === READY_STATES.OPENED)) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    if (properties.send) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    flag.withCredentials = val;\n  }\n\n  abort() {\n    const {\n      properties\n    } = this; // Terminate the request\n\n    clearTimeout(properties.timeoutId);\n    properties.timeoutFn = null;\n    properties.timeoutStart = 0;\n    const {\n      client\n    } = properties;\n\n    if (client) {\n      client.abort();\n      properties.client = null;\n    }\n\n    if (properties.abortError) {\n      // Special case that ideally shouldn't be going through the public API at all.\n      // Run the https://xhr.spec.whatwg.org/#handle-errors \"fatal\" steps.\n      this.readyState = READY_STATES.DONE;\n      properties.send = false;\n      xhrUtils.setResponseToNetworkError(this);\n      return;\n    }\n\n    if (this.readyState === READY_STATES.OPENED && properties.send || this.readyState === READY_STATES.HEADERS_RECEIVED || this.readyState === READY_STATES.LOADING) {\n      xhrUtils.requestErrorSteps(this, \"abort\");\n    }\n\n    if (this.readyState === READY_STATES.DONE) {\n      this.readyState = READY_STATES.UNSENT;\n      xhrUtils.setResponseToNetworkError(this);\n    }\n  }\n\n  getAllResponseHeaders() {\n    const {\n      properties,\n      readyState\n    } = this;\n\n    if (readyState === READY_STATES.UNSENT || readyState === READY_STATES.OPENED) {\n      return \"\";\n    }\n\n    return Object.keys(properties.responseHeaders).filter(key => properties.filteredResponseHeaders.indexOf(key) === -1).map(key => [key.toLowerCase(), properties.responseHeaders[key]].join(\": \")).join(\"\\r\\n\");\n  }\n\n  getResponseHeader(header) {\n    const {\n      properties,\n      readyState\n    } = this;\n\n    if (readyState === READY_STATES.UNSENT || readyState === READY_STATES.OPENED) {\n      return null;\n    }\n\n    const lcHeader = header.toLowerCase();\n\n    if (properties.filteredResponseHeaders.find(filtered => lcHeader === filtered.toLowerCase())) {\n      return null;\n    }\n\n    return getResponseHeader(this, lcHeader);\n  }\n\n  open(method, uri, asynchronous, user, password) {\n    const {\n      flag,\n      properties,\n      _ownerDocument\n    } = this;\n\n    if (!_ownerDocument) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    if (!tokenRegexp.test(method)) {\n      throw DOMException.create(this._globalObject, [\"The string did not match the expected pattern.\", \"SyntaxError\"]);\n    }\n\n    const upperCaseMethod = method.toUpperCase();\n\n    if (forbiddenRequestMethods.has(upperCaseMethod)) {\n      throw DOMException.create(this._globalObject, [\"The operation is insecure.\", \"SecurityError\"]);\n    }\n\n    const {\n      client\n    } = properties;\n\n    if (client && typeof client.abort === \"function\") {\n      client.abort();\n    }\n\n    if (allowedRequestMethods.has(upperCaseMethod)) {\n      method = upperCaseMethod;\n    }\n\n    if (typeof asynchronous !== \"undefined\") {\n      flag.synchronous = !asynchronous;\n    } else {\n      flag.synchronous = false;\n    }\n\n    if (flag.responseType && flag.synchronous) {\n      throw DOMException.create(this._globalObject, [\"The object does not support the operation or argument.\", \"InvalidAccessError\"]);\n    }\n\n    if (flag.synchronous && flag.timeout) {\n      throw DOMException.create(this._globalObject, [\"The object does not support the operation or argument.\", \"InvalidAccessError\"]);\n    }\n\n    flag.method = method;\n    let urlObj;\n\n    try {\n      urlObj = new URL(uri, documentBaseURLSerialized(_ownerDocument));\n    } catch (e) {\n      throw DOMException.create(this._globalObject, [\"The string did not match the expected pattern.\", \"SyntaxError\"]);\n    }\n\n    if (user || password && !urlObj.username) {\n      flag.auth = {\n        user,\n        pass: password\n      };\n      urlObj.username = \"\";\n      urlObj.password = \"\";\n    }\n\n    flag.uri = urlObj.href;\n    flag.requestHeaders = {};\n    flag.preflight = false;\n    properties.send = false;\n    properties.uploadListener = false;\n    properties.abortError = false;\n    this.responseURL = \"\";\n    readyStateChange(this, READY_STATES.OPENED);\n  }\n\n  overrideMimeType(mime) {\n    const {\n      readyState\n    } = this;\n\n    if (readyState === READY_STATES.LOADING || readyState === READY_STATES.DONE) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    this.flag.overrideMIMEType = \"application/octet-stream\"; // Waiting for better spec: https://github.com/whatwg/xhr/issues/157\n\n    const parsed = MIMEType.parse(mime);\n\n    if (parsed) {\n      this.flag.overrideMIMEType = parsed.essence;\n      const charset = parsed.parameters.get(\"charset\");\n\n      if (charset) {\n        this.flag.overrideCharset = whatwgEncoding.labelToName(charset);\n      }\n    }\n  } // TODO: Add support for URLSearchParams and ReadableStream\n\n\n  send(body) {\n    const {\n      flag,\n      properties,\n      upload,\n      _ownerDocument\n    } = this; // Not per spec, but per tests: https://github.com/whatwg/xhr/issues/65\n\n    if (!_ownerDocument) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    if (this.readyState !== READY_STATES.OPENED || properties.send) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    properties.beforeSend = true;\n\n    try {\n      if (flag.method === \"GET\" || flag.method === \"HEAD\") {\n        body = null;\n      }\n\n      if (body !== null) {\n        let encoding = null;\n        let mimeType = null;\n\n        if (Document.isImpl(body)) {\n          encoding = \"UTF-8\";\n          mimeType = (body._parsingMode === \"html\" ? \"text/html\" : \"application/xml\") + \";charset=UTF-8\";\n          flag.body = fragmentSerialization(body, {\n            requireWellFormed: false\n          });\n        } else {\n          if (typeof body === \"string\") {\n            encoding = \"UTF-8\";\n          }\n\n          const {\n            buffer,\n            formData,\n            contentType\n          } = extractBody(body);\n          mimeType = contentType;\n          flag.body = buffer || formData;\n          flag.formData = Boolean(formData);\n        }\n\n        const existingContentType = xhrUtils.getRequestHeader(flag.requestHeaders, \"content-type\");\n\n        if (mimeType !== null && existingContentType === null) {\n          flag.requestHeaders[\"Content-Type\"] = mimeType;\n        } else if (existingContentType !== null && encoding !== null) {\n          // Waiting for better spec: https://github.com/whatwg/xhr/issues/188. This seems like a good guess at what\n          // the spec will be, in the meantime.\n          const parsed = MIMEType.parse(existingContentType);\n\n          if (parsed) {\n            const charset = parsed.parameters.get(\"charset\");\n\n            if (charset && !asciiCaseInsensitiveMatch(charset, encoding) && encoding !== null) {\n              parsed.parameters.set(\"charset\", encoding);\n              xhrUtils.updateRequestHeader(flag.requestHeaders, \"content-type\", parsed.toString());\n            }\n          }\n        }\n      }\n    } finally {\n      if (properties.beforeSend) {\n        properties.beforeSend = false;\n      } else {\n        throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n      }\n    }\n\n    if (Object.keys(upload._eventListeners).length > 0) {\n      properties.uploadListener = true;\n    } // request doesn't like zero-length bodies\n\n\n    if (flag.body && flag.body.byteLength === 0) {\n      flag.body = null;\n    }\n\n    if (flag.synchronous) {\n      const flagStr = JSON.stringify(flag, function (k, v) {\n        if (this === flag && k === \"requestManager\") {\n          return null;\n        }\n\n        if (this === flag && k === \"pool\" && v) {\n          return {\n            maxSockets: v.maxSockets\n          };\n        }\n\n        return v;\n      });\n      const res = spawnSync(process.execPath, [syncWorkerFile], {\n        input: flagStr,\n        maxBuffer: Infinity\n      });\n\n      if (res.status !== 0) {\n        throw new Error(res.stderr.toString());\n      }\n\n      if (res.error) {\n        if (typeof res.error === \"string\") {\n          res.error = new Error(res.error);\n        }\n\n        throw res.error;\n      }\n\n      const response = JSON.parse(res.stdout.toString());\n      const resProp = response.properties;\n\n      if (resProp.responseBuffer && resProp.responseBuffer.data) {\n        resProp.responseBuffer = Buffer.from(resProp.responseBuffer.data);\n      }\n\n      if (resProp.cookieJar) {\n        resProp.cookieJar = tough.CookieJar.deserializeSync(resProp.cookieJar, _ownerDocument._cookieJar.store);\n      }\n\n      this.readyState = READY_STATES.LOADING;\n      this.status = response.status;\n      this.statusText = response.statusText;\n      this.responseURL = response.responseURL;\n      Object.assign(this.properties, response.properties);\n\n      if (resProp.error) {\n        xhrUtils.dispatchError(this);\n        throw DOMException.create(this._globalObject, [resProp.error, \"NetworkError\"]);\n      } else {\n        const {\n          responseBuffer\n        } = properties;\n        const contentLength = getResponseHeader(this, \"content-length\") || \"0\";\n        const bufferLength = parseInt(contentLength) || responseBuffer.length;\n        const progressObj = {\n          lengthComputable: false\n        };\n\n        if (bufferLength !== 0) {\n          progressObj.total = bufferLength;\n          progressObj.loaded = bufferLength;\n          progressObj.lengthComputable = true;\n        }\n\n        fireAnEvent(\"progress\", this, ProgressEvent, progressObj);\n        readyStateChange(this, READY_STATES.DONE);\n        fireAnEvent(\"load\", this, ProgressEvent, progressObj);\n        fireAnEvent(\"loadend\", this, ProgressEvent, progressObj);\n      }\n    } else {\n      properties.send = true;\n      fireAnEvent(\"loadstart\", this, ProgressEvent);\n      const client = xhrUtils.createClient(this);\n      properties.client = client; // For new client, reset totalReceivedChunkSize and bufferStepSize\n\n      properties.totalReceivedChunkSize = 0;\n      properties.bufferStepSize = 1 * 1024 * 1024;\n      properties.origin = flag.origin;\n      client.on(\"error\", err => {\n        client.removeAllListeners();\n        properties.error = err;\n        xhrUtils.dispatchError(this);\n      });\n      client.on(\"response\", (res, url) => receiveResponse(this, res, url));\n      client.on(\"redirect\", (response, requestHeaders, currentURL) => {\n        const destUrlObj = new URL(requestHeaders.Referer);\n        const urlObj = new URL(currentURL);\n\n        if (destUrlObj.origin !== urlObj.origin && destUrlObj.origin !== flag.origin) {\n          properties.origin = \"null\";\n        }\n\n        requestHeaders.Origin = properties.origin;\n\n        if (flag.origin !== destUrlObj.origin && destUrlObj.protocol !== \"data:\") {\n          if (!xhrUtils.validCORSHeaders(this, response, flag, properties, flag.origin)) {\n            return;\n          }\n\n          if (urlObj.username || urlObj.password) {\n            properties.error = \"Userinfo forbidden in cors redirect\";\n            xhrUtils.dispatchError(this);\n          }\n        }\n      });\n\n      if (body !== null && body !== \"\") {\n        properties.uploadComplete = false;\n        setDispatchProgressEvents(this);\n      } else {\n        properties.uploadComplete = true;\n      }\n\n      if (this.timeout > 0) {\n        properties.timeoutStart = new Date().getTime();\n\n        properties.timeoutFn = () => {\n          client.abort();\n\n          if (!(this.readyState === READY_STATES.UNSENT || this.readyState === READY_STATES.OPENED && !properties.send || this.readyState === READY_STATES.DONE)) {\n            properties.send = false;\n            let stateChanged = false;\n\n            if (!properties.uploadComplete) {\n              fireAnEvent(\"progress\", upload, ProgressEvent);\n              readyStateChange(this, READY_STATES.DONE);\n              fireAnEvent(\"timeout\", upload, ProgressEvent);\n              fireAnEvent(\"loadend\", upload, ProgressEvent);\n              stateChanged = true;\n            }\n\n            fireAnEvent(\"progress\", this, ProgressEvent);\n\n            if (!stateChanged) {\n              readyStateChange(this, READY_STATES.DONE);\n            }\n\n            fireAnEvent(\"timeout\", this, ProgressEvent);\n            fireAnEvent(\"loadend\", this, ProgressEvent);\n          }\n\n          this.readyState = READY_STATES.UNSENT;\n        };\n\n        properties.timeoutId = setTimeout(properties.timeoutFn, this.timeout);\n      }\n    }\n  }\n\n  setRequestHeader(header, value) {\n    const {\n      flag,\n      properties\n    } = this;\n\n    if (this.readyState !== READY_STATES.OPENED || properties.send) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    value = normalizeHeaderValue(value);\n\n    if (!tokenRegexp.test(header) || !fieldValueRegexp.test(value)) {\n      throw DOMException.create(this._globalObject, [\"The string did not match the expected pattern.\", \"SyntaxError\"]);\n    }\n\n    const lcHeader = header.toLowerCase();\n\n    if (forbiddenRequestHeaders.has(lcHeader) || lcHeader.startsWith(\"sec-\") || lcHeader.startsWith(\"proxy-\")) {\n      return;\n    }\n\n    const keys = Object.keys(flag.requestHeaders);\n    let n = keys.length;\n\n    while (n--) {\n      const key = keys[n];\n\n      if (key.toLowerCase() === lcHeader) {\n        flag.requestHeaders[key] += \", \" + value;\n        return;\n      }\n    }\n\n    flag.requestHeaders[header] = value;\n  }\n\n}\n\nsetupForSimpleEventAccessors(XMLHttpRequestImpl.prototype, [\"readystatechange\"]);\n\nfunction readyStateChange(xhr, readyState) {\n  if (xhr.readyState === readyState) {\n    return;\n  }\n\n  xhr.readyState = readyState;\n  fireAnEvent(\"readystatechange\", xhr);\n}\n\nfunction receiveResponse(xhr, response, currentURL) {\n  const {\n    flag,\n    properties\n  } = xhr;\n  const {\n    rawHeaders,\n    statusCode\n  } = response;\n  let byteOffset = 0;\n  const headers = {};\n  const filteredResponseHeaders = [];\n  const headerMap = {};\n  const n = Number(rawHeaders.length);\n\n  for (let i = 0; i < n; i += 2) {\n    const k = rawHeaders[i];\n    const kl = k.toLowerCase();\n    const v = rawHeaders[i + 1];\n\n    if (uniqueResponseHeaders.has(kl)) {\n      if (headerMap[kl] !== undefined) {\n        delete headers[headerMap[kl]];\n      }\n\n      headers[k] = v;\n    } else if (headerMap[kl] !== undefined) {\n      headers[headerMap[kl]] += \", \" + v;\n    } else {\n      headers[k] = v;\n    }\n\n    headerMap[kl] = k;\n  }\n\n  const destUrlObj = new URL(currentURL);\n\n  if (properties.origin !== destUrlObj.origin && destUrlObj.protocol !== \"data:\") {\n    if (!xhrUtils.validCORSHeaders(xhr, response, flag, properties, properties.origin)) {\n      return;\n    }\n\n    const acehStr = response.headers[\"access-control-expose-headers\"];\n    const aceh = new Set(acehStr ? acehStr.trim().toLowerCase().split(xhrUtils.headerListSeparatorRegexp) : []);\n\n    for (const header in headers) {\n      const lcHeader = header.toLowerCase();\n\n      if (!corsSafeResponseHeaders.has(lcHeader) && !aceh.has(lcHeader)) {\n        filteredResponseHeaders.push(header);\n      }\n    }\n  }\n\n  for (const header in headers) {\n    const lcHeader = header.toLowerCase();\n\n    if (forbiddenResponseHeaders.has(lcHeader)) {\n      filteredResponseHeaders.push(header);\n    }\n  }\n\n  xhr.responseURL = destUrlObj.href;\n  xhr.status = statusCode;\n  xhr.statusText = response.statusMessage || HTTP_STATUS_CODES[statusCode] || \"\";\n  properties.responseHeaders = headers;\n  properties.filteredResponseHeaders = filteredResponseHeaders;\n  const contentLength = getResponseHeader(xhr, \"content-length\") || \"0\";\n  const bufferLength = parseInt(contentLength) || 0;\n  const progressObj = {\n    lengthComputable: false\n  };\n  let lastProgressReported;\n\n  if (bufferLength !== 0) {\n    progressObj.total = bufferLength;\n    progressObj.loaded = 0;\n    progressObj.lengthComputable = true;\n  } // pre-allocate buffer.\n\n\n  properties.responseBuffer = Buffer.alloc(properties.bufferStepSize);\n  properties.responseCache = null;\n  properties.responseTextCache = null;\n  properties.responseXMLCache = null;\n  readyStateChange(xhr, READY_STATES.HEADERS_RECEIVED);\n\n  if (!properties.client) {\n    // The request was aborted in reaction to the readystatechange event.\n    return;\n  } // Can't use the client since the client gets the post-ungzipping bytes (which can be greater than the\n  // Content-Length).\n\n\n  response.on(\"data\", chunk => {\n    byteOffset += chunk.length;\n    progressObj.loaded = byteOffset;\n  });\n  properties.client.on(\"data\", chunk => {\n    properties.totalReceivedChunkSize += chunk.length;\n\n    if (properties.totalReceivedChunkSize >= properties.bufferStepSize) {\n      properties.bufferStepSize *= 2;\n\n      while (properties.totalReceivedChunkSize >= properties.bufferStepSize) {\n        properties.bufferStepSize *= 2;\n      }\n\n      const tmpBuf = Buffer.alloc(properties.bufferStepSize);\n      properties.responseBuffer.copy(tmpBuf, 0, 0, properties.responseBuffer.length);\n      properties.responseBuffer = tmpBuf;\n    }\n\n    chunk.copy(properties.responseBuffer, properties.totalReceivedChunkSize - chunk.length, 0, chunk.length);\n    properties.responseCache = null;\n    properties.responseTextCache = null;\n    properties.responseXMLCache = null;\n\n    if (xhr.readyState === READY_STATES.HEADERS_RECEIVED) {\n      xhr.readyState = READY_STATES.LOADING;\n    }\n\n    fireAnEvent(\"readystatechange\", xhr);\n\n    if (progressObj.total !== progressObj.loaded || properties.totalReceivedChunkSize === byteOffset) {\n      if (lastProgressReported !== progressObj.loaded) {\n        // This is a necessary check in the gzip case where we can be getting new data from the client, as it\n        // un-gzips, but no new data has been gotten from the response, so we should not fire a progress event.\n        lastProgressReported = progressObj.loaded;\n        fireAnEvent(\"progress\", xhr, ProgressEvent, progressObj);\n      }\n    }\n  });\n  properties.client.on(\"end\", () => {\n    clearTimeout(properties.timeoutId);\n    properties.timeoutFn = null;\n    properties.timeoutStart = 0;\n    properties.client = null;\n\n    if (lastProgressReported !== progressObj.loaded) {\n      // https://github.com/whatwg/xhr/issues/318\n      fireAnEvent(\"progress\", xhr, ProgressEvent, progressObj);\n    }\n\n    readyStateChange(xhr, READY_STATES.DONE);\n    fireAnEvent(\"load\", xhr, ProgressEvent, progressObj);\n    fireAnEvent(\"loadend\", xhr, ProgressEvent, progressObj);\n  });\n}\n\nfunction setDispatchProgressEvents(xhr) {\n  const {\n    properties,\n    upload\n  } = xhr;\n  const {\n    client\n  } = properties;\n  let total = 0;\n  let lengthComputable = false;\n  const length = client.headers && parseInt(xhrUtils.getRequestHeader(client.headers, \"content-length\"));\n\n  if (length) {\n    total = length;\n    lengthComputable = true;\n  }\n\n  const initProgress = {\n    lengthComputable,\n    total,\n    loaded: 0\n  };\n\n  if (properties.uploadListener) {\n    fireAnEvent(\"loadstart\", upload, ProgressEvent, initProgress);\n  }\n\n  client.on(\"request\", req => {\n    req.on(\"response\", () => {\n      properties.uploadComplete = true;\n\n      if (!properties.uploadListener) {\n        return;\n      }\n\n      const progress = {\n        lengthComputable,\n        total,\n        loaded: total\n      };\n      fireAnEvent(\"progress\", upload, ProgressEvent, progress);\n      fireAnEvent(\"load\", upload, ProgressEvent, progress);\n      fireAnEvent(\"loadend\", upload, ProgressEvent, progress);\n    });\n  });\n}\n\nfunction finalMIMEType(xhr) {\n  const {\n    flag\n  } = xhr;\n  return flag.overrideMIMEType || getResponseHeader(xhr, \"content-type\");\n}\n\nfunction finalCharset(xhr) {\n  const {\n    flag\n  } = xhr;\n\n  if (flag.overrideCharset) {\n    return flag.overrideCharset;\n  }\n\n  const parsedContentType = MIMEType.parse(getResponseHeader(xhr, \"content-type\"));\n\n  if (parsedContentType) {\n    return whatwgEncoding.labelToName(parsedContentType.parameters.get(\"charset\"));\n  }\n\n  return null;\n}\n\nfunction getResponseHeader(xhr, lcHeader) {\n  const {\n    properties\n  } = xhr;\n  const keys = Object.keys(properties.responseHeaders);\n  let n = keys.length;\n\n  while (n--) {\n    const key = keys[n];\n\n    if (key.toLowerCase() === lcHeader) {\n      return properties.responseHeaders[key];\n    }\n  }\n\n  return null;\n}\n\nfunction normalizeHeaderValue(value) {\n  return value.replace(/^[\\x09\\x0A\\x0D\\x20]+/, \"\").replace(/[\\x09\\x0A\\x0D\\x20]+$/, \"\");\n}\n\nfunction extractBody(bodyInit) {\n  // https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n  // except we represent the body as a Node.js Buffer instead,\n  // or a special case for FormData since we want request to handle that. Probably it would be\n  // cleaner (and allow a future without request) if we did the form encoding ourself.\n  if (Blob.isImpl(bodyInit)) {\n    return {\n      buffer: bodyInit._buffer,\n      contentType: bodyInit.type === \"\" ? null : bodyInit.type\n    };\n  } else if (isArrayBuffer(bodyInit)) {\n    return {\n      buffer: Buffer.from(bodyInit),\n      contentType: null\n    };\n  } else if (ArrayBuffer.isView(bodyInit)) {\n    return {\n      buffer: Buffer.from(bodyInit.buffer, bodyInit.byteOffset, bodyInit.byteLength),\n      contentType: null\n    };\n  } else if (FormData.isImpl(bodyInit)) {\n    const formData = [];\n\n    for (const entry of bodyInit._entries) {\n      let val;\n\n      if (Blob.isImpl(entry.value)) {\n        const blob = entry.value;\n        val = {\n          name: entry.name,\n          value: blob._buffer,\n          options: {\n            filename: blob.name,\n            contentType: blob.type,\n            knownLength: blob.size\n          }\n        };\n      } else {\n        val = entry;\n      }\n\n      formData.push(val);\n    }\n\n    return {\n      formData\n    };\n  } // Must be a string\n\n\n  return {\n    buffer: Buffer.from(bodyInit, \"utf-8\"),\n    contentType: \"text/plain;charset=UTF-8\"\n  };\n}\n\nexports.implementation = XMLHttpRequestImpl;","map":{"version":3,"names":["HTTP_STATUS_CODES","require","STATUS_CODES","spawnSync","URL","whatwgEncoding","tough","MIMEType","xhrUtils","DOMException","documentBaseURLSerialized","asciiCaseInsensitiveMatch","idlUtils","Document","Blob","FormData","XMLHttpRequestEventTargetImpl","implementation","XMLHttpRequestUpload","ProgressEvent","isArrayBuffer","parseIntoDocument","fragmentSerialization","setupForSimpleEventAccessors","parseJSONFromBytes","fireAnEvent","copyToArrayBufferInNewRealm","READY_STATES","syncWorkerFile","resolve","tokenRegexp","fieldValueRegexp","forbiddenRequestHeaders","Set","forbiddenResponseHeaders","uniqueResponseHeaders","corsSafeResponseHeaders","allowedRequestMethods","forbiddenRequestMethods","XMLHttpRequestImpl","constructor","window","_ownerDocument","upload","createImpl","readyState","UNSENT","responseURL","status","statusText","flag","synchronous","withCredentials","mimeType","auth","method","undefined","responseType","requestHeaders","referrer","uri","timeout","body","formData","preflight","requestManager","_requestManager","strictSSL","_resourceLoader","_strictSSL","proxy","_proxy","cookieJar","_cookieJar","encoding","_encoding","origin","_origin","userAgent","navigator","properties","beforeSend","send","client","timeoutStart","timeoutId","timeoutFn","responseBuffer","responseCache","responseTextCache","responseXMLCache","responseHeaders","filteredResponseHeaders","error","uploadComplete","uploadListener","abortError","bufferStepSize","totalReceivedChunkSize","LOADING","DONE","create","_globalObject","OPENED","response","tryWrapperForImpl","res","slice","responseText","contentType","finalMIMEType","Uint8Array","type","responseXML","e","fallbackEncoding","finalCharset","getBOMEncoding","decode","isHTML","isXML","parsed","parse","resText","options","url","lastModified","Date","getResponseHeader","parsingMode","setCookieSync","getCookieStringSync","parseOptions","_parseOptions","close","val","clearTimeout","setTimeout","Math","max","getTime","abort","setResponseToNetworkError","HEADERS_RECEIVED","requestErrorSteps","getAllResponseHeaders","Object","keys","filter","key","indexOf","map","toLowerCase","join","header","lcHeader","find","filtered","open","asynchronous","user","password","test","upperCaseMethod","toUpperCase","has","urlObj","username","pass","href","readyStateChange","overrideMimeType","mime","overrideMIMEType","essence","charset","parameters","get","overrideCharset","labelToName","isImpl","_parsingMode","requireWellFormed","buffer","extractBody","Boolean","existingContentType","getRequestHeader","set","updateRequestHeader","toString","_eventListeners","length","byteLength","flagStr","JSON","stringify","k","v","maxSockets","process","execPath","input","maxBuffer","Infinity","Error","stderr","stdout","resProp","data","Buffer","from","CookieJar","deserializeSync","store","assign","dispatchError","contentLength","bufferLength","parseInt","progressObj","lengthComputable","total","loaded","createClient","on","err","removeAllListeners","receiveResponse","currentURL","destUrlObj","Referer","Origin","protocol","validCORSHeaders","setDispatchProgressEvents","stateChanged","setRequestHeader","value","normalizeHeaderValue","startsWith","n","prototype","xhr","rawHeaders","statusCode","byteOffset","headers","headerMap","Number","i","kl","acehStr","aceh","trim","split","headerListSeparatorRegexp","push","statusMessage","lastProgressReported","alloc","chunk","tmpBuf","copy","initProgress","req","progress","parsedContentType","replace","bodyInit","_buffer","ArrayBuffer","isView","entry","_entries","blob","name","filename","knownLength","size","exports"],"sources":["C:/Users/17033/balmco/node_modules/jsdom/lib/jsdom/living/xhr/XMLHttpRequest-impl.js"],"sourcesContent":["\"use strict\";\n\nconst HTTP_STATUS_CODES = require(\"http\").STATUS_CODES;\nconst { spawnSync } = require(\"child_process\");\nconst { URL } = require(\"whatwg-url\");\nconst whatwgEncoding = require(\"whatwg-encoding\");\nconst tough = require(\"tough-cookie\");\nconst MIMEType = require(\"whatwg-mimetype\");\n\nconst xhrUtils = require(\"./xhr-utils\");\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\nconst { documentBaseURLSerialized } = require(\"../helpers/document-base-url\");\nconst { asciiCaseInsensitiveMatch } = require(\"../helpers/strings\");\nconst idlUtils = require(\"../generated/utils\");\nconst Document = require(\"../generated/Document\");\nconst Blob = require(\"../generated/Blob\");\nconst FormData = require(\"../generated/FormData\");\nconst XMLHttpRequestEventTargetImpl = require(\"./XMLHttpRequestEventTarget-impl\").implementation;\nconst XMLHttpRequestUpload = require(\"../generated/XMLHttpRequestUpload\");\nconst ProgressEvent = require(\"../generated/ProgressEvent\");\nconst { isArrayBuffer } = require(\"../generated/utils\");\nconst { parseIntoDocument } = require(\"../../browser/parser\");\nconst { fragmentSerialization } = require(\"../domparsing/serialization\");\nconst { setupForSimpleEventAccessors } = require(\"../helpers/create-event-accessor\");\nconst { parseJSONFromBytes } = require(\"../helpers/json\");\nconst { fireAnEvent } = require(\"../helpers/events\");\nconst { copyToArrayBufferInNewRealm } = require(\"../helpers/binary-data\");\n\nconst { READY_STATES } = xhrUtils;\n\nconst syncWorkerFile = require.resolve ? require.resolve(\"./xhr-sync-worker.js\") : null;\n\nconst tokenRegexp = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/;\nconst fieldValueRegexp = /^[ \\t]*(?:[\\x21-\\x7E\\x80-\\xFF](?:[ \\t][\\x21-\\x7E\\x80-\\xFF])?)*[ \\t]*$/;\n\nconst forbiddenRequestHeaders = new Set([\n  \"accept-charset\",\n  \"accept-encoding\",\n  \"access-control-request-headers\",\n  \"access-control-request-method\",\n  \"connection\",\n  \"content-length\",\n  \"cookie\",\n  \"cookie2\",\n  \"date\",\n  \"dnt\",\n  \"expect\",\n  \"host\",\n  \"keep-alive\",\n  \"origin\",\n  \"referer\",\n  \"te\",\n  \"trailer\",\n  \"transfer-encoding\",\n  \"upgrade\",\n  \"via\"\n]);\nconst forbiddenResponseHeaders = new Set([\n  \"set-cookie\",\n  \"set-cookie2\"\n]);\nconst uniqueResponseHeaders = new Set([\n  \"content-type\",\n  \"content-length\",\n  \"user-agent\",\n  \"referer\",\n  \"host\",\n  \"authorization\",\n  \"proxy-authorization\",\n  \"if-modified-since\",\n  \"if-unmodified-since\",\n  \"from\",\n  \"location\",\n  \"max-forwards\"\n]);\nconst corsSafeResponseHeaders = new Set([\n  \"cache-control\",\n  \"content-language\",\n  \"content-length\",\n  \"content-type\",\n  \"expires\",\n  \"last-modified\",\n  \"pragma\"\n]);\n\nconst allowedRequestMethods = new Set([\"OPTIONS\", \"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\"]);\nconst forbiddenRequestMethods = new Set([\"TRACK\", \"TRACE\", \"CONNECT\"]);\n\nclass XMLHttpRequestImpl extends XMLHttpRequestEventTargetImpl {\n  constructor(window) {\n    super(window);\n\n    // Avoid running `_ownerDocument` getter multiple times in the constructor:\n    const { _ownerDocument } = this;\n\n    this.upload = XMLHttpRequestUpload.createImpl(window);\n\n    this.readyState = READY_STATES.UNSENT;\n    this.responseURL = \"\";\n    this.status = 0;\n    this.statusText = \"\";\n\n    this.flag = {\n      synchronous: false,\n      withCredentials: false,\n      mimeType: null,\n      auth: null,\n      method: undefined,\n      responseType: \"\",\n      requestHeaders: {},\n      referrer: _ownerDocument.URL,\n      uri: \"\",\n      timeout: 0,\n      body: undefined,\n      formData: false,\n      preflight: false,\n      requestManager: _ownerDocument._requestManager,\n      strictSSL: window._resourceLoader._strictSSL,\n      proxy: window._resourceLoader._proxy,\n      cookieJar: _ownerDocument._cookieJar,\n      encoding: _ownerDocument._encoding,\n      origin: window._origin,\n      userAgent: window.navigator.userAgent\n    };\n\n    this.properties = {\n      beforeSend: false,\n      send: false,\n      client: null,\n\n      timeoutStart: 0,\n      timeoutId: 0,\n      timeoutFn: null,\n\n      responseBuffer: null,\n      responseCache: null,\n      responseTextCache: null,\n      responseXMLCache: null,\n\n      responseHeaders: {},\n      filteredResponseHeaders: [],\n\n      error: \"\",\n      uploadComplete: false,\n      uploadListener: false,\n\n      // Signifies that we're calling abort() from xhr-utils.js because of a window shutdown.\n      // In that case the termination reason is \"fatal\", not \"end-user abort\".\n      abortError: false,\n\n      cookieJar: _ownerDocument._cookieJar,\n      bufferStepSize: 1 * 1024 * 1024, // pre-allocate buffer increase step size. init value is 1MB\n      totalReceivedChunkSize: 0\n    };\n  }\n\n  get responseType() {\n    return this.flag.responseType;\n  }\n  set responseType(responseType) {\n    const { flag } = this;\n    if (this.readyState === READY_STATES.LOADING || this.readyState === READY_STATES.DONE) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n    if (this.readyState === READY_STATES.OPENED && flag.synchronous) {\n      throw DOMException.create(this._globalObject, [\n        \"The object does not support the operation or argument.\",\n        \"InvalidAccessError\"\n      ]);\n    }\n    flag.responseType = responseType;\n  }\n\n  get response() {\n    const { properties } = this;\n    if (properties.responseCache) {\n      // Needed because of: https://github.com/jsdom/webidl2js/issues/149\n      return idlUtils.tryWrapperForImpl(properties.responseCache);\n    }\n    let res;\n\n    const responseBuffer = properties.responseBuffer ?\n      properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) :\n      null;\n\n    switch (this.responseType) {\n      case \"\":\n      case \"text\": {\n        res = this.responseText;\n        break;\n      }\n      case \"arraybuffer\": {\n        if (!responseBuffer) {\n          return null;\n        }\n        res = copyToArrayBufferInNewRealm(responseBuffer, this._globalObject);\n        break;\n      }\n      case \"blob\": {\n        if (!responseBuffer) {\n          return null;\n        }\n        const contentType = finalMIMEType(this);\n        res = Blob.createImpl(this._globalObject, [\n          [new Uint8Array(responseBuffer)],\n          { type: contentType || \"\" }\n        ]);\n        break;\n      }\n      case \"document\": {\n        res = this.responseXML;\n        break;\n      }\n      case \"json\": {\n        if (this.readyState !== READY_STATES.DONE || !responseBuffer) {\n          res = null;\n        }\n\n        try {\n          res = parseJSONFromBytes(responseBuffer);\n        } catch (e) {\n          res = null;\n        }\n        break;\n      }\n    }\n    properties.responseCache = res;\n    // Needed because of: https://github.com/jsdom/webidl2js/issues/149\n    return idlUtils.tryWrapperForImpl(res);\n  }\n  get responseText() {\n    const { properties } = this;\n    if (this.responseType !== \"\" && this.responseType !== \"text\") {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n    if (this.readyState !== READY_STATES.LOADING && this.readyState !== READY_STATES.DONE) {\n      return \"\";\n    }\n    if (properties.responseTextCache) {\n      return properties.responseTextCache;\n    }\n    const responseBuffer = properties.responseBuffer ?\n      properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) :\n      null;\n\n    if (!responseBuffer) {\n      return \"\";\n    }\n\n    const fallbackEncoding = finalCharset(this) || whatwgEncoding.getBOMEncoding(responseBuffer) || \"UTF-8\";\n    const res = whatwgEncoding.decode(responseBuffer, fallbackEncoding);\n\n    properties.responseTextCache = res;\n    return res;\n  }\n  get responseXML() {\n    const { flag, properties } = this;\n    if (this.responseType !== \"\" && this.responseType !== \"document\") {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n    if (this.readyState !== READY_STATES.DONE) {\n      return null;\n    }\n    if (properties.responseXMLCache) {\n      return properties.responseXMLCache;\n    }\n    const responseBuffer = properties.responseBuffer ?\n      properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) :\n      null;\n\n    if (!responseBuffer) {\n      return null;\n    }\n\n    const contentType = finalMIMEType(this);\n    let isHTML = false;\n    let isXML = false;\n    const parsed = MIMEType.parse(contentType);\n    if (parsed) {\n      isHTML = parsed.isHTML();\n      isXML = parsed.isXML();\n      if (!isXML && !isHTML) {\n        return null;\n      }\n    }\n\n    if (this.responseType === \"\" && isHTML) {\n      return null;\n    }\n\n    const encoding = finalCharset(this) || whatwgEncoding.getBOMEncoding(responseBuffer) || \"UTF-8\";\n    const resText = whatwgEncoding.decode(responseBuffer, encoding);\n\n    if (!resText) {\n      return null;\n    }\n    const res = Document.createImpl(this._globalObject, [], {\n      options: {\n        url: flag.uri,\n        lastModified: new Date(getResponseHeader(this, \"last-modified\")),\n        parsingMode: isHTML ? \"html\" : \"xml\",\n        cookieJar: { setCookieSync: () => undefined, getCookieStringSync: () => \"\" },\n        encoding,\n        parseOptions: this._ownerDocument._parseOptions\n      }\n    });\n    try {\n      parseIntoDocument(resText, res);\n    } catch (e) {\n      properties.responseXMLCache = null;\n      return null;\n    }\n    res.close();\n    properties.responseXMLCache = res;\n    return res;\n  }\n\n  get timeout() {\n    return this.flag.timeout;\n  }\n  set timeout(val) {\n    const { flag, properties } = this;\n    if (flag.synchronous) {\n      throw DOMException.create(this._globalObject, [\n        \"The object does not support the operation or argument.\",\n        \"InvalidAccessError\"\n      ]);\n    }\n    flag.timeout = val;\n    clearTimeout(properties.timeoutId);\n    if (val > 0 && properties.timeoutFn) {\n      properties.timeoutId = setTimeout(\n        properties.timeoutFn,\n        Math.max(0, val - ((new Date()).getTime() - properties.timeoutStart))\n      );\n    } else {\n      properties.timeoutFn = null;\n      properties.timeoutStart = 0;\n    }\n  }\n\n  get withCredentials() {\n    return this.flag.withCredentials;\n  }\n  set withCredentials(val) {\n    const { flag, properties } = this;\n    if (!(this.readyState === READY_STATES.UNSENT || this.readyState === READY_STATES.OPENED)) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n    if (properties.send) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n    flag.withCredentials = val;\n  }\n\n  abort() {\n    const { properties } = this;\n    // Terminate the request\n    clearTimeout(properties.timeoutId);\n    properties.timeoutFn = null;\n    properties.timeoutStart = 0;\n\n    const { client } = properties;\n    if (client) {\n      client.abort();\n      properties.client = null;\n    }\n\n    if (properties.abortError) {\n      // Special case that ideally shouldn't be going through the public API at all.\n      // Run the https://xhr.spec.whatwg.org/#handle-errors \"fatal\" steps.\n      this.readyState = READY_STATES.DONE;\n      properties.send = false;\n      xhrUtils.setResponseToNetworkError(this);\n      return;\n    }\n\n    if ((this.readyState === READY_STATES.OPENED && properties.send) ||\n        this.readyState === READY_STATES.HEADERS_RECEIVED ||\n        this.readyState === READY_STATES.LOADING) {\n      xhrUtils.requestErrorSteps(this, \"abort\");\n    }\n\n    if (this.readyState === READY_STATES.DONE) {\n      this.readyState = READY_STATES.UNSENT;\n\n      xhrUtils.setResponseToNetworkError(this);\n    }\n  }\n  getAllResponseHeaders() {\n    const { properties, readyState } = this;\n    if (readyState === READY_STATES.UNSENT || readyState === READY_STATES.OPENED) {\n      return \"\";\n    }\n    return Object.keys(properties.responseHeaders)\n      .filter(key => properties.filteredResponseHeaders.indexOf(key) === -1)\n      .map(key => [key.toLowerCase(), properties.responseHeaders[key]].join(\": \"))\n      .join(\"\\r\\n\");\n  }\n\n  getResponseHeader(header) {\n    const { properties, readyState } = this;\n    if (readyState === READY_STATES.UNSENT || readyState === READY_STATES.OPENED) {\n      return null;\n    }\n    const lcHeader = header.toLowerCase();\n    if (properties.filteredResponseHeaders.find(filtered => lcHeader === filtered.toLowerCase())) {\n      return null;\n    }\n    return getResponseHeader(this, lcHeader);\n  }\n\n  open(method, uri, asynchronous, user, password) {\n    const { flag, properties, _ownerDocument } = this;\n    if (!_ownerDocument) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    if (!tokenRegexp.test(method)) {\n      throw DOMException.create(this._globalObject, [\n        \"The string did not match the expected pattern.\",\n        \"SyntaxError\"\n      ]);\n    }\n    const upperCaseMethod = method.toUpperCase();\n    if (forbiddenRequestMethods.has(upperCaseMethod)) {\n      throw DOMException.create(this._globalObject, [\"The operation is insecure.\", \"SecurityError\"]);\n    }\n\n    const { client } = properties;\n    if (client && typeof client.abort === \"function\") {\n      client.abort();\n    }\n\n    if (allowedRequestMethods.has(upperCaseMethod)) {\n      method = upperCaseMethod;\n    }\n    if (typeof asynchronous !== \"undefined\") {\n      flag.synchronous = !asynchronous;\n    } else {\n      flag.synchronous = false;\n    }\n    if (flag.responseType && flag.synchronous) {\n      throw DOMException.create(this._globalObject, [\n        \"The object does not support the operation or argument.\",\n        \"InvalidAccessError\"\n      ]);\n    }\n    if (flag.synchronous && flag.timeout) {\n      throw DOMException.create(this._globalObject, [\n        \"The object does not support the operation or argument.\",\n        \"InvalidAccessError\"\n      ]);\n    }\n    flag.method = method;\n\n    let urlObj;\n    try {\n      urlObj = new URL(uri, documentBaseURLSerialized(_ownerDocument));\n    } catch (e) {\n      throw DOMException.create(this._globalObject, [\n        \"The string did not match the expected pattern.\",\n        \"SyntaxError\"\n      ]);\n    }\n\n    if (user || (password && !urlObj.username)) {\n      flag.auth = {\n        user,\n        pass: password\n      };\n      urlObj.username = \"\";\n      urlObj.password = \"\";\n    }\n\n    flag.uri = urlObj.href;\n    flag.requestHeaders = {};\n    flag.preflight = false;\n\n    properties.send = false;\n    properties.uploadListener = false;\n    properties.abortError = false;\n    this.responseURL = \"\";\n    readyStateChange(this, READY_STATES.OPENED);\n  }\n\n  overrideMimeType(mime) {\n    const { readyState } = this;\n    if (readyState === READY_STATES.LOADING || readyState === READY_STATES.DONE) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    this.flag.overrideMIMEType = \"application/octet-stream\";\n\n    // Waiting for better spec: https://github.com/whatwg/xhr/issues/157\n    const parsed = MIMEType.parse(mime);\n    if (parsed) {\n      this.flag.overrideMIMEType = parsed.essence;\n\n      const charset = parsed.parameters.get(\"charset\");\n      if (charset) {\n        this.flag.overrideCharset = whatwgEncoding.labelToName(charset);\n      }\n    }\n  }\n\n  // TODO: Add support for URLSearchParams and ReadableStream\n  send(body) {\n    const { flag, properties, upload, _ownerDocument } = this;\n    // Not per spec, but per tests: https://github.com/whatwg/xhr/issues/65\n    if (!_ownerDocument) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    if (this.readyState !== READY_STATES.OPENED || properties.send) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    properties.beforeSend = true;\n\n    try {\n      if (flag.method === \"GET\" || flag.method === \"HEAD\") {\n        body = null;\n      }\n\n      if (body !== null) {\n        let encoding = null;\n        let mimeType = null;\n\n        if (Document.isImpl(body)) {\n          encoding = \"UTF-8\";\n          mimeType = (body._parsingMode === \"html\" ? \"text/html\" : \"application/xml\") + \";charset=UTF-8\";\n          flag.body = fragmentSerialization(body, { requireWellFormed: false });\n        } else {\n          if (typeof body === \"string\") {\n            encoding = \"UTF-8\";\n          }\n          const { buffer, formData, contentType } = extractBody(body);\n          mimeType = contentType;\n          flag.body = buffer || formData;\n          flag.formData = Boolean(formData);\n        }\n\n        const existingContentType = xhrUtils.getRequestHeader(flag.requestHeaders, \"content-type\");\n        if (mimeType !== null && existingContentType === null) {\n          flag.requestHeaders[\"Content-Type\"] = mimeType;\n        } else if (existingContentType !== null && encoding !== null) {\n          // Waiting for better spec: https://github.com/whatwg/xhr/issues/188. This seems like a good guess at what\n          // the spec will be, in the meantime.\n          const parsed = MIMEType.parse(existingContentType);\n          if (parsed) {\n            const charset = parsed.parameters.get(\"charset\");\n            if (charset && !asciiCaseInsensitiveMatch(charset, encoding) && encoding !== null) {\n              parsed.parameters.set(\"charset\", encoding);\n              xhrUtils.updateRequestHeader(flag.requestHeaders, \"content-type\", parsed.toString());\n            }\n          }\n        }\n      }\n    } finally {\n      if (properties.beforeSend) {\n        properties.beforeSend = false;\n      } else {\n        throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n      }\n    }\n\n    if (Object.keys(upload._eventListeners).length > 0) {\n      properties.uploadListener = true;\n    }\n\n    // request doesn't like zero-length bodies\n    if (flag.body && flag.body.byteLength === 0) {\n      flag.body = null;\n    }\n\n    if (flag.synchronous) {\n      const flagStr = JSON.stringify(flag, function (k, v) {\n        if (this === flag && k === \"requestManager\") {\n          return null;\n        }\n        if (this === flag && k === \"pool\" && v) {\n          return { maxSockets: v.maxSockets };\n        }\n        return v;\n      });\n      const res = spawnSync(\n        process.execPath,\n        [syncWorkerFile],\n        { input: flagStr, maxBuffer: Infinity }\n      );\n      if (res.status !== 0) {\n        throw new Error(res.stderr.toString());\n      }\n      if (res.error) {\n        if (typeof res.error === \"string\") {\n          res.error = new Error(res.error);\n        }\n        throw res.error;\n      }\n\n      const response = JSON.parse(res.stdout.toString());\n      const resProp = response.properties;\n      if (resProp.responseBuffer && resProp.responseBuffer.data) {\n        resProp.responseBuffer = Buffer.from(resProp.responseBuffer.data);\n      }\n      if (resProp.cookieJar) {\n        resProp.cookieJar = tough.CookieJar.deserializeSync(\n          resProp.cookieJar,\n          _ownerDocument._cookieJar.store\n        );\n      }\n\n      this.readyState = READY_STATES.LOADING;\n      this.status = response.status;\n      this.statusText = response.statusText;\n      this.responseURL = response.responseURL;\n      Object.assign(this.properties, response.properties);\n\n      if (resProp.error) {\n        xhrUtils.dispatchError(this);\n        throw DOMException.create(this._globalObject, [resProp.error, \"NetworkError\"]);\n      } else {\n        const { responseBuffer } = properties;\n        const contentLength = getResponseHeader(this, \"content-length\") || \"0\";\n        const bufferLength = parseInt(contentLength) || responseBuffer.length;\n        const progressObj = { lengthComputable: false };\n        if (bufferLength !== 0) {\n          progressObj.total = bufferLength;\n          progressObj.loaded = bufferLength;\n          progressObj.lengthComputable = true;\n        }\n        fireAnEvent(\"progress\", this, ProgressEvent, progressObj);\n        readyStateChange(this, READY_STATES.DONE);\n        fireAnEvent(\"load\", this, ProgressEvent, progressObj);\n        fireAnEvent(\"loadend\", this, ProgressEvent, progressObj);\n      }\n    } else {\n      properties.send = true;\n\n      fireAnEvent(\"loadstart\", this, ProgressEvent);\n\n      const client = xhrUtils.createClient(this);\n\n      properties.client = client;\n      // For new client, reset totalReceivedChunkSize and bufferStepSize\n      properties.totalReceivedChunkSize = 0;\n      properties.bufferStepSize = 1 * 1024 * 1024;\n\n      properties.origin = flag.origin;\n\n      client.on(\"error\", err => {\n        client.removeAllListeners();\n        properties.error = err;\n        xhrUtils.dispatchError(this);\n      });\n\n      client.on(\"response\", (res, url) => receiveResponse(this, res, url));\n\n      client.on(\"redirect\", (response, requestHeaders, currentURL) => {\n        const destUrlObj = new URL(requestHeaders.Referer);\n        const urlObj = new URL(currentURL);\n\n        if (destUrlObj.origin !== urlObj.origin && destUrlObj.origin !== flag.origin) {\n          properties.origin = \"null\";\n        }\n\n        requestHeaders.Origin = properties.origin;\n\n        if (flag.origin !== destUrlObj.origin &&\n            destUrlObj.protocol !== \"data:\") {\n          if (!xhrUtils.validCORSHeaders(this, response, flag, properties, flag.origin)) {\n            return;\n          }\n          if (urlObj.username || urlObj.password) {\n            properties.error = \"Userinfo forbidden in cors redirect\";\n            xhrUtils.dispatchError(this);\n          }\n        }\n      });\n      if (body !== null && body !== \"\") {\n        properties.uploadComplete = false;\n        setDispatchProgressEvents(this);\n      } else {\n        properties.uploadComplete = true;\n      }\n      if (this.timeout > 0) {\n        properties.timeoutStart = (new Date()).getTime();\n        properties.timeoutFn = () => {\n          client.abort();\n          if (!(this.readyState === READY_STATES.UNSENT ||\n              (this.readyState === READY_STATES.OPENED && !properties.send) ||\n              this.readyState === READY_STATES.DONE)) {\n            properties.send = false;\n            let stateChanged = false;\n            if (!properties.uploadComplete) {\n              fireAnEvent(\"progress\", upload, ProgressEvent);\n              readyStateChange(this, READY_STATES.DONE);\n              fireAnEvent(\"timeout\", upload, ProgressEvent);\n              fireAnEvent(\"loadend\", upload, ProgressEvent);\n              stateChanged = true;\n            }\n            fireAnEvent(\"progress\", this, ProgressEvent);\n            if (!stateChanged) {\n              readyStateChange(this, READY_STATES.DONE);\n            }\n            fireAnEvent(\"timeout\", this, ProgressEvent);\n            fireAnEvent(\"loadend\", this, ProgressEvent);\n          }\n          this.readyState = READY_STATES.UNSENT;\n        };\n        properties.timeoutId = setTimeout(properties.timeoutFn, this.timeout);\n      }\n    }\n  }\n\n  setRequestHeader(header, value) {\n    const { flag, properties } = this;\n\n    if (this.readyState !== READY_STATES.OPENED || properties.send) {\n      throw DOMException.create(this._globalObject, [\"The object is in an invalid state.\", \"InvalidStateError\"]);\n    }\n\n    value = normalizeHeaderValue(value);\n\n    if (!tokenRegexp.test(header) || !fieldValueRegexp.test(value)) {\n      throw DOMException.create(this._globalObject, [\n        \"The string did not match the expected pattern.\",\n        \"SyntaxError\"\n      ]);\n    }\n\n    const lcHeader = header.toLowerCase();\n\n    if (forbiddenRequestHeaders.has(lcHeader) || lcHeader.startsWith(\"sec-\") || lcHeader.startsWith(\"proxy-\")) {\n      return;\n    }\n\n    const keys = Object.keys(flag.requestHeaders);\n    let n = keys.length;\n    while (n--) {\n      const key = keys[n];\n      if (key.toLowerCase() === lcHeader) {\n        flag.requestHeaders[key] += \", \" + value;\n        return;\n      }\n    }\n    flag.requestHeaders[header] = value;\n  }\n}\n\nsetupForSimpleEventAccessors(XMLHttpRequestImpl.prototype, [\"readystatechange\"]);\n\nfunction readyStateChange(xhr, readyState) {\n  if (xhr.readyState === readyState) {\n    return;\n  }\n\n  xhr.readyState = readyState;\n\n  fireAnEvent(\"readystatechange\", xhr);\n}\n\nfunction receiveResponse(xhr, response, currentURL) {\n  const { flag, properties } = xhr;\n  const { rawHeaders, statusCode } = response;\n\n  let byteOffset = 0;\n\n  const headers = {};\n  const filteredResponseHeaders = [];\n  const headerMap = {};\n  const n = Number(rawHeaders.length);\n  for (let i = 0; i < n; i += 2) {\n    const k = rawHeaders[i];\n    const kl = k.toLowerCase();\n    const v = rawHeaders[i + 1];\n    if (uniqueResponseHeaders.has(kl)) {\n      if (headerMap[kl] !== undefined) {\n        delete headers[headerMap[kl]];\n      }\n      headers[k] = v;\n    } else if (headerMap[kl] !== undefined) {\n      headers[headerMap[kl]] += \", \" + v;\n    } else {\n      headers[k] = v;\n    }\n    headerMap[kl] = k;\n  }\n\n  const destUrlObj = new URL(currentURL);\n  if (properties.origin !== destUrlObj.origin &&\n      destUrlObj.protocol !== \"data:\") {\n    if (!xhrUtils.validCORSHeaders(xhr, response, flag, properties, properties.origin)) {\n      return;\n    }\n    const acehStr = response.headers[\"access-control-expose-headers\"];\n    const aceh = new Set(acehStr ? acehStr.trim().toLowerCase().split(xhrUtils.headerListSeparatorRegexp) : []);\n    for (const header in headers) {\n      const lcHeader = header.toLowerCase();\n      if (!corsSafeResponseHeaders.has(lcHeader) && !aceh.has(lcHeader)) {\n        filteredResponseHeaders.push(header);\n      }\n    }\n  }\n\n  for (const header in headers) {\n    const lcHeader = header.toLowerCase();\n    if (forbiddenResponseHeaders.has(lcHeader)) {\n      filteredResponseHeaders.push(header);\n    }\n  }\n\n  xhr.responseURL = destUrlObj.href;\n\n  xhr.status = statusCode;\n  xhr.statusText = response.statusMessage || HTTP_STATUS_CODES[statusCode] || \"\";\n\n  properties.responseHeaders = headers;\n  properties.filteredResponseHeaders = filteredResponseHeaders;\n\n  const contentLength = getResponseHeader(xhr, \"content-length\") || \"0\";\n  const bufferLength = parseInt(contentLength) || 0;\n  const progressObj = { lengthComputable: false };\n  let lastProgressReported;\n  if (bufferLength !== 0) {\n    progressObj.total = bufferLength;\n    progressObj.loaded = 0;\n    progressObj.lengthComputable = true;\n  }\n  // pre-allocate buffer.\n  properties.responseBuffer = Buffer.alloc(properties.bufferStepSize);\n  properties.responseCache = null;\n  properties.responseTextCache = null;\n  properties.responseXMLCache = null;\n  readyStateChange(xhr, READY_STATES.HEADERS_RECEIVED);\n\n  if (!properties.client) {\n    // The request was aborted in reaction to the readystatechange event.\n    return;\n  }\n\n  // Can't use the client since the client gets the post-ungzipping bytes (which can be greater than the\n  // Content-Length).\n  response.on(\"data\", chunk => {\n    byteOffset += chunk.length;\n    progressObj.loaded = byteOffset;\n  });\n\n  properties.client.on(\"data\", chunk => {\n    properties.totalReceivedChunkSize += chunk.length;\n    if (properties.totalReceivedChunkSize >= properties.bufferStepSize) {\n      properties.bufferStepSize *= 2;\n      while (properties.totalReceivedChunkSize >= properties.bufferStepSize) {\n        properties.bufferStepSize *= 2;\n      }\n      const tmpBuf = Buffer.alloc(properties.bufferStepSize);\n      properties.responseBuffer.copy(tmpBuf, 0, 0, properties.responseBuffer.length);\n      properties.responseBuffer = tmpBuf;\n    }\n    chunk.copy(properties.responseBuffer, properties.totalReceivedChunkSize - chunk.length, 0, chunk.length);\n    properties.responseCache = null;\n    properties.responseTextCache = null;\n    properties.responseXMLCache = null;\n\n    if (xhr.readyState === READY_STATES.HEADERS_RECEIVED) {\n      xhr.readyState = READY_STATES.LOADING;\n    }\n    fireAnEvent(\"readystatechange\", xhr);\n\n    if (progressObj.total !== progressObj.loaded || properties.totalReceivedChunkSize === byteOffset) {\n      if (lastProgressReported !== progressObj.loaded) {\n        // This is a necessary check in the gzip case where we can be getting new data from the client, as it\n        // un-gzips, but no new data has been gotten from the response, so we should not fire a progress event.\n        lastProgressReported = progressObj.loaded;\n        fireAnEvent(\"progress\", xhr, ProgressEvent, progressObj);\n      }\n    }\n  });\n  properties.client.on(\"end\", () => {\n    clearTimeout(properties.timeoutId);\n    properties.timeoutFn = null;\n    properties.timeoutStart = 0;\n    properties.client = null;\n    if (lastProgressReported !== progressObj.loaded) {\n      // https://github.com/whatwg/xhr/issues/318\n      fireAnEvent(\"progress\", xhr, ProgressEvent, progressObj);\n    }\n    readyStateChange(xhr, READY_STATES.DONE);\n    fireAnEvent(\"load\", xhr, ProgressEvent, progressObj);\n    fireAnEvent(\"loadend\", xhr, ProgressEvent, progressObj);\n  });\n}\n\nfunction setDispatchProgressEvents(xhr) {\n  const { properties, upload } = xhr;\n  const { client } = properties;\n\n  let total = 0;\n  let lengthComputable = false;\n  const length = client.headers && parseInt(xhrUtils.getRequestHeader(client.headers, \"content-length\"));\n  if (length) {\n    total = length;\n    lengthComputable = true;\n  }\n  const initProgress = {\n    lengthComputable,\n    total,\n    loaded: 0\n  };\n\n  if (properties.uploadListener) {\n    fireAnEvent(\"loadstart\", upload, ProgressEvent, initProgress);\n  }\n\n  client.on(\"request\", req => {\n    req.on(\"response\", () => {\n      properties.uploadComplete = true;\n\n      if (!properties.uploadListener) {\n        return;\n      }\n\n      const progress = {\n        lengthComputable,\n        total,\n        loaded: total\n      };\n      fireAnEvent(\"progress\", upload, ProgressEvent, progress);\n      fireAnEvent(\"load\", upload, ProgressEvent, progress);\n      fireAnEvent(\"loadend\", upload, ProgressEvent, progress);\n    });\n  });\n}\n\nfunction finalMIMEType(xhr) {\n  const { flag } = xhr;\n  return flag.overrideMIMEType || getResponseHeader(xhr, \"content-type\");\n}\n\nfunction finalCharset(xhr) {\n  const { flag } = xhr;\n  if (flag.overrideCharset) {\n    return flag.overrideCharset;\n  }\n  const parsedContentType = MIMEType.parse(getResponseHeader(xhr, \"content-type\"));\n  if (parsedContentType) {\n    return whatwgEncoding.labelToName(parsedContentType.parameters.get(\"charset\"));\n  }\n  return null;\n}\n\nfunction getResponseHeader(xhr, lcHeader) {\n  const { properties } = xhr;\n  const keys = Object.keys(properties.responseHeaders);\n  let n = keys.length;\n  while (n--) {\n    const key = keys[n];\n    if (key.toLowerCase() === lcHeader) {\n      return properties.responseHeaders[key];\n    }\n  }\n  return null;\n}\n\nfunction normalizeHeaderValue(value) {\n  return value.replace(/^[\\x09\\x0A\\x0D\\x20]+/, \"\").replace(/[\\x09\\x0A\\x0D\\x20]+$/, \"\");\n}\n\nfunction extractBody(bodyInit) {\n  // https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n  // except we represent the body as a Node.js Buffer instead,\n  // or a special case for FormData since we want request to handle that. Probably it would be\n  // cleaner (and allow a future without request) if we did the form encoding ourself.\n\n  if (Blob.isImpl(bodyInit)) {\n    return {\n      buffer: bodyInit._buffer,\n      contentType: bodyInit.type === \"\" ? null : bodyInit.type\n    };\n  } else if (isArrayBuffer(bodyInit)) {\n    return {\n      buffer: Buffer.from(bodyInit),\n      contentType: null\n    };\n  } else if (ArrayBuffer.isView(bodyInit)) {\n    return {\n      buffer: Buffer.from(bodyInit.buffer, bodyInit.byteOffset, bodyInit.byteLength),\n      contentType: null\n    };\n  } else if (FormData.isImpl(bodyInit)) {\n    const formData = [];\n    for (const entry of bodyInit._entries) {\n      let val;\n      if (Blob.isImpl(entry.value)) {\n        const blob = entry.value;\n        val = {\n          name: entry.name,\n          value: blob._buffer,\n          options: {\n            filename: blob.name,\n            contentType: blob.type,\n            knownLength: blob.size\n          }\n        };\n      } else {\n        val = entry;\n      }\n\n      formData.push(val);\n    }\n\n    return { formData };\n  }\n\n  // Must be a string\n  return {\n    buffer: Buffer.from(bodyInit, \"utf-8\"),\n    contentType: \"text/plain;charset=UTF-8\"\n  };\n}\n\nexports.implementation = XMLHttpRequestImpl;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}