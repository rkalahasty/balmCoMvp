{"ast":null,"code":"\"use strict\";\n\nconst xnv = require(\"xml-name-validator\");\n\nconst attributeUtils = require(\"./attributes\");\n\nconst {\n  NAMESPACES,\n  VOID_ELEMENTS,\n  NODE_TYPES\n} = require(\"./constants\");\n\nconst XML_CHAR = /^(\\x09|\\x0A|\\x0D|[\\x20-\\uD7FF]|[\\uE000-\\uFFFD]|(?:[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]))*$/;\nconst PUBID_CHAR = /^(\\x20|\\x0D|\\x0A|[a-zA-Z0-9]|[-'()+,./:=?;!*#@$_%])*$/;\n\nfunction asciiCaseInsensitiveMatch(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < a.length; ++i) {\n    if ((a.charCodeAt(i) | 32) !== (b.charCodeAt(i) | 32)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction recordNamespaceInformation(element, map, prefixMap) {\n  let defaultNamespaceAttrValue = null;\n\n  for (let i = 0; i < element.attributes.length; ++i) {\n    const attr = element.attributes[i];\n\n    if (attr.namespaceURI === NAMESPACES.XMLNS) {\n      if (attr.prefix === null) {\n        defaultNamespaceAttrValue = attr.value;\n        continue;\n      }\n\n      let namespaceDefinition = attr.value;\n\n      if (namespaceDefinition === NAMESPACES.XML) {\n        continue;\n      } // This is exactly the other way than the spec says, but that's intended.\n      // All the maps coalesce null to the empty string (explained in the\n      // spec), so instead of doing that every time, just do it once here.\n\n\n      if (namespaceDefinition === null) {\n        namespaceDefinition = \"\";\n      }\n\n      if (namespaceDefinition in map && map[namespaceDefinition].includes(attr.localName)) {\n        continue;\n      }\n\n      if (!(namespaceDefinition in map)) {\n        map[namespaceDefinition] = [];\n      }\n\n      map[namespaceDefinition].push(attr.localName);\n      prefixMap[attr.localName] = namespaceDefinition;\n    }\n  }\n\n  return defaultNamespaceAttrValue;\n}\n\nfunction serializeDocumentType(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && !PUBID_CHAR.test(node.publicId)) {\n    throw new Error(\"Failed to serialize XML: document type node publicId is not well-formed.\");\n  }\n\n  if (requireWellFormed && (!XML_CHAR.test(node.systemId) || node.systemId.includes('\"') && node.systemId.includes(\"'\"))) {\n    throw new Error(\"Failed to serialize XML: document type node systemId is not well-formed.\");\n  }\n\n  let markup = `<!DOCTYPE ${node.name}`;\n\n  if (node.publicId !== \"\") {\n    markup += ` PUBLIC \"${node.publicId}\"`;\n  } else if (node.systemId !== \"\") {\n    markup += \" SYSTEM\";\n  }\n\n  if (node.systemId !== \"\") {\n    markup += ` \"${node.systemId}\"`;\n  }\n\n  return markup + \">\";\n}\n\nfunction serializeProcessingInstruction(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && (node.target.includes(\":\") || asciiCaseInsensitiveMatch(node.target, \"xml\"))) {\n    throw new Error(\"Failed to serialize XML: processing instruction node target is not well-formed.\");\n  }\n\n  if (requireWellFormed && (!XML_CHAR.test(node.data) || node.data.includes(\"?>\"))) {\n    throw new Error(\"Failed to serialize XML: processing instruction node data is not well-formed.\");\n  }\n\n  return `<?${node.target} ${node.data}?>`;\n}\n\nfunction serializeDocument(node, namespace, prefixMap, requireWellFormed, refs) {\n  if (requireWellFormed && node.documentElement === null) {\n    throw new Error(\"Failed to serialize XML: document does not have a document element.\");\n  }\n\n  let serializedDocument = \"\";\n\n  for (const child of node.childNodes) {\n    serializedDocument += xmlSerialization(child, namespace, prefixMap, requireWellFormed, refs);\n  }\n\n  return serializedDocument;\n}\n\nfunction serializeDocumentFragment(node, namespace, prefixMap, requireWellFormed, refs) {\n  let markup = \"\";\n\n  for (const child of node.childNodes) {\n    markup += xmlSerialization(child, namespace, prefixMap, requireWellFormed, refs);\n  }\n\n  return markup;\n}\n\nfunction serializeText(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && !XML_CHAR.test(node.data)) {\n    throw new Error(\"Failed to serialize XML: text node data is not well-formed.\");\n  }\n\n  return node.data.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n}\n\nfunction serializeComment(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && !XML_CHAR.test(node.data)) {\n    throw new Error(\"Failed to serialize XML: comment node data is not well-formed.\");\n  }\n\n  if (requireWellFormed && (node.data.includes(\"--\") || node.data.endsWith(\"-\"))) {\n    throw new Error(\"Failed to serialize XML: found hyphens in illegal places in comment node data.\");\n  }\n\n  return `<!--${node.data}-->`;\n}\n\nfunction serializeElement(node, namespace, prefixMap, requireWellFormed, refs) {\n  if (requireWellFormed && (node.localName.includes(\":\") || !xnv.name(node.localName))) {\n    throw new Error(\"Failed to serialize XML: element node localName is not a valid XML name.\");\n  }\n\n  let markup = \"<\";\n  let qualifiedName = \"\";\n  let skipEndTag = false;\n  let ignoreNamespaceDefinitionAttr = false;\n  const map = Object.assign({}, prefixMap);\n  const localPrefixesMap = Object.create(null);\n  const localDefaultNamespace = recordNamespaceInformation(node, map, localPrefixesMap);\n  let inheritedNs = namespace;\n  const ns = node.namespaceURI;\n\n  if (inheritedNs === ns) {\n    if (localDefaultNamespace !== null) {\n      ignoreNamespaceDefinitionAttr = true;\n    }\n\n    if (ns === NAMESPACES.XML) {\n      qualifiedName = \"xml:\" + node.localName;\n    } else {\n      qualifiedName = node.localName;\n    }\n\n    markup += qualifiedName;\n  } else {\n    let {\n      prefix\n    } = node;\n    let candidatePrefix = attributeUtils.preferredPrefixString(map, ns, prefix);\n\n    if (prefix === \"xmlns\") {\n      if (requireWellFormed) {\n        throw new Error(\"Failed to serialize XML: element nodes can't have a prefix of \\\"xmlns\\\".\");\n      }\n\n      candidatePrefix = \"xmlns\";\n    }\n\n    if (candidatePrefix !== null) {\n      qualifiedName = candidatePrefix + \":\" + node.localName;\n\n      if (localDefaultNamespace !== null && localDefaultNamespace !== NAMESPACES.XML) {\n        inheritedNs = localDefaultNamespace === \"\" ? null : localDefaultNamespace;\n      }\n\n      markup += qualifiedName;\n    } else if (prefix !== null) {\n      if (prefix in localPrefixesMap) {\n        prefix = attributeUtils.generatePrefix(map, ns, refs.prefixIndex++);\n      }\n\n      if (map[ns]) {\n        map[ns].push(prefix);\n      } else {\n        map[ns] = [prefix];\n      }\n\n      qualifiedName = prefix + \":\" + node.localName;\n      markup += `${qualifiedName} xmlns:${prefix}=\"${attributeUtils.serializeAttributeValue(ns, requireWellFormed)}\"`;\n\n      if (localDefaultNamespace !== null) {\n        inheritedNs = localDefaultNamespace === \"\" ? null : localDefaultNamespace;\n      }\n    } else if (localDefaultNamespace === null || localDefaultNamespace !== ns) {\n      ignoreNamespaceDefinitionAttr = true;\n      qualifiedName = node.localName;\n      inheritedNs = ns;\n      markup += `${qualifiedName} xmlns=\"${attributeUtils.serializeAttributeValue(ns, requireWellFormed)}\"`;\n    } else {\n      qualifiedName = node.localName;\n      inheritedNs = ns;\n      markup += qualifiedName;\n    }\n  }\n\n  markup += attributeUtils.serializeAttributes(node, map, localPrefixesMap, ignoreNamespaceDefinitionAttr, requireWellFormed, refs);\n\n  if (ns === NAMESPACES.HTML && node.childNodes.length === 0 && VOID_ELEMENTS.has(node.localName)) {\n    markup += \" /\";\n    skipEndTag = true;\n  } else if (ns !== NAMESPACES.HTML && node.childNodes.length === 0) {\n    markup += \"/\";\n    skipEndTag = true;\n  }\n\n  markup += \">\";\n\n  if (skipEndTag) {\n    return markup;\n  }\n\n  if (ns === NAMESPACES.HTML && node.localName === \"template\") {\n    markup += xmlSerialization(node.content, inheritedNs, map, requireWellFormed, refs);\n  } else {\n    for (const child of node.childNodes) {\n      markup += xmlSerialization(child, inheritedNs, map, requireWellFormed, refs);\n    }\n  }\n\n  markup += `</${qualifiedName}>`;\n  return markup;\n}\n\nfunction serializeCDATASection(node) {\n  return \"<![CDATA[\" + node.data + \"]]>\";\n}\n/**\n * @param {{prefixIndex: number}} refs\n */\n\n\nfunction xmlSerialization(node, namespace, prefixMap, requireWellFormed, refs) {\n  switch (node.nodeType) {\n    case NODE_TYPES.ELEMENT_NODE:\n      return serializeElement(node, namespace, prefixMap, requireWellFormed, refs);\n\n    case NODE_TYPES.DOCUMENT_NODE:\n      return serializeDocument(node, namespace, prefixMap, requireWellFormed, refs);\n\n    case NODE_TYPES.COMMENT_NODE:\n      return serializeComment(node, namespace, prefixMap, requireWellFormed);\n\n    case NODE_TYPES.TEXT_NODE:\n      return serializeText(node, namespace, prefixMap, requireWellFormed);\n\n    case NODE_TYPES.DOCUMENT_FRAGMENT_NODE:\n      return serializeDocumentFragment(node, namespace, prefixMap, requireWellFormed, refs);\n\n    case NODE_TYPES.DOCUMENT_TYPE_NODE:\n      return serializeDocumentType(node, namespace, prefixMap, requireWellFormed);\n\n    case NODE_TYPES.PROCESSING_INSTRUCTION_NODE:\n      return serializeProcessingInstruction(node, namespace, prefixMap, requireWellFormed);\n\n    case NODE_TYPES.ATTRIBUTE_NODE:\n      return \"\";\n\n    case NODE_TYPES.CDATA_SECTION_NODE:\n      return serializeCDATASection(node);\n\n    default:\n      throw new TypeError(\"Failed to serialize XML: only Nodes can be serialized.\");\n  }\n}\n\nmodule.exports = function (root) {\n  let {\n    requireWellFormed = false\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const namespacePrefixMap = Object.create(null);\n  namespacePrefixMap[\"http://www.w3.org/XML/1998/namespace\"] = [\"xml\"];\n  return xmlSerialization(root, null, namespacePrefixMap, requireWellFormed, {\n    prefixIndex: 1\n  });\n};","map":{"version":3,"names":["xnv","require","attributeUtils","NAMESPACES","VOID_ELEMENTS","NODE_TYPES","XML_CHAR","PUBID_CHAR","asciiCaseInsensitiveMatch","a","b","length","i","charCodeAt","recordNamespaceInformation","element","map","prefixMap","defaultNamespaceAttrValue","attributes","attr","namespaceURI","XMLNS","prefix","value","namespaceDefinition","XML","includes","localName","push","serializeDocumentType","node","namespace","requireWellFormed","test","publicId","Error","systemId","markup","name","serializeProcessingInstruction","target","data","serializeDocument","refs","documentElement","serializedDocument","child","childNodes","xmlSerialization","serializeDocumentFragment","serializeText","replace","serializeComment","endsWith","serializeElement","qualifiedName","skipEndTag","ignoreNamespaceDefinitionAttr","Object","assign","localPrefixesMap","create","localDefaultNamespace","inheritedNs","ns","candidatePrefix","preferredPrefixString","generatePrefix","prefixIndex","serializeAttributeValue","serializeAttributes","HTML","has","content","serializeCDATASection","nodeType","ELEMENT_NODE","DOCUMENT_NODE","COMMENT_NODE","TEXT_NODE","DOCUMENT_FRAGMENT_NODE","DOCUMENT_TYPE_NODE","PROCESSING_INSTRUCTION_NODE","ATTRIBUTE_NODE","CDATA_SECTION_NODE","TypeError","module","exports","root","namespacePrefixMap"],"sources":["C:/Users/17033/balmco/node_modules/w3c-xmlserializer/lib/serialize.js"],"sourcesContent":["\"use strict\";\n\nconst xnv = require(\"xml-name-validator\");\n\nconst attributeUtils = require(\"./attributes\");\nconst { NAMESPACES, VOID_ELEMENTS, NODE_TYPES } = require(\"./constants\");\n\nconst XML_CHAR = /^(\\x09|\\x0A|\\x0D|[\\x20-\\uD7FF]|[\\uE000-\\uFFFD]|(?:[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]))*$/;\nconst PUBID_CHAR = /^(\\x20|\\x0D|\\x0A|[a-zA-Z0-9]|[-'()+,./:=?;!*#@$_%])*$/;\n\nfunction asciiCaseInsensitiveMatch(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < a.length; ++i) {\n    if ((a.charCodeAt(i) | 32) !== (b.charCodeAt(i) | 32)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction recordNamespaceInformation(element, map, prefixMap) {\n  let defaultNamespaceAttrValue = null;\n  for (let i = 0; i < element.attributes.length; ++i) {\n    const attr = element.attributes[i];\n    if (attr.namespaceURI === NAMESPACES.XMLNS) {\n      if (attr.prefix === null) {\n        defaultNamespaceAttrValue = attr.value;\n        continue;\n      }\n      let namespaceDefinition = attr.value;\n      if (namespaceDefinition === NAMESPACES.XML) {\n        continue;\n      }\n      // This is exactly the other way than the spec says, but that's intended.\n      // All the maps coalesce null to the empty string (explained in the\n      // spec), so instead of doing that every time, just do it once here.\n      if (namespaceDefinition === null) {\n        namespaceDefinition = \"\";\n      }\n\n      if (\n        namespaceDefinition in map &&\n        map[namespaceDefinition].includes(attr.localName)\n      ) {\n        continue;\n      }\n      if (!(namespaceDefinition in map)) {\n        map[namespaceDefinition] = [];\n      }\n      map[namespaceDefinition].push(attr.localName);\n      prefixMap[attr.localName] = namespaceDefinition;\n    }\n  }\n  return defaultNamespaceAttrValue;\n}\n\nfunction serializeDocumentType(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && !PUBID_CHAR.test(node.publicId)) {\n    throw new Error(\"Failed to serialize XML: document type node publicId is not well-formed.\");\n  }\n\n  if (\n    requireWellFormed &&\n    (!XML_CHAR.test(node.systemId) ||\n      (node.systemId.includes('\"') && node.systemId.includes(\"'\")))\n  ) {\n    throw new Error(\"Failed to serialize XML: document type node systemId is not well-formed.\");\n  }\n\n  let markup = `<!DOCTYPE ${node.name}`;\n  if (node.publicId !== \"\") {\n    markup += ` PUBLIC \"${node.publicId}\"`;\n  } else if (node.systemId !== \"\") {\n    markup += \" SYSTEM\";\n  }\n  if (node.systemId !== \"\") {\n    markup += ` \"${node.systemId}\"`;\n  }\n  return markup + \">\";\n}\n\nfunction serializeProcessingInstruction(\n  node,\n  namespace,\n  prefixMap,\n  requireWellFormed\n) {\n  if (\n    requireWellFormed &&\n    (node.target.includes(\":\") || asciiCaseInsensitiveMatch(node.target, \"xml\"))\n  ) {\n    throw new Error(\"Failed to serialize XML: processing instruction node target is not well-formed.\");\n  }\n  if (\n    requireWellFormed &&\n    (!XML_CHAR.test(node.data) || node.data.includes(\"?>\"))\n  ) {\n    throw new Error(\"Failed to serialize XML: processing instruction node data is not well-formed.\");\n  }\n  return `<?${node.target} ${node.data}?>`;\n}\n\nfunction serializeDocument(\n  node,\n  namespace,\n  prefixMap,\n  requireWellFormed,\n  refs\n) {\n  if (requireWellFormed && node.documentElement === null) {\n    throw new Error(\"Failed to serialize XML: document does not have a document element.\");\n  }\n  let serializedDocument = \"\";\n  for (const child of node.childNodes) {\n    serializedDocument += xmlSerialization(\n      child,\n      namespace,\n      prefixMap,\n      requireWellFormed,\n      refs\n    );\n  }\n  return serializedDocument;\n}\n\nfunction serializeDocumentFragment(\n  node,\n  namespace,\n  prefixMap,\n  requireWellFormed,\n  refs\n) {\n  let markup = \"\";\n  for (const child of node.childNodes) {\n    markup += xmlSerialization(\n      child,\n      namespace,\n      prefixMap,\n      requireWellFormed,\n      refs\n    );\n  }\n  return markup;\n}\n\nfunction serializeText(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && !XML_CHAR.test(node.data)) {\n    throw new Error(\"Failed to serialize XML: text node data is not well-formed.\");\n  }\n\n  return node.data\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\");\n}\n\nfunction serializeComment(node, namespace, prefixMap, requireWellFormed) {\n  if (requireWellFormed && !XML_CHAR.test(node.data)) {\n    throw new Error(\"Failed to serialize XML: comment node data is not well-formed.\");\n  }\n\n  if (\n    requireWellFormed &&\n    (node.data.includes(\"--\") || node.data.endsWith(\"-\"))\n  ) {\n    throw new Error(\"Failed to serialize XML: found hyphens in illegal places in comment node data.\");\n  }\n  return `<!--${node.data}-->`;\n}\n\nfunction serializeElement(node, namespace, prefixMap, requireWellFormed, refs) {\n  if (\n    requireWellFormed &&\n    (node.localName.includes(\":\") || !xnv.name(node.localName))\n  ) {\n    throw new Error(\"Failed to serialize XML: element node localName is not a valid XML name.\");\n  }\n  let markup = \"<\";\n  let qualifiedName = \"\";\n  let skipEndTag = false;\n  let ignoreNamespaceDefinitionAttr = false;\n  const map = Object.assign({}, prefixMap);\n  const localPrefixesMap = Object.create(null);\n  const localDefaultNamespace = recordNamespaceInformation(\n    node,\n    map,\n    localPrefixesMap\n  );\n  let inheritedNs = namespace;\n  const ns = node.namespaceURI;\n  if (inheritedNs === ns) {\n    if (localDefaultNamespace !== null) {\n      ignoreNamespaceDefinitionAttr = true;\n    }\n    if (ns === NAMESPACES.XML) {\n      qualifiedName = \"xml:\" + node.localName;\n    } else {\n      qualifiedName = node.localName;\n    }\n    markup += qualifiedName;\n  } else {\n    let { prefix } = node;\n    let candidatePrefix = attributeUtils.preferredPrefixString(map, ns, prefix);\n    if (prefix === \"xmlns\") {\n      if (requireWellFormed) {\n        throw new Error(\"Failed to serialize XML: element nodes can't have a prefix of \\\"xmlns\\\".\");\n      }\n      candidatePrefix = \"xmlns\";\n    }\n    if (candidatePrefix !== null) {\n      qualifiedName = candidatePrefix + \":\" + node.localName;\n      if (\n        localDefaultNamespace !== null &&\n        localDefaultNamespace !== NAMESPACES.XML\n      ) {\n        inheritedNs =\n          localDefaultNamespace === \"\" ? null : localDefaultNamespace;\n      }\n      markup += qualifiedName;\n    } else if (prefix !== null) {\n      if (prefix in localPrefixesMap) {\n        prefix = attributeUtils.generatePrefix(map, ns, refs.prefixIndex++);\n      }\n      if (map[ns]) {\n        map[ns].push(prefix);\n      } else {\n        map[ns] = [prefix];\n      }\n      qualifiedName = prefix + \":\" + node.localName;\n      markup += `${qualifiedName} xmlns:${prefix}=\"${attributeUtils.serializeAttributeValue(\n        ns,\n        requireWellFormed\n      )}\"`;\n      if (localDefaultNamespace !== null) {\n        inheritedNs =\n          localDefaultNamespace === \"\" ? null : localDefaultNamespace;\n      }\n    } else if (localDefaultNamespace === null || localDefaultNamespace !== ns) {\n      ignoreNamespaceDefinitionAttr = true;\n      qualifiedName = node.localName;\n      inheritedNs = ns;\n      markup += `${qualifiedName} xmlns=\"${attributeUtils.serializeAttributeValue(\n        ns,\n        requireWellFormed\n      )}\"`;\n    } else {\n      qualifiedName = node.localName;\n      inheritedNs = ns;\n      markup += qualifiedName;\n    }\n  }\n\n  markup += attributeUtils.serializeAttributes(\n    node,\n    map,\n    localPrefixesMap,\n    ignoreNamespaceDefinitionAttr,\n    requireWellFormed,\n    refs\n  );\n\n  if (\n    ns === NAMESPACES.HTML &&\n    node.childNodes.length === 0 &&\n    VOID_ELEMENTS.has(node.localName)\n  ) {\n    markup += \" /\";\n    skipEndTag = true;\n  } else if (ns !== NAMESPACES.HTML && node.childNodes.length === 0) {\n    markup += \"/\";\n    skipEndTag = true;\n  }\n  markup += \">\";\n  if (skipEndTag) {\n    return markup;\n  }\n\n  if (ns === NAMESPACES.HTML && node.localName === \"template\") {\n    markup += xmlSerialization(\n      node.content,\n      inheritedNs,\n      map,\n      requireWellFormed,\n      refs\n    );\n  } else {\n    for (const child of node.childNodes) {\n      markup += xmlSerialization(\n        child,\n        inheritedNs,\n        map,\n        requireWellFormed,\n        refs\n      );\n    }\n  }\n  markup += `</${qualifiedName}>`;\n  return markup;\n}\n\nfunction serializeCDATASection(node) {\n  return \"<![CDATA[\" + node.data + \"]]>\";\n}\n\n/**\n * @param {{prefixIndex: number}} refs\n */\nfunction xmlSerialization(node, namespace, prefixMap, requireWellFormed, refs) {\n  switch (node.nodeType) {\n    case NODE_TYPES.ELEMENT_NODE:\n      return serializeElement(\n        node,\n        namespace,\n        prefixMap,\n        requireWellFormed,\n        refs\n      );\n    case NODE_TYPES.DOCUMENT_NODE:\n      return serializeDocument(\n        node,\n        namespace,\n        prefixMap,\n        requireWellFormed,\n        refs\n      );\n    case NODE_TYPES.COMMENT_NODE:\n      return serializeComment(node, namespace, prefixMap, requireWellFormed);\n    case NODE_TYPES.TEXT_NODE:\n      return serializeText(node, namespace, prefixMap, requireWellFormed);\n    case NODE_TYPES.DOCUMENT_FRAGMENT_NODE:\n      return serializeDocumentFragment(\n        node,\n        namespace,\n        prefixMap,\n        requireWellFormed,\n        refs\n      );\n    case NODE_TYPES.DOCUMENT_TYPE_NODE:\n      return serializeDocumentType(\n        node,\n        namespace,\n        prefixMap,\n        requireWellFormed\n      );\n    case NODE_TYPES.PROCESSING_INSTRUCTION_NODE:\n      return serializeProcessingInstruction(\n        node,\n        namespace,\n        prefixMap,\n        requireWellFormed\n      );\n    case NODE_TYPES.ATTRIBUTE_NODE:\n      return \"\";\n    case NODE_TYPES.CDATA_SECTION_NODE:\n      return serializeCDATASection(node);\n    default:\n      throw new TypeError(\"Failed to serialize XML: only Nodes can be serialized.\");\n  }\n}\n\nmodule.exports = (root, { requireWellFormed = false } = {}) => {\n  const namespacePrefixMap = Object.create(null);\n  namespacePrefixMap[\"http://www.w3.org/XML/1998/namespace\"] = [\"xml\"];\n  return xmlSerialization(root, null, namespacePrefixMap, requireWellFormed, {\n    prefixIndex: 1\n  });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}