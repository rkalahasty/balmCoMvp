{"ast":null,"code":"/** Here is yet another implementation of XPath 1.0 in Javascript.\n *\n * My goal was to make it relatively compact, but as I fixed all the axis bugs\n * the axes became more and more complicated. :-(.\n *\n * I have not implemented namespaces or case-sensitive axes for XML yet.\n *\n * How to test it in Chrome: You can make a Chrome extension that replaces\n * the WebKit XPath parser with this one. But it takes a bit of effort to\n * get around isolated world and same-origin restrictions:\n * manifest.json:\n    {\n      \"name\": \"XPathTest\",\n      \"version\": \"0.1\",\n      \"content_scripts\": [{\n        \"matches\": [\"http://localhost/*\"],  // or wildcard host\n        \"js\": [\"xpath.js\", \"injection.js\"],\n        \"all_frames\": true, \"run_at\": \"document_start\"\n      }]\n    }\n * injection.js:\n    // goal: give my xpath object to the website's JS context.\n    var script = document.createElement('script');\n    script.textContent =\n        \"document.addEventListener('xpathextend', function(e) {\\n\" +\n        \"  console.log('extending document with xpath...');\\n\" +\n        \"  e.detail(window);\" +\n        \"});\";\n    document.documentElement.appendChild(script);\n    document.documentElement.removeChild(script);\n    var evt = document.createEvent('CustomEvent');\n    evt.initCustomEvent('xpathextend', true, true, this.xpath.extend);\n    document.dispatchEvent(evt);\n */\nmodule.exports = core => {\n  var xpath = {}; // Helper function to deal with the migration of Attr to no longer have a nodeName property despite this codebase\n  // assuming it does.\n\n  function getNodeName(nodeOrAttr) {\n    return nodeOrAttr.constructor.name === 'Attr' ? nodeOrAttr.name : nodeOrAttr.nodeName;\n  }\n  /***************************************************************************\n   *                            Tokenization                                 *\n   ***************************************************************************/\n\n  /**\n   * The XPath lexer is basically a single regular expression, along with\n   * some helper functions to pop different types.\n   */\n\n\n  var Stream = xpath.Stream = function Stream(str) {\n    this.original = this.str = str;\n    this.peeked = null; // TODO: not really needed, but supposedly tokenizer also disambiguates\n    // a * b vs. node test *\n\n    this.prev = null; // for debugging\n\n    this.prevprev = null;\n  };\n\n  Stream.prototype = {\n    peek: function () {\n      if (this.peeked) return this.peeked;\n      var m = this.re.exec(this.str);\n      if (!m) return null;\n      this.str = this.str.substr(m[0].length);\n      return this.peeked = m[1];\n    },\n\n    /** Peek 2 tokens ahead. */\n    peek2: function () {\n      this.peek(); // make sure this.peeked is set\n\n      var m = this.re.exec(this.str);\n      if (!m) return null;\n      return m[1];\n    },\n    pop: function () {\n      var r = this.peek();\n      this.peeked = null;\n      this.prevprev = this.prev;\n      this.prev = r;\n      return r;\n    },\n    trypop: function (tokens) {\n      var tok = this.peek();\n      if (tok === tokens) return this.pop();\n\n      if (Array.isArray(tokens)) {\n        for (var i = 0; i < tokens.length; ++i) {\n          var t = tokens[i];\n          if (t == tok) return this.pop();\n          ;\n        }\n      }\n    },\n    trypopfuncname: function () {\n      var tok = this.peek();\n      if (!this.isQnameRe.test(tok)) return null;\n\n      switch (tok) {\n        case 'comment':\n        case 'text':\n        case 'processing-instruction':\n        case 'node':\n          return null;\n      }\n\n      if ('(' != this.peek2()) return null;\n      return this.pop();\n    },\n    trypopaxisname: function () {\n      var tok = this.peek();\n\n      switch (tok) {\n        case 'ancestor':\n        case 'ancestor-or-self':\n        case 'attribute':\n        case 'child':\n        case 'descendant':\n        case 'descendant-or-self':\n        case 'following':\n        case 'following-sibling':\n        case 'namespace':\n        case 'parent':\n        case 'preceding':\n        case 'preceding-sibling':\n        case 'self':\n          if ('::' == this.peek2()) return this.pop();\n      }\n\n      return null;\n    },\n    trypopnametest: function () {\n      var tok = this.peek();\n      if ('*' === tok || this.startsWithNcNameRe.test(tok)) return this.pop();\n      return null;\n    },\n    trypopliteral: function () {\n      var tok = this.peek();\n      if (null == tok) return null;\n      var first = tok.charAt(0);\n      var last = tok.charAt(tok.length - 1);\n\n      if ('\"' === first && '\"' === last || \"'\" === first && \"'\" === last) {\n        this.pop();\n        return tok.substr(1, tok.length - 2);\n      }\n    },\n    trypopnumber: function () {\n      var tok = this.peek();\n      if (this.isNumberRe.test(tok)) return parseFloat(this.pop());else return null;\n    },\n    trypopvarref: function () {\n      var tok = this.peek();\n      if (null == tok) return null;\n      if ('$' === tok.charAt(0)) return this.pop().substr(1);else return null;\n    },\n    position: function () {\n      return this.original.length - this.str.length;\n    }\n  };\n\n  (function () {\n    // http://www.w3.org/TR/REC-xml-names/#NT-NCName\n    var nameStartCharsExceptColon = 'A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xF8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF' + '\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF' + '\\uFDF0-\\uFFFD'; // JS doesn't support [#x10000-#xEFFFF]\n\n    var nameCharExceptColon = nameStartCharsExceptColon + '\\\\-\\\\.0-9\\xb7\\u0300-\\u036F\\u203F-\\u2040';\n    var ncNameChars = '[' + nameStartCharsExceptColon + '][' + nameCharExceptColon + ']*'; // http://www.w3.org/TR/REC-xml-names/#NT-QName\n\n    var qNameChars = ncNameChars + '(?::' + ncNameChars + ')?';\n    var otherChars = '\\\\.\\\\.|[\\\\(\\\\)\\\\[\\\\].@,]|::'; // .. must come before [.]\n\n    var operatorChars = 'and|or|mod|div|' + '//|!=|<=|>=|[*/|+\\\\-=<>]'; // //, !=, <=, >= before individual ones.\n\n    var literal = '\"[^\"]*\"|' + \"'[^']*'\";\n    var numberChars = '[0-9]+(?:\\\\.[0-9]*)?|\\\\.[0-9]+';\n    var variableReference = '\\\\$' + qNameChars;\n    var nameTestChars = '\\\\*|' + ncNameChars + ':\\\\*|' + qNameChars;\n    var optionalSpace = '[ \\t\\r\\n]*'; // stricter than regexp \\s.\n\n    var nodeType = 'comment|text|processing-instruction|node';\n    var re = new RegExp( // numberChars before otherChars so that leading-decimal doesn't become .\n    '^' + optionalSpace + '(' + numberChars + '|' + otherChars + '|' + nameTestChars + '|' + operatorChars + '|' + literal + '|' + variableReference + ')' // operatorName | nodeType | functionName | axisName are lumped into\n    // qName for now; we'll check them on pop.\n    );\n    Stream.prototype.re = re;\n    Stream.prototype.startsWithNcNameRe = new RegExp('^' + ncNameChars);\n    Stream.prototype.isQnameRe = new RegExp('^' + qNameChars + '$');\n    Stream.prototype.isNumberRe = new RegExp('^' + numberChars + '$');\n  })();\n  /***************************************************************************\n   *                               Parsing                                   *\n   ***************************************************************************/\n\n\n  var parse = xpath.parse = function parse(stream, a) {\n    var r = orExpr(stream, a);\n    var x,\n        unparsed = [];\n\n    while (x = stream.pop()) {\n      unparsed.push(x);\n    }\n\n    if (unparsed.length) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Unparsed tokens: ' + unparsed.join(' '));\n    return r;\n  };\n  /**\n   * binaryL  ::= subExpr\n   *            | binaryL op subExpr\n   * so a op b op c becomes ((a op b) op c)\n   */\n\n\n  function binaryL(subExpr, stream, a, ops) {\n    var lhs = subExpr(stream, a);\n    if (lhs == null) return null;\n    var op;\n\n    while (op = stream.trypop(ops)) {\n      var rhs = subExpr(stream, a);\n      if (rhs == null) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected something after ' + op);\n      lhs = a.node(op, lhs, rhs);\n    }\n\n    return lhs;\n  }\n  /**\n   * Too bad this is never used. If they made a ** operator (raise to power),\n   ( we would use it.\n   * binaryR  ::= subExpr\n   *            | subExpr op binaryR\n   * so a op b op c becomes (a op (b op c))\n   */\n\n\n  function binaryR(subExpr, stream, a, ops) {\n    var lhs = subExpr(stream, a);\n    if (lhs == null) return null;\n    var op = stream.trypop(ops);\n\n    if (op) {\n      var rhs = binaryR(stream, a);\n      if (rhs == null) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected something after ' + op);\n      return a.node(op, lhs, rhs);\n    } else {\n      return lhs; // TODO\n    }\n  }\n  /** [1] LocationPath::= RelativeLocationPath | AbsoluteLocationPath\n   * e.g. a, a/b, //a/b\n   */\n\n\n  function locationPath(stream, a) {\n    return absoluteLocationPath(stream, a) || relativeLocationPath(null, stream, a);\n  }\n  /** [2] AbsoluteLocationPath::= '/' RelativeLocationPath? | AbbreviatedAbsoluteLocationPath\n   *  [10] AbbreviatedAbsoluteLocationPath::= '//' RelativeLocationPath\n   */\n\n\n  function absoluteLocationPath(stream, a) {\n    var op = stream.peek();\n\n    if ('/' === op || '//' === op) {\n      var lhs = a.node('Root');\n      return relativeLocationPath(lhs, stream, a, true);\n    } else {\n      return null;\n    }\n  }\n  /** [3] RelativeLocationPath::= Step | RelativeLocationPath '/' Step |\n   *                            | AbbreviatedRelativeLocationPath\n   *  [11] AbbreviatedRelativeLocationPath::= RelativeLocationPath '//' Step\n   * e.g. p/a, etc.\n   */\n\n\n  function relativeLocationPath(lhs, stream, a, isOnlyRootOk) {\n    if (null == lhs) {\n      lhs = step(stream, a);\n      if (null == lhs) return lhs;\n    }\n\n    var op;\n\n    while (op = stream.trypop(['/', '//'])) {\n      if ('//' === op) {\n        lhs = a.node('/', lhs, a.node('Axis', 'descendant-or-self', 'node', undefined));\n      }\n\n      var rhs = step(stream, a);\n      if (null == rhs && '/' === op && isOnlyRootOk) return lhs;else isOnlyRootOk = false;\n      if (null == rhs) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected step after ' + op);\n      lhs = a.node('/', lhs, rhs);\n    }\n\n    return lhs;\n  }\n  /** [4] Step::= AxisSpecifier NodeTest Predicate* | AbbreviatedStep\n   *  [12] AbbreviatedStep::= '.' | '..'\n   * e.g. @href, self::p, p, a[@href], ., ..\n   */\n\n\n  function step(stream, a) {\n    var abbrStep = stream.trypop(['.', '..']);\n    if ('.' === abbrStep) // A location step of . is short for self::node().\n      return a.node('Axis', 'self', 'node');\n    if ('..' === abbrStep) // A location step of .. is short for parent::node()\n      return a.node('Axis', 'parent', 'node');\n    var axis = axisSpecifier(stream, a);\n    var nodeType = nodeTypeTest(stream, a);\n    var nodeName;\n    if (null == nodeType) nodeName = nodeNameTest(stream, a);\n    if (null == axis && null == nodeType && null == nodeName) return null;\n    if (null == nodeType && null == nodeName) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected nodeTest after axisSpecifier ' + axis);\n    if (null == axis) axis = 'child';\n\n    if (null == nodeType) {\n      // When there's only a node name, then the node type is forced to be the\n      // principal node type of the axis.\n      // see http://www.w3.org/TR/xpath/#dt-principal-node-type\n      if ('attribute' === axis) nodeType = 'attribute';else if ('namespace' === axis) nodeType = 'namespace';else nodeType = 'element';\n    }\n\n    var lhs = a.node('Axis', axis, nodeType, nodeName);\n    var pred;\n\n    while (null != (pred = predicate(lhs, stream, a))) {\n      lhs = pred;\n    }\n\n    return lhs;\n  }\n  /** [5] AxisSpecifier::= AxisName '::' | AbbreviatedAxisSpecifier\n   *  [6] AxisName::= 'ancestor' | 'ancestor-or-self' | 'attribute' | 'child'\n   *                | 'descendant' | 'descendant-or-self' | 'following'\n   *                | 'following-sibling' | 'namespace' | 'parent' |\n   *                | 'preceding' | 'preceding-sibling' | 'self'\n   *  [13] AbbreviatedAxisSpecifier::= '@'?\n   */\n\n\n  function axisSpecifier(stream, a) {\n    var attr = stream.trypop('@');\n    if (null != attr) return 'attribute';\n    var axisName = stream.trypopaxisname();\n\n    if (null != axisName) {\n      var coloncolon = stream.trypop('::');\n      if (null == coloncolon) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Should not happen. Should be ::.');\n      return axisName;\n    }\n  }\n  /** [7] NodeTest::= NameTest | NodeType '(' ')' | 'processing-instruction' '(' Literal ')'\n   *  [38] NodeType::= 'comment' | 'text' | 'processing-instruction' | 'node'\n   * I've split nodeTypeTest from nodeNameTest for convenience.\n   */\n\n\n  function nodeTypeTest(stream, a) {\n    if ('(' !== stream.peek2()) {\n      return null;\n    }\n\n    var type = stream.trypop(['comment', 'text', 'processing-instruction', 'node']);\n\n    if (null != type) {\n      if (null == stream.trypop('(')) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Should not happen.');\n      var param = undefined;\n\n      if (type == 'processing-instruction') {\n        param = stream.trypopliteral();\n      }\n\n      if (null == stream.trypop(')')) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected close parens.');\n      return type;\n    }\n  }\n\n  function nodeNameTest(stream, a) {\n    var name = stream.trypopnametest();\n    if (name != null) return name;else return null;\n  }\n  /** [8] Predicate::= '[' PredicateExpr ']'\n   *  [9] PredicateExpr::= Expr\n   */\n\n\n  function predicate(lhs, stream, a) {\n    if (null == stream.trypop('[')) return null;\n    var expr = orExpr(stream, a);\n    if (null == expr) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected expression after [');\n    if (null == stream.trypop(']')) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected ] after expression.');\n    return a.node('Predicate', lhs, expr);\n  }\n  /** [14] Expr::= OrExpr\n   */\n\n  /** [15] PrimaryExpr::= VariableReference | '(' Expr ')' | Literal | Number | FunctionCall\n   * e.g. $x,  (3+4),  \"hi\",  32,  f(x)\n   */\n\n\n  function primaryExpr(stream, a) {\n    var x = stream.trypopliteral();\n    if (null == x) x = stream.trypopnumber();\n\n    if (null != x) {\n      return x;\n    }\n\n    var varRef = stream.trypopvarref();\n    if (null != varRef) return a.node('VariableReference', varRef);\n    var funCall = functionCall(stream, a);\n\n    if (null != funCall) {\n      return funCall;\n    }\n\n    if (stream.trypop('(')) {\n      var e = orExpr(stream, a);\n      if (null == e) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected expression after (.');\n      if (null == stream.trypop(')')) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected ) after expression.');\n      return e;\n    }\n\n    return null;\n  }\n  /** [16] FunctionCall::= FunctionName '(' ( Argument ( ',' Argument )* )? ')'\n   *  [17] Argument::= Expr\n   */\n\n\n  function functionCall(stream, a) {\n    var name = stream.trypopfuncname(stream, a);\n    if (null == name) return null;\n    if (null == stream.trypop('(')) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected ( ) after function name.');\n    var params = [];\n    var first = true;\n\n    while (null == stream.trypop(')')) {\n      if (!first && null == stream.trypop(',')) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected , between arguments of the function.');\n      first = false;\n      var param = orExpr(stream, a);\n      if (param == null) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected expression as argument of function.');\n      params.push(param);\n    }\n\n    return a.node('FunctionCall', name, params);\n  }\n  /** [18] UnionExpr::= PathExpr | UnionExpr '|' PathExpr\n   */\n\n\n  function unionExpr(stream, a) {\n    return binaryL(pathExpr, stream, a, '|');\n  }\n  /** [19] PathExpr ::= LocationPath\n   *                  | FilterExpr\n   *                  | FilterExpr '/' RelativeLocationPath\n   *                  | FilterExpr '//' RelativeLocationPath\n   * Unlike most other nodes, this one always generates a node because\n   * at this point all reverse nodesets must turn into a forward nodeset\n   */\n\n\n  function pathExpr(stream, a) {\n    // We have to do FilterExpr before LocationPath because otherwise\n    // LocationPath will eat up the name from a function call.\n    var filter = filterExpr(stream, a);\n\n    if (null == filter) {\n      var loc = locationPath(stream, a);\n\n      if (null == loc) {\n        throw new Error();\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': The expression shouldn\\'t be empty...');\n      }\n\n      return a.node('PathExpr', loc);\n    }\n\n    var rel = relativeLocationPath(filter, stream, a, false);\n    if (filter === rel) return rel;else return a.node('PathExpr', rel);\n  }\n  /** [20] FilterExpr::= PrimaryExpr | FilterExpr Predicate\n   * aka. FilterExpr ::= PrimaryExpr Predicate*\n   */\n\n\n  function filterExpr(stream, a) {\n    var primary = primaryExpr(stream, a);\n    if (primary == null) return null;\n    var pred,\n        lhs = primary;\n\n    while (null != (pred = predicate(lhs, stream, a))) {\n      lhs = pred;\n    }\n\n    return lhs;\n  }\n  /** [21] OrExpr::= AndExpr | OrExpr 'or' AndExpr\n   */\n\n\n  function orExpr(stream, a) {\n    var orig = (stream.peeked || '') + stream.str;\n    var r = binaryL(andExpr, stream, a, 'or');\n    var now = (stream.peeked || '') + stream.str;\n    return r;\n  }\n  /** [22] AndExpr::= EqualityExpr | AndExpr 'and' EqualityExpr\n   */\n\n\n  function andExpr(stream, a) {\n    return binaryL(equalityExpr, stream, a, 'and');\n  }\n  /** [23] EqualityExpr::= RelationalExpr | EqualityExpr '=' RelationalExpr\n   *                     | EqualityExpr '!=' RelationalExpr\n   */\n\n\n  function equalityExpr(stream, a) {\n    return binaryL(relationalExpr, stream, a, ['=', '!=']);\n  }\n  /** [24] RelationalExpr::= AdditiveExpr | RelationalExpr '<' AdditiveExpr\n   *                       | RelationalExpr '>' AdditiveExpr\n   *                       | RelationalExpr '<=' AdditiveExpr\n   *                       | RelationalExpr '>=' AdditiveExpr\n   */\n\n\n  function relationalExpr(stream, a) {\n    return binaryL(additiveExpr, stream, a, ['<', '>', '<=', '>=']);\n  }\n  /** [25] AdditiveExpr::= MultiplicativeExpr\n   *                     | AdditiveExpr '+' MultiplicativeExpr\n   *                     | AdditiveExpr '-' MultiplicativeExpr\n   */\n\n\n  function additiveExpr(stream, a) {\n    return binaryL(multiplicativeExpr, stream, a, ['+', '-']);\n  }\n  /** [26] MultiplicativeExpr::= UnaryExpr\n   *                           | MultiplicativeExpr MultiplyOperator UnaryExpr\n   *                           | MultiplicativeExpr 'div' UnaryExpr\n   *                           | MultiplicativeExpr 'mod' UnaryExpr\n   */\n\n\n  function multiplicativeExpr(stream, a) {\n    return binaryL(unaryExpr, stream, a, ['*', 'div', 'mod']);\n  }\n  /** [27] UnaryExpr::= UnionExpr | '-' UnaryExpr\n   */\n\n\n  function unaryExpr(stream, a) {\n    if (stream.trypop('-')) {\n      var e = unaryExpr(stream, a);\n      if (null == e) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Expected unary expression after -');\n      return a.node('UnaryMinus', e);\n    } else return unionExpr(stream, a);\n  }\n\n  var astFactory = {\n    node: function () {\n      return Array.prototype.slice.call(arguments);\n    }\n  };\n  /***************************************************************************\n   *                            Optimizations (TODO)                         *\n   ***************************************************************************/\n\n  /**\n   * Some things I've been considering:\n   * 1) a//b becomes a/descendant::b if there's no predicate that uses\n   *    position() or last()\n   * 2) axis[pred]: when pred doesn't use position, evaluate it just once per\n   *    node in the node-set rather than once per (node, position, last).\n   * For more optimizations, look up Gecko's optimizer:\n   * http://mxr.mozilla.org/mozilla-central/source/content/xslt/src/xpath/txXPathOptimizer.cpp\n   */\n  // TODO\n\n  function optimize(ast) {}\n  /***************************************************************************\n   *                           Evaluation: axes                              *\n   ***************************************************************************/\n\n  /**\n   * Data types: For string, number, boolean, we just use Javascript types.\n   * Node-sets have the form\n   *    {nodes: [node, ...]}\n   * or {nodes: [node, ...], pos: [[1], [2], ...], lasts: [[1], [2], ...]}\n   *\n   * Most of the time, only the node is used and the position information is\n   * discarded. But if you use a predicate, we need to try every value of\n   * position and last in case the predicate calls position() or last().\n   */\n\n  /**\n   * The NodeMultiSet is a helper class to help generate\n   * {nodes:[], pos:[], lasts:[]} structures. It is useful for the\n   * descendant, descendant-or-self, following-sibling, and\n   * preceding-sibling axes for which we can use a stack to organize things.\n   */\n\n\n  function NodeMultiSet(isReverseAxis) {\n    this.nodes = [];\n    this.pos = [];\n    this.lasts = [];\n    this.nextPos = [];\n    this.seriesIndexes = []; // index within nodes that each series begins.\n\n    this.isReverseAxis = isReverseAxis;\n    this._pushToNodes = isReverseAxis ? Array.prototype.unshift : Array.prototype.push;\n  }\n\n  NodeMultiSet.prototype = {\n    pushSeries: function pushSeries() {\n      this.nextPos.push(1);\n      this.seriesIndexes.push(this.nodes.length);\n    },\n    popSeries: function popSeries() {\n      console.assert(0 < this.nextPos.length, this.nextPos);\n      var last = this.nextPos.pop() - 1,\n          indexInPos = this.nextPos.length,\n          seriesBeginIndex = this.seriesIndexes.pop(),\n          seriesEndIndex = this.nodes.length;\n\n      for (var i = seriesBeginIndex; i < seriesEndIndex; ++i) {\n        console.assert(indexInPos < this.lasts[i].length);\n        console.assert(undefined === this.lasts[i][indexInPos]);\n        this.lasts[i][indexInPos] = last;\n      }\n    },\n    finalize: function () {\n      if (null == this.nextPos) return this;\n      console.assert(0 === this.nextPos.length);\n      var lastsJSON = JSON.stringify(this.lasts);\n\n      for (var i = 0; i < this.lasts.length; ++i) {\n        for (var j = 0; j < this.lasts[i].length; ++j) {\n          console.assert(null != this.lasts[i][j], i + ',' + j + ':' + lastsJSON);\n        }\n      }\n\n      this.pushSeries = this.popSeries = this.addNode = function () {\n        throw new Error('Already finalized.');\n      };\n\n      return this;\n    },\n    addNode: function addNode(node) {\n      console.assert(node);\n\n      this._pushToNodes.call(this.nodes, node);\n\n      this._pushToNodes.call(this.pos, this.nextPos.slice());\n\n      this._pushToNodes.call(this.lasts, new Array(this.nextPos.length));\n\n      for (var i = 0; i < this.nextPos.length; ++i) this.nextPos[i]++;\n    },\n    simplify: function () {\n      this.finalize();\n      return {\n        nodes: this.nodes,\n        pos: this.pos,\n        lasts: this.lasts\n      };\n    }\n  };\n\n  function eachContext(nodeMultiSet) {\n    var r = [];\n\n    for (var i = 0; i < nodeMultiSet.nodes.length; i++) {\n      var node = nodeMultiSet.nodes[i];\n\n      if (!nodeMultiSet.pos) {\n        r.push({\n          nodes: [node],\n          pos: [[i + 1]],\n          lasts: [[nodeMultiSet.nodes.length]]\n        });\n      } else {\n        for (var j = 0; j < nodeMultiSet.pos[i].length; ++j) {\n          r.push({\n            nodes: [node],\n            pos: [[nodeMultiSet.pos[i][j]]],\n            lasts: [[nodeMultiSet.lasts[i][j]]]\n          });\n        }\n      }\n    }\n\n    return r;\n  }\n  /** Matcher used in the axes.\n   */\n\n\n  function NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase) {\n    this.nodeTypeNum = nodeTypeNum;\n    this.nodeName = nodeName;\n    this.shouldLowerCase = shouldLowerCase;\n    this.nodeNameTest = null == nodeName ? this._alwaysTrue : shouldLowerCase ? this._nodeNameLowerCaseEquals : this._nodeNameEquals;\n  }\n\n  NodeMatcher.prototype = {\n    matches: function matches(node) {\n      if (0 === this.nodeTypeNum || this._nodeTypeMatches(node)) {\n        return this.nodeNameTest(getNodeName(node));\n      }\n\n      return false;\n    },\n\n    _nodeTypeMatches(nodeOrAttr) {\n      if (nodeOrAttr.constructor.name === 'Attr' && this.nodeTypeNum === 2) {\n        return true;\n      }\n\n      return nodeOrAttr.nodeType === this.nodeTypeNum;\n    },\n\n    _alwaysTrue: function (name) {\n      return true;\n    },\n    _nodeNameEquals: function _nodeNameEquals(name) {\n      return this.nodeName === name;\n    },\n    _nodeNameLowerCaseEquals: function _nodeNameLowerCaseEquals(name) {\n      return this.nodeName === name.toLowerCase();\n    }\n  };\n\n  function followingSiblingHelper(nodeList\n  /*destructive!*/\n  , nodeTypeNum, nodeName, shouldLowerCase, shift, peek, followingNode, andSelf, isReverseAxis) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var nodeMultiSet = new NodeMultiSet(isReverseAxis);\n\n    while (0 < nodeList.length) {\n      // can be if for following, preceding\n      var node = shift.call(nodeList);\n      console.assert(node != null);\n      node = followingNode(node);\n      nodeMultiSet.pushSeries();\n      var numPushed = 1;\n\n      while (null != node) {\n        if (!andSelf && matcher.matches(node)) nodeMultiSet.addNode(node);\n\n        if (node === peek.call(nodeList)) {\n          shift.call(nodeList);\n          nodeMultiSet.pushSeries();\n          numPushed++;\n        }\n\n        if (andSelf && matcher.matches(node)) nodeMultiSet.addNode(node);\n        node = followingNode(node);\n      }\n\n      while (0 < numPushed--) nodeMultiSet.popSeries();\n    }\n\n    return nodeMultiSet;\n  }\n  /** Returns the next non-descendant node in document order.\n   * This is the first node in following::node(), if node is the context.\n   */\n\n\n  function followingNonDescendantNode(node) {\n    if (node.ownerElement) {\n      if (node.ownerElement.firstChild) return node.ownerElement.firstChild;\n      node = node.ownerElement;\n    }\n\n    do {\n      if (node.nextSibling) return node.nextSibling;\n    } while (node = node.parentNode);\n\n    return null;\n  }\n  /** Returns the next node in a document-order depth-first search.\n   * See the definition of document order[1]:\n   *   1) element\n   *   2) namespace nodes\n   *   3) attributes\n   *   4) children\n   *   [1]: http://www.w3.org/TR/xpath/#dt-document-order\n   */\n\n\n  function followingNode(node) {\n    if (node.ownerElement) // attributes: following node of element.\n      node = node.ownerElement;\n    if (null != node.firstChild) return node.firstChild;\n\n    do {\n      if (null != node.nextSibling) {\n        return node.nextSibling;\n      }\n\n      node = node.parentNode;\n    } while (node);\n\n    return null;\n  }\n  /** Returns the previous node in document order (excluding attributes\n   * and namespace nodes).\n   */\n\n\n  function precedingNode(node) {\n    if (node.ownerElement) return node.ownerElement;\n\n    if (null != node.previousSibling) {\n      node = node.previousSibling;\n\n      while (null != node.lastChild) {\n        node = node.lastChild;\n      }\n\n      return node;\n    }\n\n    if (null != node.parentNode) {\n      return node.parentNode;\n    }\n\n    return null;\n  }\n  /** This axis is inefficient if there are many nodes in the nodeList.\n   * But I think it's a pretty useless axis so it's ok. */\n\n\n  function followingHelper(nodeList\n  /*destructive!*/\n  , nodeTypeNum, nodeName, shouldLowerCase) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var nodeMultiSet = new NodeMultiSet(false);\n    var cursor = nodeList[0];\n    var unorderedFollowingStarts = [];\n\n    for (var i = 0; i < nodeList.length; i++) {\n      var node = nodeList[i];\n      var start = followingNonDescendantNode(node);\n      if (start) unorderedFollowingStarts.push(start);\n    }\n\n    if (0 === unorderedFollowingStarts.length) return {\n      nodes: []\n    };\n    var pos = [],\n        nextPos = [];\n    var started = 0;\n\n    while (cursor = followingNode(cursor)) {\n      for (var i = unorderedFollowingStarts.length - 1; i >= 0; i--) {\n        if (cursor === unorderedFollowingStarts[i]) {\n          nodeMultiSet.pushSeries();\n          unorderedFollowingStarts.splice(i, i + 1);\n          started++;\n        }\n      }\n\n      if (started && matcher.matches(cursor)) {\n        nodeMultiSet.addNode(cursor);\n      }\n    }\n\n    console.assert(0 === unorderedFollowingStarts.length);\n\n    for (var i = 0; i < started; i++) nodeMultiSet.popSeries();\n\n    return nodeMultiSet.finalize();\n  }\n\n  function precedingHelper(nodeList\n  /*destructive!*/\n  , nodeTypeNum, nodeName, shouldLowerCase) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var cursor = nodeList.pop();\n    if (null == cursor) return {\n      nodes: {}\n    };\n    var r = {\n      nodes: [],\n      pos: [],\n      lasts: []\n    };\n    var nextParents = [cursor.parentNode || cursor.ownerElement],\n        nextPos = [1];\n\n    while (cursor = precedingNode(cursor)) {\n      if (cursor === nodeList[nodeList.length - 1]) {\n        nextParents.push(nodeList.pop());\n        nextPos.push(1);\n      }\n\n      var matches = matcher.matches(cursor);\n      var pos,\n          someoneUsed = false;\n      if (matches) pos = nextPos.slice();\n\n      for (var i = 0; i < nextParents.length; ++i) {\n        if (cursor === nextParents[i]) {\n          nextParents[i] = cursor.parentNode || cursor.ownerElement;\n\n          if (matches) {\n            pos[i] = null;\n          }\n        } else {\n          if (matches) {\n            pos[i] = nextPos[i]++;\n            someoneUsed = true;\n          }\n        }\n      }\n\n      if (someoneUsed) {\n        r.nodes.unshift(cursor);\n        r.pos.unshift(pos);\n      }\n    }\n\n    for (var i = 0; i < r.pos.length; ++i) {\n      var lasts = [];\n      r.lasts.push(lasts);\n\n      for (var j = r.pos[i].length - 1; j >= 0; j--) {\n        if (null == r.pos[i][j]) {\n          r.pos[i].splice(j, j + 1);\n        } else {\n          lasts.unshift(nextPos[j] - 1);\n        }\n      }\n    }\n\n    return r;\n  }\n  /** node-set, axis -> node-set */\n\n\n  function descendantDfs(nodeMultiSet, node, remaining, matcher, andSelf, attrIndices, attrNodes) {\n    while (0 < remaining.length && null != remaining[0].ownerElement) {\n      var attr = remaining.shift();\n\n      if (andSelf && matcher.matches(attr)) {\n        attrNodes.push(attr);\n        attrIndices.push(nodeMultiSet.nodes.length);\n      }\n    }\n\n    if (null != node && !andSelf) {\n      if (matcher.matches(node)) nodeMultiSet.addNode(node);\n    }\n\n    var pushed = false;\n\n    if (null == node) {\n      if (0 === remaining.length) return;\n      node = remaining.shift();\n      nodeMultiSet.pushSeries();\n      pushed = true;\n    } else if (0 < remaining.length && node === remaining[0]) {\n      nodeMultiSet.pushSeries();\n      pushed = true;\n      remaining.shift();\n    }\n\n    if (andSelf) {\n      if (matcher.matches(node)) nodeMultiSet.addNode(node);\n    } // TODO: use optimization. Also try element.getElementsByTagName\n    // var nodeList = 1 === nodeTypeNum && null != node.children ? node.children : node.childNodes;\n\n\n    var nodeList = node.childNodes;\n\n    for (var j = 0; j < nodeList.length; ++j) {\n      var child = nodeList[j];\n      descendantDfs(nodeMultiSet, child, remaining, matcher, andSelf, attrIndices, attrNodes);\n    }\n\n    if (pushed) {\n      nodeMultiSet.popSeries();\n    }\n  }\n\n  function descenantHelper(nodeList\n  /*destructive!*/\n  , nodeTypeNum, nodeName, shouldLowerCase, andSelf) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var nodeMultiSet = new NodeMultiSet(false);\n    var attrIndices = [],\n        attrNodes = [];\n\n    while (0 < nodeList.length) {\n      // var node = nodeList.shift();\n      descendantDfs(nodeMultiSet, null, nodeList, matcher, andSelf, attrIndices, attrNodes);\n    }\n\n    nodeMultiSet.finalize();\n\n    for (var i = attrNodes.length - 1; i >= 0; --i) {\n      nodeMultiSet.nodes.splice(attrIndices[i], attrIndices[i], attrNodes[i]);\n      nodeMultiSet.pos.splice(attrIndices[i], attrIndices[i], [1]);\n      nodeMultiSet.lasts.splice(attrIndices[i], attrIndices[i], [1]);\n    }\n\n    return nodeMultiSet;\n  }\n  /**\n   */\n\n\n  function ancestorHelper(nodeList\n  /*destructive!*/\n  , nodeTypeNum, nodeName, shouldLowerCase, andSelf) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var ancestors = []; // array of non-empty arrays of matching ancestors\n\n    for (var i = 0; i < nodeList.length; ++i) {\n      var node = nodeList[i];\n      var isFirst = true;\n      var a = [];\n\n      while (null != node) {\n        if (!isFirst || andSelf) {\n          if (matcher.matches(node)) a.push(node);\n        }\n\n        isFirst = false;\n        node = node.parentNode || node.ownerElement;\n      }\n\n      if (0 < a.length) ancestors.push(a);\n    }\n\n    var lasts = [];\n\n    for (var i = 0; i < ancestors.length; ++i) lasts.push(ancestors[i].length);\n\n    var nodeMultiSet = new NodeMultiSet(true);\n    var newCtx = {\n      nodes: [],\n      pos: [],\n      lasts: []\n    };\n\n    while (0 < ancestors.length) {\n      var pos = [ancestors[0].length];\n      var last = [lasts[0]];\n      var node = ancestors[0].pop();\n\n      for (var i = ancestors.length - 1; i > 0; --i) {\n        if (node === ancestors[i][ancestors[i].length - 1]) {\n          pos.push(ancestors[i].length);\n          last.push(lasts[i]);\n          ancestors[i].pop();\n\n          if (0 === ancestors[i].length) {\n            ancestors.splice(i, i + 1);\n            lasts.splice(i, i + 1);\n          }\n        }\n      }\n\n      if (0 === ancestors[0].length) {\n        ancestors.shift();\n        lasts.shift();\n      }\n\n      newCtx.nodes.push(node);\n      newCtx.pos.push(pos);\n      newCtx.lasts.push(last);\n    }\n\n    return newCtx;\n  }\n  /** Helper function for sortDocumentOrder. Returns a list of indices, from the\n   * node to the root, of positions within parent.\n   * For convenience, the node is the first element of the array.\n   */\n\n\n  function addressVector(node) {\n    var r = [node];\n\n    if (null != node.ownerElement) {\n      node = node.ownerElement;\n      r.push(-1);\n    }\n\n    while (null != node) {\n      var i = 0;\n\n      while (null != node.previousSibling) {\n        node = node.previousSibling;\n        i++;\n      }\n\n      r.push(i);\n      node = node.parentNode;\n    }\n\n    return r;\n  }\n\n  function addressComparator(a, b) {\n    var minlen = Math.min(a.length - 1, b.length - 1),\n        // not including [0]=node\n    alen = a.length,\n        blen = b.length;\n    if (a[0] === b[0]) return 0;\n    var c;\n\n    for (var i = 0; i < minlen; ++i) {\n      c = a[alen - i - 1] - b[blen - i - 1];\n      if (0 !== c) break;\n    }\n\n    if (null == c || 0 === c) {\n      // All equal until one of the nodes. The longer one is the descendant.\n      c = alen - blen;\n    }\n\n    if (0 === c) c = getNodeName(a) - getNodeName(b);\n    if (0 === c) c = 1;\n    return c;\n  }\n\n  var sortUniqDocumentOrder = xpath.sortUniqDocumentOrder = function (nodes) {\n    var a = [];\n\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i];\n      var v = addressVector(node);\n      a.push(v);\n    }\n\n    a.sort(addressComparator);\n    var b = [];\n\n    for (var i = 0; i < a.length; i++) {\n      if (0 < i && a[i][0] === a[i - 1][0]) continue;\n      b.push(a[i][0]);\n    }\n\n    return b;\n  };\n  /** Sort node multiset. Does not do any de-duping. */\n\n\n  function sortNodeMultiSet(nodeMultiSet) {\n    var a = [];\n\n    for (var i = 0; i < nodeMultiSet.nodes.length; i++) {\n      var v = addressVector(nodeMultiSet.nodes[i]);\n      a.push({\n        v: v,\n        n: nodeMultiSet.nodes[i],\n        p: nodeMultiSet.pos[i],\n        l: nodeMultiSet.lasts[i]\n      });\n    }\n\n    a.sort(compare);\n    var r = {\n      nodes: [],\n      pos: [],\n      lasts: []\n    };\n\n    for (var i = 0; i < a.length; ++i) {\n      r.nodes.push(a[i].n);\n      r.pos.push(a[i].p);\n      r.lasts.push(a[i].l);\n    }\n\n    function compare(x, y) {\n      return addressComparator(x.v, y.v);\n    }\n\n    return r;\n  }\n  /** Returns an array containing all the ancestors down to a node.\n   * The array starts with document.\n   */\n\n\n  function nodeAndAncestors(node) {\n    var ancestors = [node];\n    var p = node;\n\n    while (p = p.parentNode || p.ownerElement) {\n      ancestors.unshift(p);\n    }\n\n    return ancestors;\n  }\n\n  function compareSiblings(a, b) {\n    if (a === b) return 0;\n    var c = a;\n\n    while (c = c.previousSibling) {\n      if (c === b) return 1; // b < a\n    }\n\n    c = b;\n\n    while (c = c.previousSibling) {\n      if (c === a) return -1; // a < b\n    }\n\n    throw new Error('a and b are not siblings: ' + xpath.stringifyObject(a) + ' vs ' + xpath.stringifyObject(b));\n  }\n  /** The merge in merge-sort.*/\n\n\n  function mergeNodeLists(x, y) {\n    var a,\n        b,\n        aanc,\n        banc,\n        r = [];\n    if ('object' !== typeof x) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Invalid LHS for | operator ' + '(expected node-set): ' + x);\n    if ('object' !== typeof y) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Invalid LHS for | operator ' + '(expected node-set): ' + y);\n\n    while (true) {\n      if (null == a) {\n        a = x.shift();\n        if (null != a) aanc = addressVector(a);\n      }\n\n      if (null == b) {\n        b = y.shift();\n        if (null != b) banc = addressVector(b);\n      }\n\n      if (null == a || null == b) break;\n      var c = addressComparator(aanc, banc);\n\n      if (c < 0) {\n        r.push(a);\n        a = null;\n        aanc = null;\n      } else if (c > 0) {\n        r.push(b);\n        b = null;\n        banc = null;\n      } else if (getNodeName(a) < getNodeName(b)) {\n        // attributes\n        r.push(a);\n        a = null;\n        aanc = null;\n      } else if (getNodeName(a) > getNodeName(b)) {\n        // attributes\n        r.push(b);\n        b = null;\n        banc = null;\n      } else if (a !== b) {\n        // choose b arbitrarily\n        r.push(b);\n        b = null;\n        banc = null;\n      } else {\n        console.assert(a === b, c); // just skip b without pushing it.\n\n        b = null;\n        banc = null;\n      }\n    }\n\n    while (a) {\n      r.push(a);\n      a = x.shift();\n    }\n\n    while (b) {\n      r.push(b);\n      b = y.shift();\n    }\n\n    return r;\n  }\n\n  function comparisonHelper(test, x, y, isNumericComparison) {\n    var coersion;\n    if (isNumericComparison) coersion = fn.number;else coersion = 'boolean' === typeof x || 'boolean' === typeof y ? fn['boolean'] : 'number' === typeof x || 'number' === typeof y ? fn.number : fn.string;\n\n    if ('object' === typeof x && 'object' === typeof y) {\n      var aMap = {};\n\n      for (var i = 0; i < x.nodes.length; ++i) {\n        var xi = coersion({\n          nodes: [x.nodes[i]]\n        });\n\n        for (var j = 0; j < y.nodes.length; ++j) {\n          var yj = coersion({\n            nodes: [y.nodes[j]]\n          });\n          if (test(xi, yj)) return true;\n        }\n      }\n\n      return false;\n    } else if ('object' === typeof x && x.nodes && x.nodes.length) {\n      for (var i = 0; i < x.nodes.length; ++i) {\n        var xi = coersion({\n          nodes: [x.nodes[i]]\n        }),\n            yc = coersion(y);\n        if (test(xi, yc)) return true;\n      }\n\n      return false;\n    } else if ('object' === typeof y && x.nodes && x.nodes.length) {\n      for (var i = 0; i < x.nodes.length; ++i) {\n        var yi = coersion({\n          nodes: [y.nodes[i]]\n        }),\n            xc = coersion(x);\n        if (test(xc, yi)) return true;\n      }\n\n      return false;\n    } else {\n      var xc = coersion(x),\n          yc = coersion(y);\n      return test(xc, yc);\n    }\n  }\n\n  var axes = xpath.axes = {\n    'ancestor': function ancestor(nodeList\n    /*destructive!*/\n    , nodeTypeNum, nodeName, shouldLowerCase) {\n      return ancestorHelper(nodeList\n      /*destructive!*/\n      , nodeTypeNum, nodeName, shouldLowerCase, false);\n    },\n    'ancestor-or-self': function ancestorOrSelf(nodeList\n    /*destructive!*/\n    , nodeTypeNum, nodeName, shouldLowerCase) {\n      return ancestorHelper(nodeList\n      /*destructive!*/\n      , nodeTypeNum, nodeName, shouldLowerCase, true);\n    },\n    'attribute': function attribute(nodeList\n    /*destructive!*/\n    , nodeTypeNum, nodeName, shouldLowerCase) {\n      // TODO: figure out whether positions should be undefined here.\n      var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n      var nodeMultiSet = new NodeMultiSet(false);\n\n      if (null != nodeName) {\n        // TODO: with namespace\n        for (var i = 0; i < nodeList.length; ++i) {\n          var node = nodeList[i];\n          if (null == node.getAttributeNode) continue; // only Element has .getAttributeNode\n\n          var attr = node.getAttributeNode(nodeName);\n\n          if (null != attr && matcher.matches(attr)) {\n            nodeMultiSet.pushSeries();\n            nodeMultiSet.addNode(attr);\n            nodeMultiSet.popSeries();\n          }\n        }\n      } else {\n        for (var i = 0; i < nodeList.length; ++i) {\n          var node = nodeList[i];\n\n          if (null != node.attributes) {\n            nodeMultiSet.pushSeries();\n\n            for (var j = 0; j < node.attributes.length; j++) {\n              // all nodes have .attributes\n              var attr = node.attributes[j];\n              if (matcher.matches(attr)) // TODO: I think this check is unnecessary\n                nodeMultiSet.addNode(attr);\n            }\n\n            nodeMultiSet.popSeries();\n          }\n        }\n      }\n\n      return nodeMultiSet.finalize();\n    },\n    'child': function child(nodeList\n    /*destructive!*/\n    , nodeTypeNum, nodeName, shouldLowerCase) {\n      var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n      var nodeMultiSet = new NodeMultiSet(false);\n\n      for (var i = 0; i < nodeList.length; ++i) {\n        var n = nodeList[i];\n        if (n.ownerElement) // skip attribute nodes' text child.\n          continue;\n\n        if (n.childNodes) {\n          nodeMultiSet.pushSeries();\n          var childList = 1 === nodeTypeNum && null != n.children ? n.children : n.childNodes;\n\n          for (var j = 0; j < childList.length; ++j) {\n            var child = childList[j];\n\n            if (matcher.matches(child)) {\n              nodeMultiSet.addNode(child);\n            } // don't have to do de-duping because children have parent,\n            // which are current context.\n\n          }\n\n          nodeMultiSet.popSeries();\n        }\n      }\n\n      nodeMultiSet.finalize();\n      return sortNodeMultiSet(nodeMultiSet);\n    },\n    'descendant': function descenant(nodeList\n    /*destructive!*/\n    , nodeTypeNum, nodeName, shouldLowerCase) {\n      return descenantHelper(nodeList\n      /*destructive!*/\n      , nodeTypeNum, nodeName, shouldLowerCase, false);\n    },\n    'descendant-or-self': function descenantOrSelf(nodeList\n    /*destructive!*/\n    , nodeTypeNum, nodeName, shouldLowerCase) {\n      return descenantHelper(nodeList\n      /*destructive!*/\n      , nodeTypeNum, nodeName, shouldLowerCase, true);\n    },\n    'following': function following(nodeList\n    /*destructive!*/\n    , nodeTypeNum, nodeName, shouldLowerCase) {\n      return followingHelper(nodeList\n      /*destructive!*/\n      , nodeTypeNum, nodeName, shouldLowerCase);\n    },\n    'following-sibling': function followingSibling(nodeList\n    /*destructive!*/\n    , nodeTypeNum, nodeName, shouldLowerCase) {\n      return followingSiblingHelper(nodeList\n      /*destructive!*/\n      , nodeTypeNum, nodeName, shouldLowerCase, Array.prototype.shift, function () {\n        return this[0];\n      }, function (node) {\n        return node.nextSibling;\n      });\n    },\n    'namespace': function namespace(nodeList\n    /*destructive!*/\n    , nodeTypeNum, nodeName, shouldLowerCase) {// TODO\n    },\n    'parent': function parent(nodeList\n    /*destructive!*/\n    , nodeTypeNum, nodeName, shouldLowerCase) {\n      var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n      var nodes = [],\n          pos = [];\n\n      for (var i = 0; i < nodeList.length; ++i) {\n        var parent = nodeList[i].parentNode || nodeList[i].ownerElement;\n        if (null == parent) continue;\n        if (!matcher.matches(parent)) continue;\n        if (nodes.length > 0 && parent === nodes[nodes.length - 1]) continue;\n        nodes.push(parent);\n        pos.push([1]);\n      }\n\n      return {\n        nodes: nodes,\n        pos: pos,\n        lasts: pos\n      };\n    },\n    'preceding': function preceding(nodeList\n    /*destructive!*/\n    , nodeTypeNum, nodeName, shouldLowerCase) {\n      return precedingHelper(nodeList\n      /*destructive!*/\n      , nodeTypeNum, nodeName, shouldLowerCase);\n    },\n    'preceding-sibling': function precedingSibling(nodeList\n    /*destructive!*/\n    , nodeTypeNum, nodeName, shouldLowerCase) {\n      return followingSiblingHelper(nodeList\n      /*destructive!*/\n      , nodeTypeNum, nodeName, shouldLowerCase, Array.prototype.pop, function () {\n        return this[this.length - 1];\n      }, function (node) {\n        return node.previousSibling;\n      }, false, true);\n    },\n    'self': function self(nodeList\n    /*destructive!*/\n    , nodeTypeNum, nodeName, shouldLowerCase) {\n      var nodes = [],\n          pos = [];\n      var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n\n      for (var i = 0; i < nodeList.length; ++i) {\n        if (matcher.matches(nodeList[i])) {\n          nodes.push(nodeList[i]);\n          pos.push([1]);\n        }\n      }\n\n      return {\n        nodes: nodes,\n        pos: pos,\n        lasts: pos\n      };\n    }\n  };\n  /***************************************************************************\n   *                         Evaluation: functions                           *\n   ***************************************************************************/\n\n  var fn = {\n    'number': function number(optObject) {\n      if ('number' === typeof optObject) return optObject;\n      if ('string' === typeof optObject) return parseFloat(optObject); // note: parseFloat(' ') -> NaN, unlike +' ' -> 0.\n\n      if ('boolean' === typeof optObject) return +optObject;\n      return fn.number(fn.string.call(this, optObject)); // for node-sets\n    },\n    'string': function string(optObject) {\n      if (null == optObject) return fn.string(this);\n      if ('string' === typeof optObject || 'boolean' === typeof optObject || 'number' === typeof optObject) return '' + optObject;\n      if (0 == optObject.nodes.length) return '';\n      if (null != optObject.nodes[0].textContent) return optObject.nodes[0].textContent;\n      return optObject.nodes[0].nodeValue;\n    },\n    'boolean': function booleanVal(x) {\n      return 'object' === typeof x ? x.nodes.length > 0 : !!x;\n    },\n    'last': function last() {\n      console.assert(Array.isArray(this.pos));\n      console.assert(Array.isArray(this.lasts));\n      console.assert(1 === this.pos.length);\n      console.assert(1 === this.lasts.length);\n      console.assert(1 === this.lasts[0].length);\n      return this.lasts[0][0];\n    },\n    'position': function position() {\n      console.assert(Array.isArray(this.pos));\n      console.assert(Array.isArray(this.lasts));\n      console.assert(1 === this.pos.length);\n      console.assert(1 === this.lasts.length);\n      console.assert(1 === this.pos[0].length);\n      return this.pos[0][0];\n    },\n    'count': function count(nodeSet) {\n      if ('object' !== typeof nodeSet) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Position ' + stream.position() + ': Function count(node-set) ' + 'got wrong argument type: ' + nodeSet);\n      return nodeSet.nodes.length;\n    },\n    'id': function id(object) {\n      var r = {\n        nodes: []\n      };\n      var doc = this.nodes[0].ownerDocument || this.nodes[0];\n      console.assert(doc);\n      var ids;\n\n      if ('object' === typeof object) {\n        // for node-sets, map id over each node value.\n        ids = [];\n\n        for (var i = 0; i < object.nodes.length; ++i) {\n          var idNode = object.nodes[i];\n          var idsString = fn.string({\n            nodes: [idNode]\n          });\n          var a = idsString.split(/[ \\t\\r\\n]+/g);\n          Array.prototype.push.apply(ids, a);\n        }\n      } else {\n        var idsString = fn.string(object);\n        var a = idsString.split(/[ \\t\\r\\n]+/g);\n        ids = a;\n      }\n\n      for (var i = 0; i < ids.length; ++i) {\n        var id = ids[i];\n        if (0 === id.length) continue;\n        var node = doc.getElementById(id);\n        if (null != node) r.nodes.push(node);\n      }\n\n      r.nodes = sortUniqDocumentOrder(r.nodes);\n      return r;\n    },\n    'local-name': function (nodeSet) {\n      if (null == nodeSet) return fn.name(this);\n\n      if (null == nodeSet.nodes) {\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'argument to name() must be a node-set. got ' + nodeSet);\n      } // TODO: namespaced version\n\n\n      return nodeSet.nodes[0].localName;\n    },\n    'namespace-uri': function (nodeSet) {\n      // TODO\n      throw new Error('not implemented yet');\n    },\n    'name': function (nodeSet) {\n      if (null == nodeSet) return fn.name(this);\n\n      if (null == nodeSet.nodes) {\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'argument to name() must be a node-set. got ' + nodeSet);\n      }\n\n      return nodeSet.nodes[0].name;\n    },\n    'concat': function concat(x) {\n      var l = [];\n\n      for (var i = 0; i < arguments.length; ++i) {\n        l.push(fn.string(arguments[i]));\n      }\n\n      return l.join('');\n    },\n    'starts-with': function startsWith(a, b) {\n      var as = fn.string(a),\n          bs = fn.string(b);\n      return as.substr(0, bs.length) === bs;\n    },\n    'contains': function contains(a, b) {\n      var as = fn.string(a),\n          bs = fn.string(b);\n      var i = as.indexOf(bs);\n      if (-1 === i) return false;\n      return true;\n    },\n    'substring-before': function substringBefore(a, b) {\n      var as = fn.string(a),\n          bs = fn.string(b);\n      var i = as.indexOf(bs);\n      if (-1 === i) return '';\n      return as.substr(0, i);\n    },\n    'substring-after': function substringBefore(a, b) {\n      var as = fn.string(a),\n          bs = fn.string(b);\n      var i = as.indexOf(bs);\n      if (-1 === i) return '';\n      return as.substr(i + bs.length);\n    },\n    'substring': function substring(string, start, optEnd) {\n      if (null == string || null == start) {\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Must be at least 2 arguments to string()');\n      }\n\n      var sString = fn.string(string),\n          iStart = fn.round(start),\n          iEnd = optEnd == null ? null : fn.round(optEnd); // Note that xpath string positions user 1-based index\n\n      if (iEnd == null) return sString.substr(iStart - 1);else return sString.substr(iStart - 1, iEnd);\n    },\n    'string-length': function stringLength(optString) {\n      return fn.string.call(this, optString).length;\n    },\n    'normalize-space': function normalizeSpace(optString) {\n      var s = fn.string.call(this, optString);\n      return s.replace(/[ \\t\\r\\n]+/g, ' ').replace(/^ | $/g, '');\n    },\n    'translate': function translate(string, from, to) {\n      var sString = fn.string.call(this, string),\n          sFrom = fn.string(from),\n          sTo = fn.string(to);\n      var eachCharRe = [];\n      var map = {};\n\n      for (var i = 0; i < sFrom.length; ++i) {\n        var c = sFrom.charAt(i);\n        map[c] = sTo.charAt(i); // returns '' if beyond length of sTo.\n        // copied from goog.string.regExpEscape in the Closure library.\n\n        eachCharRe.push(c.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, '\\\\$1').replace(/\\x08/g, '\\\\x08'));\n      }\n\n      var re = new RegExp(eachCharRe.join('|'), 'g');\n      return sString.replace(re, function (c) {\n        return map[c];\n      });\n    },\n    /// Boolean functions\n    'not': function not(x) {\n      var bx = fn['boolean'](x);\n      return !bx;\n    },\n    'true': function trueVal() {\n      return true;\n    },\n    'false': function falseVal() {\n      return false;\n    },\n    // TODO\n    'lang': function lang(string) {\n      throw new Error('Not implemented');\n    },\n    'sum': function sum(optNodeSet) {\n      if (null == optNodeSet) return fn.sum(this); // for node-sets, map id over each node value.\n\n      var sum = 0;\n\n      for (var i = 0; i < optNodeSet.nodes.length; ++i) {\n        var node = optNodeSet.nodes[i];\n        var x = fn.number({\n          nodes: [node]\n        });\n        sum += x;\n      }\n\n      return sum;\n    },\n    'floor': function floor(number) {\n      return Math.floor(fn.number(number));\n    },\n    'ceiling': function ceiling(number) {\n      return Math.ceil(fn.number(number));\n    },\n    'round': function round(number) {\n      return Math.round(fn.number(number));\n    }\n  };\n  /***************************************************************************\n   *                         Evaluation: operators                           *\n   ***************************************************************************/\n\n  var more = {\n    UnaryMinus: function (x) {\n      return -fn.number(x);\n    },\n    '+': function (x, y) {\n      return fn.number(x) + fn.number(y);\n    },\n    '-': function (x, y) {\n      return fn.number(x) - fn.number(y);\n    },\n    '*': function (x, y) {\n      return fn.number(x) * fn.number(y);\n    },\n    'div': function (x, y) {\n      return fn.number(x) / fn.number(y);\n    },\n    'mod': function (x, y) {\n      return fn.number(x) % fn.number(y);\n    },\n    '<': function (x, y) {\n      return comparisonHelper(function (x, y) {\n        return fn.number(x) < fn.number(y);\n      }, x, y, true);\n    },\n    '<=': function (x, y) {\n      return comparisonHelper(function (x, y) {\n        return fn.number(x) <= fn.number(y);\n      }, x, y, true);\n    },\n    '>': function (x, y) {\n      return comparisonHelper(function (x, y) {\n        return fn.number(x) > fn.number(y);\n      }, x, y, true);\n    },\n    '>=': function (x, y) {\n      return comparisonHelper(function (x, y) {\n        return fn.number(x) >= fn.number(y);\n      }, x, y, true);\n    },\n    'and': function (x, y) {\n      return fn['boolean'](x) && fn['boolean'](y);\n    },\n    'or': function (x, y) {\n      return fn['boolean'](x) || fn['boolean'](y);\n    },\n    '|': function (x, y) {\n      return {\n        nodes: mergeNodeLists(x.nodes, y.nodes)\n      };\n    },\n    '=': function (x, y) {\n      // optimization for two node-sets case: avoid n^2 comparisons.\n      if ('object' === typeof x && 'object' === typeof y) {\n        var aMap = {};\n\n        for (var i = 0; i < x.nodes.length; ++i) {\n          var s = fn.string({\n            nodes: [x.nodes[i]]\n          });\n          aMap[s] = true;\n        }\n\n        for (var i = 0; i < y.nodes.length; ++i) {\n          var s = fn.string({\n            nodes: [y.nodes[i]]\n          });\n          if (aMap[s]) return true;\n        }\n\n        return false;\n      } else {\n        return comparisonHelper(function (x, y) {\n          return x === y;\n        }, x, y);\n      }\n    },\n    '!=': function (x, y) {\n      // optimization for two node-sets case: avoid n^2 comparisons.\n      if ('object' === typeof x && 'object' === typeof y) {\n        if (0 === x.nodes.length || 0 === y.nodes.length) return false;\n        var aMap = {};\n\n        for (var i = 0; i < x.nodes.length; ++i) {\n          var s = fn.string({\n            nodes: [x.nodes[i]]\n          });\n          aMap[s] = true;\n        }\n\n        for (var i = 0; i < y.nodes.length; ++i) {\n          var s = fn.string({\n            nodes: [y.nodes[i]]\n          });\n          if (!aMap[s]) return true;\n        }\n\n        return false;\n      } else {\n        return comparisonHelper(function (x, y) {\n          return x !== y;\n        }, x, y);\n      }\n    }\n  };\n  var nodeTypes = xpath.nodeTypes = {\n    'node': 0,\n    'attribute': 2,\n    'comment': 8,\n    // this.doc.COMMENT_NODE,\n    'text': 3,\n    // this.doc.TEXT_NODE,\n    'processing-instruction': 7,\n    // this.doc.PROCESSING_INSTRUCTION_NODE,\n    'element': 1 //this.doc.ELEMENT_NODE\n\n  };\n  /** For debugging and unit tests: returnjs a stringified version of the\n   * argument. */\n\n  var stringifyObject = xpath.stringifyObject = function stringifyObject(ctx) {\n    var seenKey = 'seen' + Math.floor(Math.random() * 1000000000);\n    return JSON.stringify(helper(ctx));\n\n    function helper(ctx) {\n      if (Array.isArray(ctx)) {\n        return ctx.map(function (x) {\n          return helper(x);\n        });\n      }\n\n      if ('object' !== typeof ctx) return ctx;\n      if (null == ctx) return ctx; //  if (ctx.toString) return ctx.toString();\n\n      if (null != ctx.outerHTML) return ctx.outerHTML;\n      if (null != ctx.nodeValue) return ctx.nodeName + '=' + ctx.nodeValue;\n      if (ctx[seenKey]) return '[circular]';\n      ctx[seenKey] = true;\n      var nicer = {};\n\n      for (var key in ctx) {\n        if (seenKey === key) continue;\n\n        try {\n          nicer[key] = helper(ctx[key]);\n        } catch (e) {\n          nicer[key] = '[exception: ' + e.message + ']';\n        }\n      }\n\n      delete ctx[seenKey];\n      return nicer;\n    }\n  };\n\n  var Evaluator = xpath.Evaluator = function Evaluator(doc) {\n    this.doc = doc;\n  };\n\n  Evaluator.prototype = {\n    val: function val(ast, ctx) {\n      console.assert(ctx.nodes);\n      if ('number' === typeof ast || 'string' === typeof ast) return ast;\n\n      if (more[ast[0]]) {\n        var evaluatedParams = [];\n\n        for (var i = 1; i < ast.length; ++i) {\n          evaluatedParams.push(this.val(ast[i], ctx));\n        }\n\n        var r = more[ast[0]].apply(ctx, evaluatedParams);\n        return r;\n      }\n\n      switch (ast[0]) {\n        case 'Root':\n          return {\n            nodes: [this.doc]\n          };\n\n        case 'FunctionCall':\n          var functionName = ast[1],\n              functionParams = ast[2];\n          if (null == fn[functionName]) throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, 'Unknown function: ' + functionName);\n          var evaluatedParams = [];\n\n          for (var i = 0; i < functionParams.length; ++i) {\n            evaluatedParams.push(this.val(functionParams[i], ctx));\n          }\n\n          var r = fn[functionName].apply(ctx, evaluatedParams);\n          return r;\n\n        case 'Predicate':\n          var lhs = this.val(ast[1], ctx);\n          var ret = {\n            nodes: []\n          };\n          var contexts = eachContext(lhs);\n\n          for (var i = 0; i < contexts.length; ++i) {\n            var singleNodeSet = contexts[i];\n            var rhs = this.val(ast[2], singleNodeSet);\n            var success;\n\n            if ('number' === typeof rhs) {\n              success = rhs === singleNodeSet.pos[0][0];\n            } else {\n              success = fn['boolean'](rhs);\n            }\n\n            if (success) {\n              var node = singleNodeSet.nodes[0];\n              ret.nodes.push(node); // skip over all the rest of the same node.\n\n              while (i + 1 < contexts.length && node === contexts[i + 1].nodes[0]) {\n                i++;\n              }\n            }\n          }\n\n          return ret;\n\n        case 'PathExpr':\n          // turn the path into an expressoin; i.e., remove the position\n          // information of the last axis.\n          var x = this.val(ast[1], ctx); // Make the nodeset a forward-direction-only one.\n\n          if (x.finalize) {\n            // it is a NodeMultiSet\n            return {\n              nodes: x.nodes\n            };\n          } else {\n            return x;\n          }\n\n        case '/':\n          // TODO: don't generate '/' nodes, just Axis nodes.\n          var lhs = this.val(ast[1], ctx);\n          console.assert(null != lhs);\n          var r = this.val(ast[2], lhs);\n          console.assert(null != r);\n          return r;\n\n        case 'Axis':\n          // All the axis tests from Step. We only get AxisSpecifier NodeTest,\n          // not the predicate (which is applied later)\n          var axis = ast[1],\n              nodeType = ast[2],\n              nodeTypeNum = nodeTypes[nodeType],\n              shouldLowerCase = true,\n              // TODO: give option\n          nodeName = ast[3] && shouldLowerCase ? ast[3].toLowerCase() : ast[3];\n          nodeName = nodeName === '*' ? null : nodeName;\n          if ('object' !== typeof ctx) return {\n            nodes: [],\n            pos: []\n          };\n          var nodeList = ctx.nodes.slice(); // TODO: is copy needed?\n\n          var r = axes[axis](nodeList\n          /*destructive!*/\n          , nodeTypeNum, nodeName, shouldLowerCase);\n          return r;\n      }\n    }\n  };\n\n  var evaluate = xpath.evaluate = function evaluate(expr, doc, context) {\n    //var astFactory = new AstEvaluatorFactory(doc, context);\n    var stream = new Stream(expr);\n    var ast = parse(stream, astFactory);\n    var val = new Evaluator(doc).val(ast, {\n      nodes: [context]\n    });\n    return val;\n  };\n  /***************************************************************************\n   *                           DOM interface                                 *\n   ***************************************************************************/\n\n\n  var XPathException = xpath.XPathException = function XPathException(code, message) {\n    var e = new Error(message);\n    e.name = 'XPathException';\n    e.code = code;\n    return e;\n  };\n\n  XPathException.INVALID_EXPRESSION_ERR = 51;\n  XPathException.TYPE_ERR = 52;\n\n  var XPathEvaluator = xpath.XPathEvaluator = function XPathEvaluator() {};\n\n  XPathEvaluator.prototype = {\n    createExpression: function (expression, resolver) {\n      return new XPathExpression(expression, resolver);\n    },\n    createNSResolver: function (nodeResolver) {// TODO\n    },\n    evaluate: function evaluate(expression, contextNode, resolver, type, result) {\n      var expr = new XPathExpression(expression, resolver);\n      return expr.evaluate(contextNode, type, result);\n    }\n  };\n\n  var XPathExpression = xpath.XPathExpression = function XPathExpression(expression, resolver, optDoc) {\n    var stream = new Stream(expression);\n    this._ast = parse(stream, astFactory);\n    this._doc = optDoc;\n  };\n\n  XPathExpression.prototype = {\n    evaluate: function evaluate(contextNode, type, result) {\n      if (null == contextNode.nodeType) throw new Error('bad argument (expected context node): ' + contextNode);\n      var doc = contextNode.ownerDocument || contextNode;\n\n      if (null != this._doc && this._doc !== doc) {\n        throw new core.DOMException(core.DOMException.WRONG_DOCUMENT_ERR, 'The document must be the same as the context node\\'s document.');\n      }\n\n      var evaluator = new Evaluator(doc);\n      var value = evaluator.val(this._ast, {\n        nodes: [contextNode]\n      });\n      if (XPathResult.NUMBER_TYPE === type) value = fn.number(value);else if (XPathResult.STRING_TYPE === type) value = fn.string(value);else if (XPathResult.BOOLEAN_TYPE === type) value = fn['boolean'](value);else if (XPathResult.ANY_TYPE !== type && XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== type && XPathResult.ORDERED_NODE_ITERATOR_TYPE !== type && XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== type && XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== type && XPathResult.ANY_UNORDERED_NODE_TYPE !== type && XPathResult.FIRST_ORDERED_NODE_TYPE !== type) throw new core.DOMException(core.DOMException.NOT_SUPPORTED_ERR, 'You must provide an XPath result type (0=any).');else if (XPathResult.ANY_TYPE !== type && 'object' !== typeof value) throw new XPathException(XPathException.TYPE_ERR, 'Value should be a node-set: ' + value);\n      return new XPathResult(doc, value, type);\n    }\n  };\n\n  var XPathResult = xpath.XPathResult = function XPathResult(doc, value, resultType) {\n    this._value = value;\n    this._resultType = resultType;\n    this._i = 0; // TODO: we removed mutation events but didn't take care of this. No tests fail, so that's nice, but eventually we\n    // should fix this, preferably by entirely replacing our XPath implementation.\n    // this._invalidated = false;\n    // if (this.resultType === XPathResult.UNORDERED_NODE_ITERATOR_TYPE ||\n    //     this.resultType === XPathResult.ORDERED_NODE_ITERATOR_TYPE) {\n    //   doc.addEventListener('DOMSubtreeModified', invalidate, true);\n    //   var self = this;\n    //   function invalidate() {\n    //     self._invalidated = true;\n    //     doc.removeEventListener('DOMSubtreeModified', invalidate, true);\n    //   }\n    // }\n  };\n\n  XPathResult.ANY_TYPE = 0;\n  XPathResult.NUMBER_TYPE = 1;\n  XPathResult.STRING_TYPE = 2;\n  XPathResult.BOOLEAN_TYPE = 3;\n  XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;\n  XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;\n  XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;\n  XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;\n  XPathResult.ANY_UNORDERED_NODE_TYPE = 8;\n  XPathResult.FIRST_ORDERED_NODE_TYPE = 9;\n  var proto = {\n    // XPathResultType\n    get resultType() {\n      if (this._resultType) return this._resultType;\n\n      switch (typeof this._value) {\n        case 'number':\n          return XPathResult.NUMBER_TYPE;\n\n        case 'string':\n          return XPathResult.STRING_TYPE;\n\n        case 'boolean':\n          return XPathResult.BOOLEAN_TYPE;\n\n        default:\n          return XPathResult.UNORDERED_NODE_ITERATOR_TYPE;\n      }\n    },\n\n    get numberValue() {\n      if (XPathResult.NUMBER_TYPE !== this.resultType) throw new XPathException(XPathException.TYPE_ERR, 'You should have asked for a NUMBER_TYPE.');\n      return this._value;\n    },\n\n    get stringValue() {\n      if (XPathResult.STRING_TYPE !== this.resultType) throw new XPathException(XPathException.TYPE_ERR, 'You should have asked for a STRING_TYPE.');\n      return this._value;\n    },\n\n    get booleanValue() {\n      if (XPathResult.BOOLEAN_TYPE !== this.resultType) throw new XPathException(XPathException.TYPE_ERR, 'You should have asked for a BOOLEAN_TYPE.');\n      return this._value;\n    },\n\n    get singleNodeValue() {\n      if (XPathResult.ANY_UNORDERED_NODE_TYPE !== this.resultType && XPathResult.FIRST_ORDERED_NODE_TYPE !== this.resultType) throw new XPathException(XPathException.TYPE_ERR, 'You should have asked for a FIRST_ORDERED_NODE_TYPE.');\n      return this._value.nodes[0] || null;\n    },\n\n    get invalidIteratorState() {\n      if (XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== this.resultType && XPathResult.ORDERED_NODE_ITERATOR_TYPE !== this.resultType) return false;\n      return !!this._invalidated;\n    },\n\n    get snapshotLength() {\n      if (XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== this.resultType && XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== this.resultType) throw new XPathException(XPathException.TYPE_ERR, 'You should have asked for a ORDERED_NODE_SNAPSHOT_TYPE.');\n      return this._value.nodes.length;\n    },\n\n    iterateNext: function iterateNext() {\n      if (XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== this.resultType && XPathResult.ORDERED_NODE_ITERATOR_TYPE !== this.resultType) throw new XPathException(XPathException.TYPE_ERR, 'You should have asked for a ORDERED_NODE_ITERATOR_TYPE.');\n      if (this.invalidIteratorState) throw new core.DOMException(core.DOMException.INVALID_STATE_ERR, 'The document has been mutated since the result was returned');\n      return this._value.nodes[this._i++] || null;\n    },\n    snapshotItem: function snapshotItem(index) {\n      if (XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== this.resultType && XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== this.resultType) throw new XPathException(XPathException.TYPE_ERR, 'You should have asked for a ORDERED_NODE_SNAPSHOT_TYPE.');\n      return this._value.nodes[index] || null;\n    }\n  }; // so you can access ANY_TYPE etc. from the instances:\n\n  XPathResult.prototype = Object.create(XPathResult, Object.keys(proto).reduce(function (descriptors, name) {\n    descriptors[name] = Object.getOwnPropertyDescriptor(proto, name);\n    return descriptors;\n  }, {\n    constructor: {\n      value: XPathResult,\n      writable: true,\n      configurable: true\n    }\n  }));\n  core.XPathException = XPathException;\n  core.XPathExpression = XPathExpression;\n  core.XPathResult = XPathResult;\n  core.XPathEvaluator = XPathEvaluator;\n  core.Document.prototype.createExpression = XPathEvaluator.prototype.createExpression;\n  core.Document.prototype.createNSResolver = XPathEvaluator.prototype.createNSResolver;\n  core.Document.prototype.evaluate = XPathEvaluator.prototype.evaluate;\n  return xpath; // for tests\n};","map":{"version":3,"names":["module","exports","core","xpath","getNodeName","nodeOrAttr","constructor","name","nodeName","Stream","str","original","peeked","prev","prevprev","prototype","peek","m","re","exec","substr","length","peek2","pop","r","trypop","tokens","tok","Array","isArray","i","t","trypopfuncname","isQnameRe","test","trypopaxisname","trypopnametest","startsWithNcNameRe","trypopliteral","first","charAt","last","trypopnumber","isNumberRe","parseFloat","trypopvarref","position","nameStartCharsExceptColon","nameCharExceptColon","ncNameChars","qNameChars","otherChars","operatorChars","literal","numberChars","variableReference","nameTestChars","optionalSpace","nodeType","RegExp","parse","stream","a","orExpr","x","unparsed","push","XPathException","INVALID_EXPRESSION_ERR","join","binaryL","subExpr","ops","lhs","op","rhs","node","binaryR","locationPath","absoluteLocationPath","relativeLocationPath","isOnlyRootOk","step","undefined","abbrStep","axis","axisSpecifier","nodeTypeTest","nodeNameTest","pred","predicate","attr","axisName","coloncolon","type","param","expr","primaryExpr","varRef","funCall","functionCall","e","params","unionExpr","pathExpr","filter","filterExpr","loc","Error","rel","primary","orig","andExpr","now","equalityExpr","relationalExpr","additiveExpr","multiplicativeExpr","unaryExpr","astFactory","slice","call","arguments","optimize","ast","NodeMultiSet","isReverseAxis","nodes","pos","lasts","nextPos","seriesIndexes","_pushToNodes","unshift","pushSeries","popSeries","console","assert","indexInPos","seriesBeginIndex","seriesEndIndex","finalize","lastsJSON","JSON","stringify","j","addNode","simplify","eachContext","nodeMultiSet","NodeMatcher","nodeTypeNum","shouldLowerCase","_alwaysTrue","_nodeNameLowerCaseEquals","_nodeNameEquals","matches","_nodeTypeMatches","toLowerCase","followingSiblingHelper","nodeList","shift","followingNode","andSelf","matcher","numPushed","followingNonDescendantNode","ownerElement","firstChild","nextSibling","parentNode","precedingNode","previousSibling","lastChild","followingHelper","cursor","unorderedFollowingStarts","start","started","splice","precedingHelper","nextParents","someoneUsed","descendantDfs","remaining","attrIndices","attrNodes","pushed","childNodes","child","descenantHelper","ancestorHelper","ancestors","isFirst","newCtx","addressVector","addressComparator","b","minlen","Math","min","alen","blen","c","sortUniqDocumentOrder","v","sort","sortNodeMultiSet","n","p","l","compare","y","nodeAndAncestors","compareSiblings","stringifyObject","mergeNodeLists","aanc","banc","comparisonHelper","isNumericComparison","coersion","fn","number","string","aMap","xi","yj","yc","yi","xc","axes","ancestor","ancestorOrSelf","attribute","getAttributeNode","attributes","childList","children","descenant","descenantOrSelf","following","followingSibling","namespace","parent","preceding","precedingSibling","self","optObject","textContent","nodeValue","booleanVal","count","nodeSet","id","object","doc","ownerDocument","ids","idNode","idsString","split","apply","getElementById","localName","concat","startsWith","as","bs","contains","indexOf","substringBefore","substring","optEnd","sString","iStart","round","iEnd","stringLength","optString","normalizeSpace","s","replace","translate","from","to","sFrom","sTo","eachCharRe","map","not","bx","trueVal","falseVal","lang","sum","optNodeSet","floor","ceiling","ceil","more","UnaryMinus","nodeTypes","ctx","seenKey","random","helper","outerHTML","nicer","key","message","Evaluator","val","evaluatedParams","functionName","functionParams","ret","contexts","singleNodeSet","success","evaluate","context","code","TYPE_ERR","XPathEvaluator","createExpression","expression","resolver","XPathExpression","createNSResolver","nodeResolver","contextNode","result","optDoc","_ast","_doc","DOMException","WRONG_DOCUMENT_ERR","evaluator","value","XPathResult","NUMBER_TYPE","STRING_TYPE","BOOLEAN_TYPE","ANY_TYPE","UNORDERED_NODE_ITERATOR_TYPE","ORDERED_NODE_ITERATOR_TYPE","UNORDERED_NODE_SNAPSHOT_TYPE","ORDERED_NODE_SNAPSHOT_TYPE","ANY_UNORDERED_NODE_TYPE","FIRST_ORDERED_NODE_TYPE","NOT_SUPPORTED_ERR","resultType","_value","_resultType","_i","proto","numberValue","stringValue","booleanValue","singleNodeValue","invalidIteratorState","_invalidated","snapshotLength","iterateNext","INVALID_STATE_ERR","snapshotItem","index","Object","create","keys","reduce","descriptors","getOwnPropertyDescriptor","writable","configurable","Document"],"sources":["C:/Users/17033/balmco/node_modules/jsdom/lib/jsdom/level3/xpath.js"],"sourcesContent":["/** Here is yet another implementation of XPath 1.0 in Javascript.\n *\n * My goal was to make it relatively compact, but as I fixed all the axis bugs\n * the axes became more and more complicated. :-(.\n *\n * I have not implemented namespaces or case-sensitive axes for XML yet.\n *\n * How to test it in Chrome: You can make a Chrome extension that replaces\n * the WebKit XPath parser with this one. But it takes a bit of effort to\n * get around isolated world and same-origin restrictions:\n * manifest.json:\n    {\n      \"name\": \"XPathTest\",\n      \"version\": \"0.1\",\n      \"content_scripts\": [{\n        \"matches\": [\"http://localhost/*\"],  // or wildcard host\n        \"js\": [\"xpath.js\", \"injection.js\"],\n        \"all_frames\": true, \"run_at\": \"document_start\"\n      }]\n    }\n * injection.js:\n    // goal: give my xpath object to the website's JS context.\n    var script = document.createElement('script');\n    script.textContent =\n        \"document.addEventListener('xpathextend', function(e) {\\n\" +\n        \"  console.log('extending document with xpath...');\\n\" +\n        \"  e.detail(window);\" +\n        \"});\";\n    document.documentElement.appendChild(script);\n    document.documentElement.removeChild(script);\n    var evt = document.createEvent('CustomEvent');\n    evt.initCustomEvent('xpathextend', true, true, this.xpath.extend);\n    document.dispatchEvent(evt);\n */\nmodule.exports = core => {\n  var xpath = {};\n\n  // Helper function to deal with the migration of Attr to no longer have a nodeName property despite this codebase\n  // assuming it does.\n  function getNodeName(nodeOrAttr) {\n    return nodeOrAttr.constructor.name === 'Attr' ? nodeOrAttr.name : nodeOrAttr.nodeName;\n  }\n\n  /***************************************************************************\n   *                            Tokenization                                 *\n   ***************************************************************************/\n  /**\n   * The XPath lexer is basically a single regular expression, along with\n   * some helper functions to pop different types.\n   */\n  var Stream = xpath.Stream = function Stream(str) {\n    this.original = this.str = str;\n    this.peeked = null;\n    // TODO: not really needed, but supposedly tokenizer also disambiguates\n    // a * b vs. node test *\n    this.prev = null;  // for debugging\n    this.prevprev = null;\n  }\n  Stream.prototype = {\n    peek: function() {\n      if (this.peeked) return this.peeked;\n      var m = this.re.exec(this.str);\n      if (!m) return null;\n      this.str = this.str.substr(m[0].length);\n      return this.peeked = m[1];\n    },\n    /** Peek 2 tokens ahead. */\n    peek2: function() {\n      this.peek();  // make sure this.peeked is set\n      var m = this.re.exec(this.str);\n      if (!m) return null;\n      return m[1];\n    },\n    pop: function() {\n      var r = this.peek();\n      this.peeked = null;\n      this.prevprev = this.prev;\n      this.prev = r;\n      return r;\n    },\n    trypop: function(tokens) {\n      var tok = this.peek();\n      if (tok === tokens) return this.pop();\n      if (Array.isArray(tokens)) {\n        for (var i = 0; i < tokens.length; ++i) {\n          var t = tokens[i];\n          if (t == tok) return this.pop();;\n        }\n      }\n    },\n    trypopfuncname: function() {\n      var tok = this.peek();\n      if (!this.isQnameRe.test(tok))\n        return null;\n      switch (tok) {\n        case 'comment': case 'text': case 'processing-instruction': case 'node':\n          return null;\n      }\n      if ('(' != this.peek2()) return null;\n      return this.pop();\n    },\n    trypopaxisname: function() {\n      var tok = this.peek();\n      switch (tok) {\n        case 'ancestor': case 'ancestor-or-self': case 'attribute':\n        case 'child': case 'descendant': case 'descendant-or-self':\n        case 'following': case 'following-sibling': case 'namespace':\n        case 'parent': case 'preceding': case 'preceding-sibling': case 'self':\n          if ('::' == this.peek2()) return this.pop();\n      }\n      return null;\n    },\n    trypopnametest: function() {\n      var tok = this.peek();\n      if ('*' === tok || this.startsWithNcNameRe.test(tok)) return this.pop();\n      return null;\n    },\n    trypopliteral: function() {\n      var tok = this.peek();\n      if (null == tok) return null;\n      var first = tok.charAt(0);\n      var last = tok.charAt(tok.length - 1);\n      if ('\"' === first && '\"' === last ||\n          \"'\" === first && \"'\" === last) {\n        this.pop();\n        return tok.substr(1, tok.length - 2);\n      }\n    },\n    trypopnumber: function() {\n      var tok = this.peek();\n      if (this.isNumberRe.test(tok)) return parseFloat(this.pop());\n      else return null;\n    },\n    trypopvarref: function() {\n      var tok = this.peek();\n      if (null == tok) return null;\n      if ('$' === tok.charAt(0)) return this.pop().substr(1);\n      else return null;\n    },\n    position: function() {\n      return this.original.length - this.str.length;\n    }\n  };\n  (function() {\n    // http://www.w3.org/TR/REC-xml-names/#NT-NCName\n    var nameStartCharsExceptColon =\n        'A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xF8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF' +\n        '\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF' +\n        '\\uFDF0-\\uFFFD';  // JS doesn't support [#x10000-#xEFFFF]\n    var nameCharExceptColon = nameStartCharsExceptColon +\n        '\\\\-\\\\.0-9\\xb7\\u0300-\\u036F\\u203F-\\u2040';\n    var ncNameChars = '[' + nameStartCharsExceptColon +\n        '][' + nameCharExceptColon + ']*'\n    // http://www.w3.org/TR/REC-xml-names/#NT-QName\n    var qNameChars = ncNameChars + '(?::' + ncNameChars + ')?';\n    var otherChars = '\\\\.\\\\.|[\\\\(\\\\)\\\\[\\\\].@,]|::';  // .. must come before [.]\n    var operatorChars =\n        'and|or|mod|div|' +\n        '//|!=|<=|>=|[*/|+\\\\-=<>]';  // //, !=, <=, >= before individual ones.\n    var literal = '\"[^\"]*\"|' + \"'[^']*'\";\n    var numberChars = '[0-9]+(?:\\\\.[0-9]*)?|\\\\.[0-9]+';\n    var variableReference = '\\\\$' + qNameChars;\n    var nameTestChars = '\\\\*|' + ncNameChars + ':\\\\*|' + qNameChars;\n    var optionalSpace = '[ \\t\\r\\n]*';  // stricter than regexp \\s.\n    var nodeType = 'comment|text|processing-instruction|node';\n    var re = new RegExp(\n        // numberChars before otherChars so that leading-decimal doesn't become .\n        '^' + optionalSpace + '(' + numberChars + '|' + otherChars + '|' +\n        nameTestChars + '|' + operatorChars + '|' + literal + '|' +\n        variableReference + ')'\n        // operatorName | nodeType | functionName | axisName are lumped into\n        // qName for now; we'll check them on pop.\n    );\n    Stream.prototype.re = re;\n    Stream.prototype.startsWithNcNameRe = new RegExp('^' + ncNameChars);\n    Stream.prototype.isQnameRe = new RegExp('^' + qNameChars + '$');\n    Stream.prototype.isNumberRe = new RegExp('^' + numberChars + '$');\n  })();\n\n  /***************************************************************************\n   *                               Parsing                                   *\n   ***************************************************************************/\n  var parse = xpath.parse = function parse(stream, a) {\n    var r = orExpr(stream,a);\n    var x, unparsed = [];\n    while (x = stream.pop()) {\n      unparsed.push(x);\n    }\n    if (unparsed.length)\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Position ' + stream.position() +\n                               ': Unparsed tokens: ' + unparsed.join(' '));\n    return r;\n  }\n\n  /**\n   * binaryL  ::= subExpr\n   *            | binaryL op subExpr\n   * so a op b op c becomes ((a op b) op c)\n   */\n  function binaryL(subExpr, stream, a, ops) {\n    var lhs = subExpr(stream, a);\n    if (lhs == null) return null;\n    var op;\n    while (op = stream.trypop(ops)) {\n      var rhs = subExpr(stream, a);\n      if (rhs == null)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected something after ' + op);\n      lhs = a.node(op, lhs, rhs);\n    }\n    return lhs;\n  }\n  /**\n   * Too bad this is never used. If they made a ** operator (raise to power),\n   ( we would use it.\n   * binaryR  ::= subExpr\n   *            | subExpr op binaryR\n   * so a op b op c becomes (a op (b op c))\n   */\n  function binaryR(subExpr, stream, a, ops) {\n    var lhs = subExpr(stream, a);\n    if (lhs == null) return null;\n    var op = stream.trypop(ops);\n    if (op) {\n      var rhs = binaryR(stream, a);\n      if (rhs == null)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected something after ' + op);\n      return a.node(op, lhs, rhs);\n    } else {\n      return lhs;// TODO\n    }\n  }\n  /** [1] LocationPath::= RelativeLocationPath | AbsoluteLocationPath\n   * e.g. a, a/b, //a/b\n   */\n  function locationPath(stream, a) {\n    return absoluteLocationPath(stream, a) ||\n           relativeLocationPath(null, stream, a);\n  }\n  /** [2] AbsoluteLocationPath::= '/' RelativeLocationPath? | AbbreviatedAbsoluteLocationPath\n   *  [10] AbbreviatedAbsoluteLocationPath::= '//' RelativeLocationPath\n   */\n  function absoluteLocationPath(stream, a) {\n    var op = stream.peek();\n    if ('/' === op || '//' === op) {\n      var lhs = a.node('Root');\n      return relativeLocationPath(lhs, stream, a, true);\n    } else {\n      return null;\n    }\n  }\n  /** [3] RelativeLocationPath::= Step | RelativeLocationPath '/' Step |\n   *                            | AbbreviatedRelativeLocationPath\n   *  [11] AbbreviatedRelativeLocationPath::= RelativeLocationPath '//' Step\n   * e.g. p/a, etc.\n   */\n  function relativeLocationPath(lhs, stream, a, isOnlyRootOk) {\n    if (null == lhs) {\n      lhs = step(stream, a);\n      if (null == lhs) return lhs;\n    }\n    var op;\n    while (op = stream.trypop(['/', '//'])) {\n      if ('//' === op) {\n        lhs = a.node('/', lhs,\n                     a.node('Axis', 'descendant-or-self', 'node', undefined));\n      }\n      var rhs = step(stream, a);\n      if (null == rhs && '/' === op && isOnlyRootOk) return lhs;\n      else isOnlyRootOk = false;\n      if (null == rhs)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected step after ' + op);\n      lhs = a.node('/', lhs, rhs);\n    }\n    return lhs;\n  }\n  /** [4] Step::= AxisSpecifier NodeTest Predicate* | AbbreviatedStep\n   *  [12] AbbreviatedStep::= '.' | '..'\n   * e.g. @href, self::p, p, a[@href], ., ..\n   */\n  function step(stream, a) {\n    var abbrStep = stream.trypop(['.', '..']);\n    if ('.' === abbrStep)  // A location step of . is short for self::node().\n      return a.node('Axis', 'self', 'node');\n    if ('..' === abbrStep)  // A location step of .. is short for parent::node()\n      return a.node('Axis', 'parent', 'node');\n\n    var axis = axisSpecifier(stream, a);\n    var nodeType = nodeTypeTest(stream, a);\n    var nodeName;\n    if (null == nodeType) nodeName = nodeNameTest(stream, a);\n    if (null == axis && null == nodeType && null == nodeName) return null;\n    if (null == nodeType && null == nodeName)\n        throw new XPathException(\n            XPathException.INVALID_EXPRESSION_ERR,\n            'Position ' + stream.position() +\n            ': Expected nodeTest after axisSpecifier ' + axis);\n    if (null == axis) axis = 'child';\n    if (null == nodeType) {\n      // When there's only a node name, then the node type is forced to be the\n      // principal node type of the axis.\n      // see http://www.w3.org/TR/xpath/#dt-principal-node-type\n      if ('attribute' === axis) nodeType = 'attribute';\n      else if ('namespace' === axis) nodeType = 'namespace';\n      else nodeType = 'element';\n    }\n    var lhs = a.node('Axis', axis, nodeType, nodeName);\n    var pred;\n    while (null != (pred = predicate(lhs, stream, a))) {\n      lhs = pred;\n    }\n    return lhs;\n  }\n  /** [5] AxisSpecifier::= AxisName '::' | AbbreviatedAxisSpecifier\n   *  [6] AxisName::= 'ancestor' | 'ancestor-or-self' | 'attribute' | 'child'\n   *                | 'descendant' | 'descendant-or-self' | 'following'\n   *                | 'following-sibling' | 'namespace' | 'parent' |\n   *                | 'preceding' | 'preceding-sibling' | 'self'\n   *  [13] AbbreviatedAxisSpecifier::= '@'?\n   */\n  function axisSpecifier(stream, a) {\n    var attr = stream.trypop('@');\n    if (null != attr) return 'attribute';\n    var axisName = stream.trypopaxisname();\n    if (null != axisName) {\n      var coloncolon = stream.trypop('::');\n      if (null == coloncolon)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Should not happen. Should be ::.');\n      return axisName;\n    }\n  }\n  /** [7] NodeTest::= NameTest | NodeType '(' ')' | 'processing-instruction' '(' Literal ')'\n   *  [38] NodeType::= 'comment' | 'text' | 'processing-instruction' | 'node'\n   * I've split nodeTypeTest from nodeNameTest for convenience.\n   */\n  function nodeTypeTest(stream, a) {\n    if ('(' !== stream.peek2()) {\n      return null;\n    }\n    var type = stream.trypop(['comment', 'text', 'processing-instruction', 'node']);\n    if (null != type) {\n      if (null == stream.trypop('('))\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Should not happen.');\n      var param = undefined;\n      if (type == 'processing-instruction') {\n        param = stream.trypopliteral();\n      }\n      if (null == stream.trypop(')'))\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected close parens.');\n      return type\n    }\n  }\n  function nodeNameTest(stream, a) {\n    var name = stream.trypopnametest();\n    if (name != null) return name;\n    else return null;\n  }\n  /** [8] Predicate::= '[' PredicateExpr ']'\n   *  [9] PredicateExpr::= Expr\n   */\n  function predicate(lhs, stream, a) {\n    if (null == stream.trypop('[')) return null;\n    var expr = orExpr(stream, a);\n    if (null == expr)\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Position ' + stream.position() +\n                               ': Expected expression after [');\n    if (null == stream.trypop(']'))\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Position ' + stream.position() +\n                               ': Expected ] after expression.');\n    return a.node('Predicate', lhs, expr);\n  }\n  /** [14] Expr::= OrExpr\n   */\n  /** [15] PrimaryExpr::= VariableReference | '(' Expr ')' | Literal | Number | FunctionCall\n   * e.g. $x,  (3+4),  \"hi\",  32,  f(x)\n   */\n  function primaryExpr(stream, a) {\n    var x = stream.trypopliteral();\n    if (null == x)\n      x = stream.trypopnumber();\n    if (null != x) {\n      return x;\n    }\n    var varRef = stream.trypopvarref();\n    if (null != varRef) return a.node('VariableReference', varRef);\n    var funCall = functionCall(stream, a);\n    if (null != funCall) {\n      return funCall;\n    }\n    if (stream.trypop('(')) {\n      var e = orExpr(stream, a);\n      if (null == e)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected expression after (.');\n      if (null == stream.trypop(')'))\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected ) after expression.');\n      return e;\n    }\n    return null;\n  }\n  /** [16] FunctionCall::= FunctionName '(' ( Argument ( ',' Argument )* )? ')'\n   *  [17] Argument::= Expr\n   */\n  function functionCall(stream, a) {\n    var name = stream.trypopfuncname(stream, a);\n    if (null == name) return null;\n    if (null == stream.trypop('('))\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Position ' + stream.position() +\n                               ': Expected ( ) after function name.');\n    var params = [];\n    var first = true;\n    while (null == stream.trypop(')')) {\n      if (!first && null == stream.trypop(','))\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected , between arguments of the function.');\n      first = false;\n      var param = orExpr(stream, a);\n      if (param == null)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected expression as argument of function.');\n      params.push(param);\n    }\n    return a.node('FunctionCall', name, params);\n  }\n\n  /** [18] UnionExpr::= PathExpr | UnionExpr '|' PathExpr\n   */\n  function unionExpr(stream, a) { return binaryL(pathExpr, stream, a, '|'); }\n  /** [19] PathExpr ::= LocationPath\n   *                  | FilterExpr\n   *                  | FilterExpr '/' RelativeLocationPath\n   *                  | FilterExpr '//' RelativeLocationPath\n   * Unlike most other nodes, this one always generates a node because\n   * at this point all reverse nodesets must turn into a forward nodeset\n   */\n  function pathExpr(stream, a) {\n    // We have to do FilterExpr before LocationPath because otherwise\n    // LocationPath will eat up the name from a function call.\n    var filter = filterExpr(stream, a);\n    if (null == filter) {\n      var loc = locationPath(stream, a);\n      if (null == loc) {\n        throw new Error\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': The expression shouldn\\'t be empty...');\n      }\n      return a.node('PathExpr', loc);\n    }\n    var rel = relativeLocationPath(filter, stream, a, false);\n    if (filter === rel) return rel;\n    else return a.node('PathExpr', rel);\n  }\n  /** [20] FilterExpr::= PrimaryExpr | FilterExpr Predicate\n   * aka. FilterExpr ::= PrimaryExpr Predicate*\n   */\n  function filterExpr(stream, a) {\n    var primary = primaryExpr(stream, a);\n    if (primary == null) return null;\n    var pred, lhs = primary;\n    while (null != (pred = predicate(lhs, stream, a))) {\n      lhs = pred;\n    }\n    return lhs;\n  }\n\n  /** [21] OrExpr::= AndExpr | OrExpr 'or' AndExpr\n   */\n  function orExpr(stream, a) {\n    var orig = (stream.peeked || '') + stream.str\n    var r = binaryL(andExpr, stream, a, 'or');\n    var now = (stream.peeked || '') + stream.str;\n    return r;\n  }\n  /** [22] AndExpr::= EqualityExpr | AndExpr 'and' EqualityExpr\n   */\n  function andExpr(stream, a) { return binaryL(equalityExpr, stream, a, 'and'); }\n  /** [23] EqualityExpr::= RelationalExpr | EqualityExpr '=' RelationalExpr\n   *                     | EqualityExpr '!=' RelationalExpr\n   */\n  function equalityExpr(stream, a) { return binaryL(relationalExpr, stream, a, ['=','!=']); }\n  /** [24] RelationalExpr::= AdditiveExpr | RelationalExpr '<' AdditiveExpr\n   *                       | RelationalExpr '>' AdditiveExpr\n   *                       | RelationalExpr '<=' AdditiveExpr\n   *                       | RelationalExpr '>=' AdditiveExpr\n   */\n  function relationalExpr(stream, a) { return binaryL(additiveExpr, stream, a, ['<','>','<=','>=']); }\n  /** [25] AdditiveExpr::= MultiplicativeExpr\n   *                     | AdditiveExpr '+' MultiplicativeExpr\n   *                     | AdditiveExpr '-' MultiplicativeExpr\n   */\n  function additiveExpr(stream, a) { return binaryL(multiplicativeExpr, stream, a, ['+','-']); }\n  /** [26] MultiplicativeExpr::= UnaryExpr\n   *                           | MultiplicativeExpr MultiplyOperator UnaryExpr\n   *                           | MultiplicativeExpr 'div' UnaryExpr\n   *                           | MultiplicativeExpr 'mod' UnaryExpr\n   */\n  function multiplicativeExpr(stream, a) { return binaryL(unaryExpr, stream, a, ['*','div','mod']); }\n  /** [27] UnaryExpr::= UnionExpr | '-' UnaryExpr\n   */\n  function unaryExpr(stream, a) {\n    if (stream.trypop('-')) {\n      var e = unaryExpr(stream, a);\n      if (null == e)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Expected unary expression after -');\n      return a.node('UnaryMinus', e);\n    }\n    else return unionExpr(stream, a);\n  }\n  var astFactory = {\n    node: function() {return Array.prototype.slice.call(arguments);}\n  };\n\n\n  /***************************************************************************\n   *                            Optimizations (TODO)                         *\n   ***************************************************************************/\n  /**\n   * Some things I've been considering:\n   * 1) a//b becomes a/descendant::b if there's no predicate that uses\n   *    position() or last()\n   * 2) axis[pred]: when pred doesn't use position, evaluate it just once per\n   *    node in the node-set rather than once per (node, position, last).\n   * For more optimizations, look up Gecko's optimizer:\n   * http://mxr.mozilla.org/mozilla-central/source/content/xslt/src/xpath/txXPathOptimizer.cpp\n   */\n  // TODO\n  function optimize(ast) {\n  }\n\n  /***************************************************************************\n   *                           Evaluation: axes                              *\n   ***************************************************************************/\n\n  /**\n   * Data types: For string, number, boolean, we just use Javascript types.\n   * Node-sets have the form\n   *    {nodes: [node, ...]}\n   * or {nodes: [node, ...], pos: [[1], [2], ...], lasts: [[1], [2], ...]}\n   *\n   * Most of the time, only the node is used and the position information is\n   * discarded. But if you use a predicate, we need to try every value of\n   * position and last in case the predicate calls position() or last().\n   */\n\n  /**\n   * The NodeMultiSet is a helper class to help generate\n   * {nodes:[], pos:[], lasts:[]} structures. It is useful for the\n   * descendant, descendant-or-self, following-sibling, and\n   * preceding-sibling axes for which we can use a stack to organize things.\n   */\n  function NodeMultiSet(isReverseAxis) {\n    this.nodes = [];\n    this.pos = [];\n    this.lasts = [];\n    this.nextPos = [];\n    this.seriesIndexes = [];  // index within nodes that each series begins.\n    this.isReverseAxis = isReverseAxis;\n    this._pushToNodes = isReverseAxis ? Array.prototype.unshift : Array.prototype.push;\n  }\n  NodeMultiSet.prototype = {\n    pushSeries: function pushSeries() {\n      this.nextPos.push(1);\n      this.seriesIndexes.push(this.nodes.length);\n    },\n    popSeries: function popSeries() {\n      console.assert(0 < this.nextPos.length, this.nextPos);\n      var last = this.nextPos.pop() - 1,\n          indexInPos = this.nextPos.length,\n          seriesBeginIndex = this.seriesIndexes.pop(),\n          seriesEndIndex = this.nodes.length;\n      for (var i = seriesBeginIndex; i < seriesEndIndex; ++i) {\n        console.assert(indexInPos < this.lasts[i].length);\n        console.assert(undefined === this.lasts[i][indexInPos]);\n        this.lasts[i][indexInPos] = last;\n      }\n    },\n    finalize: function() {\n      if (null == this.nextPos) return this;\n      console.assert(0 === this.nextPos.length);\n      var lastsJSON = JSON.stringify(this.lasts);\n      for (var i = 0; i < this.lasts.length; ++i) {\n        for (var j = 0; j < this.lasts[i].length; ++j) {\n          console.assert(null != this.lasts[i][j], i + ',' + j + ':' + lastsJSON);\n        }\n      }\n      this.pushSeries = this.popSeries = this.addNode = function() {\n        throw new Error('Already finalized.');\n      };\n      return this;\n    },\n    addNode: function addNode(node) {\n      console.assert(node);\n      this._pushToNodes.call(this.nodes, node)\n      this._pushToNodes.call(this.pos, this.nextPos.slice());\n      this._pushToNodes.call(this.lasts, new Array(this.nextPos.length));\n      for (var i = 0; i < this.nextPos.length; ++i) this.nextPos[i]++;\n    },\n    simplify: function() {\n      this.finalize();\n      return {nodes:this.nodes, pos:this.pos, lasts:this.lasts};\n    }\n  };\n  function eachContext(nodeMultiSet) {\n    var r = [];\n    for (var i = 0; i < nodeMultiSet.nodes.length; i++) {\n      var node = nodeMultiSet.nodes[i];\n      if (!nodeMultiSet.pos) {\n        r.push({nodes:[node], pos: [[i + 1]], lasts: [[nodeMultiSet.nodes.length]]});\n      } else {\n        for (var j = 0; j < nodeMultiSet.pos[i].length; ++j) {\n          r.push({nodes:[node], pos: [[nodeMultiSet.pos[i][j]]], lasts: [[nodeMultiSet.lasts[i][j]]]});\n        }\n      }\n    }\n    return r;\n  }\n  /** Matcher used in the axes.\n   */\n  function NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase) {\n    this.nodeTypeNum = nodeTypeNum;\n    this.nodeName = nodeName;\n    this.shouldLowerCase = shouldLowerCase;\n    this.nodeNameTest =\n      null == nodeName ? this._alwaysTrue :\n      shouldLowerCase ? this._nodeNameLowerCaseEquals :\n      this._nodeNameEquals;\n  }\n  NodeMatcher.prototype = {\n    matches: function matches(node) {\n      if (0 === this.nodeTypeNum || this._nodeTypeMatches(node)) {\n        return this.nodeNameTest(getNodeName(node));\n      }\n\n      return false;\n    },\n    _nodeTypeMatches(nodeOrAttr) {\n      if (nodeOrAttr.constructor.name === 'Attr' && this.nodeTypeNum === 2) {\n        return true;\n      }\n      return nodeOrAttr.nodeType === this.nodeTypeNum;\n    },\n    _alwaysTrue: function(name) {return true;},\n    _nodeNameEquals: function _nodeNameEquals(name) {\n      return this.nodeName === name;\n    },\n    _nodeNameLowerCaseEquals: function _nodeNameLowerCaseEquals(name) {\n      return this.nodeName === name.toLowerCase();\n    }\n  };\n\n  function followingSiblingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, shift, peek, followingNode, andSelf, isReverseAxis) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var nodeMultiSet = new NodeMultiSet(isReverseAxis);\n    while (0 < nodeList.length) {  // can be if for following, preceding\n      var node = shift.call(nodeList);\n      console.assert(node != null);\n      node = followingNode(node);\n      nodeMultiSet.pushSeries();\n      var numPushed = 1;\n      while (null != node) {\n        if (! andSelf && matcher.matches(node))\n          nodeMultiSet.addNode(node);\n        if (node === peek.call(nodeList)) {\n          shift.call(nodeList);\n          nodeMultiSet.pushSeries();\n          numPushed++;\n        }\n        if (andSelf && matcher.matches(node))\n          nodeMultiSet.addNode(node);\n        node = followingNode(node);\n      }\n      while (0 < numPushed--)\n        nodeMultiSet.popSeries();\n    }\n    return nodeMultiSet;\n  }\n\n  /** Returns the next non-descendant node in document order.\n   * This is the first node in following::node(), if node is the context.\n   */\n  function followingNonDescendantNode(node) {\n    if (node.ownerElement) {\n      if (node.ownerElement.firstChild)\n        return node.ownerElement.firstChild;\n      node = node.ownerElement;\n    }\n    do {\n      if (node.nextSibling) return node.nextSibling;\n    } while (node = node.parentNode);\n    return null;\n  }\n\n  /** Returns the next node in a document-order depth-first search.\n   * See the definition of document order[1]:\n   *   1) element\n   *   2) namespace nodes\n   *   3) attributes\n   *   4) children\n   *   [1]: http://www.w3.org/TR/xpath/#dt-document-order\n   */\n  function followingNode(node) {\n    if (node.ownerElement)  // attributes: following node of element.\n      node = node.ownerElement;\n    if (null != node.firstChild)\n      return node.firstChild;\n    do {\n      if (null != node.nextSibling) {\n        return node.nextSibling;\n      }\n      node = node.parentNode;\n    } while (node);\n    return null;\n  }\n  /** Returns the previous node in document order (excluding attributes\n   * and namespace nodes).\n   */\n  function precedingNode(node) {\n    if (node.ownerElement)\n      return node.ownerElement;\n    if (null != node.previousSibling) {\n      node = node.previousSibling;\n      while (null != node.lastChild) {\n        node = node.lastChild;\n      }\n      return node;\n    }\n    if (null != node.parentNode) {\n      return node.parentNode;\n    }\n    return null;\n  }\n  /** This axis is inefficient if there are many nodes in the nodeList.\n   * But I think it's a pretty useless axis so it's ok. */\n  function followingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var nodeMultiSet = new NodeMultiSet(false);\n    var cursor = nodeList[0];\n    var unorderedFollowingStarts = [];\n    for (var i = 0; i < nodeList.length; i++) {\n      var node = nodeList[i];\n      var start = followingNonDescendantNode(node);\n      if (start)\n        unorderedFollowingStarts.push(start);\n    }\n    if (0 === unorderedFollowingStarts.length)\n      return {nodes:[]};\n    var pos = [], nextPos = [];\n    var started = 0;\n    while (cursor = followingNode(cursor)) {\n      for (var i = unorderedFollowingStarts.length - 1; i >= 0; i--){\n        if (cursor === unorderedFollowingStarts[i]) {\n          nodeMultiSet.pushSeries();\n          unorderedFollowingStarts.splice(i,i+1);\n          started++;\n        }\n      }\n      if (started && matcher.matches(cursor)) {\n        nodeMultiSet.addNode(cursor);\n      }\n    }\n    console.assert(0 === unorderedFollowingStarts.length);\n    for (var i = 0; i < started; i++)\n      nodeMultiSet.popSeries();\n    return nodeMultiSet.finalize();\n  }\n  function precedingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var cursor = nodeList.pop();\n    if (null == cursor) return {nodes:{}};\n    var r = {nodes:[], pos:[], lasts:[]};\n    var nextParents = [cursor.parentNode || cursor.ownerElement], nextPos = [1];\n    while (cursor = precedingNode(cursor)) {\n      if (cursor === nodeList[nodeList.length - 1]) {\n        nextParents.push(nodeList.pop());\n        nextPos.push(1);\n      }\n      var matches = matcher.matches(cursor);\n      var pos, someoneUsed = false;\n      if (matches)\n        pos = nextPos.slice();\n\n      for (var i = 0; i < nextParents.length; ++i) {\n        if (cursor === nextParents[i]) {\n          nextParents[i] = cursor.parentNode || cursor.ownerElement;\n          if (matches) {\n            pos[i] = null;\n          }\n        } else {\n          if (matches) {\n            pos[i] = nextPos[i]++;\n            someoneUsed = true;\n          }\n        }\n      }\n      if (someoneUsed) {\n        r.nodes.unshift(cursor);\n        r.pos.unshift(pos);\n      }\n    }\n    for (var i = 0; i < r.pos.length; ++i) {\n      var lasts = [];\n      r.lasts.push(lasts);\n      for (var j = r.pos[i].length - 1; j >= 0; j--) {\n        if (null == r.pos[i][j]) {\n          r.pos[i].splice(j, j+1);\n        } else {\n          lasts.unshift(nextPos[j] - 1);\n        }\n      }\n    }\n    return r;\n  }\n\n  /** node-set, axis -> node-set */\n  function descendantDfs(nodeMultiSet, node, remaining, matcher, andSelf, attrIndices, attrNodes) {\n    while (0 < remaining.length && null != remaining[0].ownerElement) {\n      var attr = remaining.shift();\n      if (andSelf && matcher.matches(attr)) {\n        attrNodes.push(attr);\n        attrIndices.push(nodeMultiSet.nodes.length);\n      }\n    }\n    if (null != node && !andSelf) {\n      if (matcher.matches(node))\n        nodeMultiSet.addNode(node);\n    }\n    var pushed = false;\n    if (null == node) {\n      if (0 === remaining.length) return;\n      node = remaining.shift();\n      nodeMultiSet.pushSeries();\n      pushed = true;\n    } else if (0 < remaining.length && node === remaining[0]) {\n      nodeMultiSet.pushSeries();\n      pushed = true;\n      remaining.shift();\n    }\n    if (andSelf) {\n      if (matcher.matches(node))\n        nodeMultiSet.addNode(node);\n    }\n    // TODO: use optimization. Also try element.getElementsByTagName\n    // var nodeList = 1 === nodeTypeNum && null != node.children ? node.children : node.childNodes;\n    var nodeList = node.childNodes;\n    for (var j = 0; j < nodeList.length; ++j) {\n      var child = nodeList[j];\n      descendantDfs(nodeMultiSet, child, remaining, matcher, andSelf, attrIndices, attrNodes);\n    }\n    if (pushed) {\n      nodeMultiSet.popSeries();\n    }\n  }\n  function descenantHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, andSelf) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var nodeMultiSet = new NodeMultiSet(false);\n    var attrIndices = [], attrNodes = [];\n    while (0 < nodeList.length) {\n      // var node = nodeList.shift();\n      descendantDfs(nodeMultiSet, null, nodeList, matcher, andSelf, attrIndices, attrNodes);\n    }\n    nodeMultiSet.finalize();\n    for (var i = attrNodes.length-1; i >= 0; --i) {\n      nodeMultiSet.nodes.splice(attrIndices[i], attrIndices[i], attrNodes[i]);\n      nodeMultiSet.pos.splice(attrIndices[i], attrIndices[i], [1]);\n      nodeMultiSet.lasts.splice(attrIndices[i], attrIndices[i], [1]);\n    }\n    return nodeMultiSet;\n  }\n  /**\n   */\n  function ancestorHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, andSelf) {\n    var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n    var ancestors = []; // array of non-empty arrays of matching ancestors\n    for (var i = 0; i < nodeList.length; ++i) {\n      var node = nodeList[i];\n      var isFirst = true;\n      var a = [];\n      while (null != node) {\n        if (!isFirst || andSelf) {\n          if (matcher.matches(node))\n            a.push(node);\n        }\n        isFirst = false;\n        node = node.parentNode || node.ownerElement;\n      }\n      if (0 < a.length)\n        ancestors.push(a);\n    }\n    var lasts = [];\n    for (var i = 0; i < ancestors.length; ++i) lasts.push(ancestors[i].length);\n    var nodeMultiSet = new NodeMultiSet(true);\n    var newCtx = {nodes:[], pos:[], lasts:[]};\n    while (0 < ancestors.length) {\n      var pos = [ancestors[0].length];\n      var last = [lasts[0]];\n      var node = ancestors[0].pop();\n      for (var i = ancestors.length - 1; i > 0; --i) {\n        if (node === ancestors[i][ancestors[i].length - 1]) {\n          pos.push(ancestors[i].length);\n          last.push(lasts[i]);\n          ancestors[i].pop();\n          if (0 === ancestors[i].length) {\n            ancestors.splice(i, i+1);\n            lasts.splice(i, i+1);\n          }\n        }\n      }\n      if (0 === ancestors[0].length) {\n        ancestors.shift();\n        lasts.shift();\n      }\n      newCtx.nodes.push(node);\n      newCtx.pos.push(pos);\n      newCtx.lasts.push(last);\n    }\n    return newCtx;\n  }\n  /** Helper function for sortDocumentOrder. Returns a list of indices, from the\n   * node to the root, of positions within parent.\n   * For convenience, the node is the first element of the array.\n   */\n  function addressVector(node) {\n    var r = [node];\n    if (null != node.ownerElement) {\n      node = node.ownerElement;\n      r.push(-1);\n    }\n    while (null != node) {\n      var i = 0;\n      while (null != node.previousSibling) {\n        node = node.previousSibling;\n        i++;\n      }\n      r.push(i);\n      node = node.parentNode\n    }\n    return r;\n  }\n  function addressComparator(a, b) {\n    var minlen = Math.min(a.length - 1, b.length - 1),  // not including [0]=node\n        alen = a.length,\n        blen = b.length;\n    if (a[0] === b[0]) return 0;\n    var c;\n    for (var i = 0; i < minlen; ++i) {\n      c = a[alen - i - 1] - b[blen - i - 1];\n      if (0 !== c)\n        break;\n    }\n    if (null == c || 0 === c) {\n      // All equal until one of the nodes. The longer one is the descendant.\n      c = alen - blen;\n    }\n    if (0 === c)\n      c = getNodeName(a) - getNodeName(b);\n    if (0 === c)\n      c = 1;\n    return c;\n  }\n  var sortUniqDocumentOrder = xpath.sortUniqDocumentOrder = function(nodes) {\n    var a = [];\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i];\n      var v = addressVector(node);\n      a.push(v);\n    }\n    a.sort(addressComparator);\n    var b = [];\n    for (var i = 0; i < a.length; i++) {\n      if (0 < i && a[i][0] === a[i - 1][0])\n        continue;\n      b.push(a[i][0]);\n    }\n    return b;\n  }\n  /** Sort node multiset. Does not do any de-duping. */\n  function sortNodeMultiSet(nodeMultiSet) {\n    var a = [];\n    for (var i = 0; i < nodeMultiSet.nodes.length; i++) {\n      var v = addressVector(nodeMultiSet.nodes[i]);\n      a.push({v:v, n:nodeMultiSet.nodes[i],\n              p:nodeMultiSet.pos[i], l:nodeMultiSet.lasts[i]});\n    }\n    a.sort(compare);\n    var r = {nodes:[], pos:[], lasts:[]};\n    for (var i = 0; i < a.length; ++i) {\n      r.nodes.push(a[i].n);\n      r.pos.push(a[i].p);\n      r.lasts.push(a[i].l);\n    }\n    function compare(x, y) {\n      return addressComparator(x.v, y.v);\n    }\n    return r;\n  }\n  /** Returns an array containing all the ancestors down to a node.\n   * The array starts with document.\n   */\n  function nodeAndAncestors(node) {\n    var ancestors = [node];\n    var p = node;\n    while (p = p.parentNode || p.ownerElement) {\n      ancestors.unshift(p);\n    }\n    return ancestors;\n  }\n  function compareSiblings(a, b) {\n    if (a === b) return 0;\n    var c = a;\n    while (c = c.previousSibling) {\n      if (c === b)\n        return 1;  // b < a\n    }\n    c = b;\n    while (c = c.previousSibling) {\n      if (c === a)\n        return -1;  // a < b\n    }\n    throw new Error('a and b are not siblings: ' + xpath.stringifyObject(a) + ' vs ' + xpath.stringifyObject(b));\n  }\n  /** The merge in merge-sort.*/\n  function mergeNodeLists(x, y) {\n    var a, b, aanc, banc, r = [];\n    if ('object' !== typeof x)\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Invalid LHS for | operator ' +\n                               '(expected node-set): ' + x);\n    if ('object' !== typeof y)\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                               'Invalid LHS for | operator ' +\n                               '(expected node-set): ' + y);\n    while (true) {\n      if (null == a) {\n        a = x.shift();\n        if (null != a)\n          aanc = addressVector(a);\n      }\n      if (null == b) {\n        b = y.shift();\n        if (null != b)\n          banc = addressVector(b);\n      }\n      if (null == a || null == b) break;\n      var c = addressComparator(aanc, banc);\n      if (c < 0) {\n        r.push(a);\n        a = null;\n        aanc = null;\n      } else if (c > 0) {\n        r.push(b);\n        b = null;\n        banc = null;\n      } else if (getNodeName(a) < getNodeName(b)) {  // attributes\n        r.push(a);\n        a = null;\n        aanc = null;\n      } else if (getNodeName(a) > getNodeName(b)) {  // attributes\n        r.push(b);\n        b = null;\n        banc = null;\n      } else if (a !== b) {\n        // choose b arbitrarily\n        r.push(b);\n        b = null;\n        banc = null;\n      } else {\n        console.assert(a === b, c);\n        // just skip b without pushing it.\n        b = null;\n        banc = null;\n      }\n    }\n    while (a) {\n      r.push(a);\n      a = x.shift();\n    }\n    while (b) {\n      r.push(b);\n      b = y.shift();\n    }\n    return r;\n  }\n  function comparisonHelper(test, x, y, isNumericComparison) {\n    var coersion;\n    if (isNumericComparison)\n      coersion = fn.number;\n    else coersion =\n      'boolean' === typeof x || 'boolean' === typeof y ? fn['boolean'] :\n      'number' === typeof x || 'number' === typeof y ? fn.number :\n      fn.string;\n    if ('object' === typeof x && 'object' === typeof y) {\n      var aMap = {};\n      for (var i = 0; i < x.nodes.length; ++i) {\n        var xi = coersion({nodes:[x.nodes[i]]});\n        for (var j = 0; j < y.nodes.length; ++j) {\n          var yj = coersion({nodes:[y.nodes[j]]});\n          if (test(xi, yj)) return true;\n        }\n      }\n      return false;\n    } else if ('object' === typeof x && x.nodes && x.nodes.length) {\n      for (var i = 0; i < x.nodes.length; ++i) {\n        var xi = coersion({nodes:[x.nodes[i]]}), yc = coersion(y);\n        if (test(xi, yc))\n          return true;\n      }\n      return false;\n    } else if ('object' === typeof y && x.nodes && x.nodes.length) {\n      for (var i = 0; i < x.nodes.length; ++i) {\n        var yi = coersion({nodes:[y.nodes[i]]}), xc = coersion(x);\n        if (test(xc, yi))\n          return true;\n      }\n      return false;\n    } else {\n      var xc = coersion(x), yc = coersion(y);\n      return test(xc, yc);\n    }\n  }\n  var axes = xpath.axes = {\n    'ancestor':\n      function ancestor(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return ancestorHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, false);\n      },\n    'ancestor-or-self':\n      function ancestorOrSelf(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return ancestorHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, true);\n      },\n    'attribute':\n      function attribute(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        // TODO: figure out whether positions should be undefined here.\n        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n        var nodeMultiSet = new NodeMultiSet(false);\n        if (null != nodeName) {\n          // TODO: with namespace\n          for (var i = 0; i < nodeList.length; ++i) {\n            var node = nodeList[i];\n            if (null == node.getAttributeNode)\n              continue;  // only Element has .getAttributeNode\n            var attr = node.getAttributeNode(nodeName);\n            if (null != attr && matcher.matches(attr)) {\n              nodeMultiSet.pushSeries();\n              nodeMultiSet.addNode(attr);\n              nodeMultiSet.popSeries();\n            }\n          }\n        } else {\n          for (var i = 0; i < nodeList.length; ++i) {\n            var node = nodeList[i];\n            if (null != node.attributes) {\n              nodeMultiSet.pushSeries();\n              for (var j = 0; j < node.attributes.length; j++) {  // all nodes have .attributes\n                var attr = node.attributes[j];\n                if (matcher.matches(attr))  // TODO: I think this check is unnecessary\n                  nodeMultiSet.addNode(attr);\n              }\n              nodeMultiSet.popSeries();\n            }\n          }\n        }\n        return nodeMultiSet.finalize();\n      },\n    'child':\n      function child(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n        var nodeMultiSet = new NodeMultiSet(false);\n        for (var i = 0; i < nodeList.length; ++i) {\n          var n = nodeList[i];\n          if (n.ownerElement)  // skip attribute nodes' text child.\n            continue;\n          if (n.childNodes) {\n            nodeMultiSet.pushSeries();\n            var childList = 1 === nodeTypeNum && null != n.children ?\n                n.children : n.childNodes;\n            for (var j = 0; j < childList.length; ++j) {\n              var child = childList[j];\n              if (matcher.matches(child)) {\n                nodeMultiSet.addNode(child);\n              }\n              // don't have to do de-duping because children have parent,\n              // which are current context.\n            }\n            nodeMultiSet.popSeries();\n          }\n        }\n        nodeMultiSet.finalize();\n        return sortNodeMultiSet(nodeMultiSet);\n      },\n    'descendant':\n      function descenant(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return descenantHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, false);\n      },\n    'descendant-or-self':\n      function descenantOrSelf(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return descenantHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase, true);\n      },\n    'following':\n      function following(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return followingHelper(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase);\n      },\n    'following-sibling':\n      function followingSibling(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return followingSiblingHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase,\n          Array.prototype.shift, function() {return this[0];},\n          function(node) {return node.nextSibling;});\n      },\n    'namespace':\n      function namespace(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        // TODO\n      },\n    'parent':\n      function parent(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n        var nodes = [], pos = [];\n        for (var i = 0; i < nodeList.length; ++i) {\n          var parent = nodeList[i].parentNode || nodeList[i].ownerElement;\n          if (null == parent)\n            continue;\n          if (!matcher.matches(parent))\n            continue;\n          if (nodes.length > 0 && parent === nodes[nodes.length-1])\n            continue;\n          nodes.push(parent);\n          pos.push([1]);\n        }\n        return {nodes:nodes, pos:pos, lasts:pos};\n      },\n    'preceding':\n      function preceding(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return precedingHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase);\n      },\n    'preceding-sibling':\n      function precedingSibling(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        return followingSiblingHelper(\n          nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase,\n          Array.prototype.pop, function() {return this[this.length-1];},\n          function(node) {return node.previousSibling},\n          false, true);\n      },\n    'self':\n      function self(nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase) {\n        var nodes = [], pos = [];\n        var matcher = new NodeMatcher(nodeTypeNum, nodeName, shouldLowerCase);\n        for (var i = 0; i < nodeList.length; ++i) {\n          if (matcher.matches(nodeList[i])) {\n            nodes.push(nodeList[i]);\n            pos.push([1]);\n          }\n        }\n        return {nodes: nodes, pos: pos, lasts: pos}\n      }\n  };\n\n  /***************************************************************************\n   *                         Evaluation: functions                           *\n   ***************************************************************************/\n  var fn = {\n    'number': function number(optObject) {\n      if ('number' === typeof optObject)\n        return optObject;\n      if ('string' === typeof optObject)\n        return parseFloat(optObject);  // note: parseFloat(' ') -> NaN, unlike +' ' -> 0.\n      if ('boolean' === typeof optObject)\n        return +optObject;\n      return fn.number(fn.string.call(this, optObject));  // for node-sets\n    },\n    'string': function string(optObject) {\n      if (null == optObject)\n        return fn.string(this);\n      if ('string' === typeof optObject || 'boolean' === typeof optObject ||\n          'number' === typeof optObject)\n        return '' + optObject;\n      if (0 == optObject.nodes.length) return '';\n      if (null != optObject.nodes[0].textContent)\n        return optObject.nodes[0].textContent;\n      return optObject.nodes[0].nodeValue;\n    },\n    'boolean': function booleanVal(x) {\n      return 'object' === typeof x ? x.nodes.length > 0 : !!x;\n    },\n    'last': function last() {\n      console.assert(Array.isArray(this.pos));\n      console.assert(Array.isArray(this.lasts));\n      console.assert(1 === this.pos.length);\n      console.assert(1 === this.lasts.length);\n      console.assert(1 === this.lasts[0].length);\n      return this.lasts[0][0];\n    },\n    'position': function position() {\n      console.assert(Array.isArray(this.pos));\n      console.assert(Array.isArray(this.lasts));\n      console.assert(1 === this.pos.length);\n      console.assert(1 === this.lasts.length);\n      console.assert(1 === this.pos[0].length);\n      return this.pos[0][0];\n    },\n    'count': function count(nodeSet) {\n      if ('object' !== typeof nodeSet)\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Position ' + stream.position() +\n                                 ': Function count(node-set) ' +\n                                 'got wrong argument type: ' + nodeSet);\n      return nodeSet.nodes.length;\n    },\n    'id': function id(object) {\n      var r = {nodes: []};\n      var doc = this.nodes[0].ownerDocument || this.nodes[0];\n      console.assert(doc);\n      var ids;\n      if ('object' === typeof object) {\n        // for node-sets, map id over each node value.\n        ids = [];\n        for (var i = 0; i < object.nodes.length; ++i) {\n          var idNode = object.nodes[i];\n          var idsString = fn.string({nodes:[idNode]});\n          var a = idsString.split(/[ \\t\\r\\n]+/g);\n          Array.prototype.push.apply(ids, a);\n        }\n      } else {\n        var idsString = fn.string(object);\n        var a = idsString.split(/[ \\t\\r\\n]+/g);\n        ids = a;\n      }\n      for (var i = 0; i < ids.length; ++i) {\n        var id = ids[i];\n        if (0 === id.length)\n          continue;\n        var node = doc.getElementById(id);\n        if (null != node)\n          r.nodes.push(node);\n      }\n      r.nodes = sortUniqDocumentOrder(r.nodes);\n      return r;\n    },\n    'local-name': function(nodeSet) {\n      if (null == nodeSet)\n        return fn.name(this);\n      if (null == nodeSet.nodes) {\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'argument to name() must be a node-set. got ' + nodeSet);\n      }\n      // TODO: namespaced version\n      return nodeSet.nodes[0].localName;\n    },\n    'namespace-uri': function(nodeSet) {\n      // TODO\n      throw new Error('not implemented yet');\n    },\n    'name': function(nodeSet) {\n      if (null == nodeSet)\n        return fn.name(this);\n      if (null == nodeSet.nodes) {\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'argument to name() must be a node-set. got ' + nodeSet);\n      }\n      return nodeSet.nodes[0].name;\n    },\n    'concat': function concat(x) {\n      var l = [];\n      for (var i = 0; i < arguments.length; ++i) {\n        l.push(fn.string(arguments[i]));\n      }\n      return l.join('');\n    },\n    'starts-with': function startsWith(a, b) {\n      var as = fn.string(a), bs = fn.string(b);\n      return as.substr(0, bs.length) === bs;\n    },\n    'contains': function contains(a, b) {\n      var as = fn.string(a), bs = fn.string(b);\n      var i = as.indexOf(bs);\n      if (-1 === i) return false;\n      return true;\n    },\n    'substring-before': function substringBefore(a, b) {\n      var as = fn.string(a), bs = fn.string(b);\n      var i = as.indexOf(bs);\n      if (-1 === i) return '';\n      return as.substr(0, i);\n    },\n    'substring-after': function substringBefore(a, b) {\n      var as = fn.string(a), bs = fn.string(b);\n      var i = as.indexOf(bs);\n      if (-1 === i) return '';\n      return as.substr(i + bs.length);\n    },\n    'substring': function substring(string, start, optEnd) {\n      if (null == string || null == start) {\n        throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                 'Must be at least 2 arguments to string()');\n      }\n      var sString = fn.string(string),\n          iStart = fn.round(start),\n          iEnd = optEnd == null ? null : fn.round(optEnd);\n      // Note that xpath string positions user 1-based index\n      if (iEnd == null)\n        return sString.substr(iStart - 1);\n      else\n        return sString.substr(iStart - 1, iEnd);\n    },\n    'string-length': function stringLength(optString) {\n      return fn.string.call(this, optString).length;\n    },\n    'normalize-space': function normalizeSpace(optString) {\n      var s = fn.string.call(this, optString);\n      return s.replace(/[ \\t\\r\\n]+/g, ' ').replace(/^ | $/g, '');\n    },\n    'translate': function translate(string, from, to) {\n      var sString = fn.string.call(this, string),\n          sFrom = fn.string(from),\n          sTo = fn.string(to);\n      var eachCharRe = [];\n      var map = {};\n      for (var i = 0; i < sFrom.length; ++i) {\n        var c = sFrom.charAt(i);\n        map[c] = sTo.charAt(i);  // returns '' if beyond length of sTo.\n        // copied from goog.string.regExpEscape in the Closure library.\n        eachCharRe.push(\n          c.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, '\\\\$1').\n            replace(/\\x08/g, '\\\\x08'));\n      }\n      var re = new RegExp(eachCharRe.join('|'), 'g');\n      return sString.replace(re, function(c) {return map[c];});\n    },\n    /// Boolean functions\n    'not': function not(x) {\n      var bx = fn['boolean'](x);\n      return !bx;\n    },\n    'true': function trueVal() { return true; },\n    'false': function falseVal() { return false; },\n    // TODO\n    'lang': function lang(string) { throw new Error('Not implemented');},\n    'sum': function sum(optNodeSet) {\n      if (null == optNodeSet) return fn.sum(this);\n      // for node-sets, map id over each node value.\n      var sum = 0;\n      for (var i = 0; i < optNodeSet.nodes.length; ++i) {\n        var node = optNodeSet.nodes[i];\n        var x = fn.number({nodes:[node]});\n        sum += x;\n      }\n      return sum;\n    },\n    'floor': function floor(number) {\n      return Math.floor(fn.number(number));\n    },\n    'ceiling': function ceiling(number) {\n      return Math.ceil(fn.number(number));\n    },\n    'round': function round(number) {\n      return Math.round(fn.number(number));\n    }\n  };\n  /***************************************************************************\n   *                         Evaluation: operators                           *\n   ***************************************************************************/\n  var more = {\n    UnaryMinus: function(x) { return -fn.number(x); },\n    '+': function(x, y) { return fn.number(x) + fn.number(y); },\n    '-': function(x, y) { return fn.number(x) - fn.number(y); },\n    '*': function(x, y) { return fn.number(x) * fn.number(y); },\n    'div': function(x, y) { return fn.number(x) / fn.number(y); },\n    'mod': function(x, y) { return fn.number(x) % fn.number(y); },\n    '<': function(x, y) {\n      return comparisonHelper(function(x, y) { return fn.number(x) < fn.number(y);}, x, y, true);\n    },\n    '<=': function(x, y) {\n      return comparisonHelper(function(x, y) { return fn.number(x) <= fn.number(y);}, x, y, true);\n    },\n    '>':  function(x, y) {\n      return comparisonHelper(function(x, y) { return fn.number(x) > fn.number(y);}, x, y, true);\n    },\n    '>=': function(x, y) {\n      return comparisonHelper(function(x, y) { return fn.number(x) >= fn.number(y);}, x, y, true);\n    },\n    'and': function(x, y) { return fn['boolean'](x) && fn['boolean'](y); },\n    'or': function(x, y) { return fn['boolean'](x) || fn['boolean'](y); },\n    '|': function(x, y) { return {nodes: mergeNodeLists(x.nodes, y.nodes)}; },\n    '=': function(x, y) {\n      // optimization for two node-sets case: avoid n^2 comparisons.\n      if ('object' === typeof x && 'object' === typeof y) {\n        var aMap = {};\n        for (var i = 0; i < x.nodes.length; ++i) {\n          var s = fn.string({nodes:[x.nodes[i]]});\n          aMap[s] = true;\n        }\n        for (var i = 0; i < y.nodes.length; ++i) {\n          var s = fn.string({nodes:[y.nodes[i]]});\n          if (aMap[s]) return true;\n        }\n        return false;\n      } else {\n        return comparisonHelper(function(x, y) {return x === y;}, x, y);\n      }\n    },\n    '!=': function(x, y) {\n      // optimization for two node-sets case: avoid n^2 comparisons.\n      if ('object' === typeof x && 'object' === typeof y) {\n        if (0 === x.nodes.length || 0 === y.nodes.length) return false;\n        var aMap = {};\n        for (var i = 0; i < x.nodes.length; ++i) {\n          var s = fn.string({nodes:[x.nodes[i]]});\n          aMap[s] = true;\n        }\n        for (var i = 0; i < y.nodes.length; ++i) {\n          var s = fn.string({nodes:[y.nodes[i]]});\n          if (!aMap[s]) return true;\n        }\n        return false;\n      } else {\n        return comparisonHelper(function(x, y) {return x !== y;}, x, y);\n      }\n    }\n  };\n  var nodeTypes = xpath.nodeTypes = {\n    'node': 0,\n    'attribute': 2,\n    'comment': 8, // this.doc.COMMENT_NODE,\n    'text': 3, // this.doc.TEXT_NODE,\n    'processing-instruction': 7, // this.doc.PROCESSING_INSTRUCTION_NODE,\n    'element': 1  //this.doc.ELEMENT_NODE\n  };\n  /** For debugging and unit tests: returnjs a stringified version of the\n   * argument. */\n  var stringifyObject = xpath.stringifyObject = function stringifyObject(ctx) {\n    var seenKey = 'seen' + Math.floor(Math.random()*1000000000);\n    return JSON.stringify(helper(ctx));\n\n    function helper(ctx) {\n      if (Array.isArray(ctx)) {\n        return ctx.map(function(x) {return helper(x);});\n      }\n      if ('object' !== typeof ctx) return ctx;\n      if (null == ctx) return ctx;\n    //  if (ctx.toString) return ctx.toString();\n      if (null != ctx.outerHTML) return ctx.outerHTML;\n      if (null != ctx.nodeValue) return ctx.nodeName + '=' + ctx.nodeValue;\n      if (ctx[seenKey]) return '[circular]';\n      ctx[seenKey] = true;\n      var nicer = {};\n      for (var key in ctx) {\n        if (seenKey === key)\n          continue;\n        try {\n          nicer[key] = helper(ctx[key]);\n        } catch (e) {\n          nicer[key] = '[exception: ' + e.message + ']';\n        }\n      }\n      delete ctx[seenKey];\n      return nicer;\n    }\n  }\n  var Evaluator = xpath.Evaluator = function Evaluator(doc) {\n    this.doc = doc;\n  }\n  Evaluator.prototype = {\n    val: function val(ast, ctx) {\n      console.assert(ctx.nodes);\n\n      if ('number' === typeof ast || 'string' === typeof ast) return ast;\n      if (more[ast[0]]) {\n        var evaluatedParams = [];\n        for (var i = 1; i < ast.length; ++i) {\n          evaluatedParams.push(this.val(ast[i], ctx));\n        }\n        var r = more[ast[0]].apply(ctx, evaluatedParams);\n        return r;\n      }\n      switch (ast[0]) {\n        case 'Root': return {nodes: [this.doc]};\n        case 'FunctionCall':\n          var functionName = ast[1], functionParams = ast[2];\n          if (null == fn[functionName])\n            throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,\n                                     'Unknown function: ' + functionName);\n          var evaluatedParams = [];\n          for (var i = 0; i < functionParams.length; ++i) {\n            evaluatedParams.push(this.val(functionParams[i], ctx));\n          }\n          var r = fn[functionName].apply(ctx, evaluatedParams);\n          return r;\n        case 'Predicate':\n          var lhs = this.val(ast[1], ctx);\n          var ret = {nodes: []};\n          var contexts = eachContext(lhs);\n          for (var i = 0; i < contexts.length; ++i) {\n            var singleNodeSet = contexts[i];\n            var rhs = this.val(ast[2], singleNodeSet);\n            var success;\n            if ('number' === typeof rhs) {\n              success = rhs === singleNodeSet.pos[0][0];\n            } else {\n              success = fn['boolean'](rhs);\n            }\n            if (success) {\n              var node = singleNodeSet.nodes[0];\n              ret.nodes.push(node);\n              // skip over all the rest of the same node.\n              while (i+1 < contexts.length && node === contexts[i+1].nodes[0]) {\n                i++;\n              }\n            }\n          }\n          return ret;\n        case 'PathExpr':\n          // turn the path into an expressoin; i.e., remove the position\n          // information of the last axis.\n          var x = this.val(ast[1], ctx);\n          // Make the nodeset a forward-direction-only one.\n          if (x.finalize) {  // it is a NodeMultiSet\n            return {nodes: x.nodes};\n          } else {\n            return x;\n          }\n        case '/':\n          // TODO: don't generate '/' nodes, just Axis nodes.\n          var lhs = this.val(ast[1], ctx);\n          console.assert(null != lhs);\n          var r = this.val(ast[2], lhs);\n          console.assert(null != r);\n          return r;\n        case 'Axis':\n          // All the axis tests from Step. We only get AxisSpecifier NodeTest,\n          // not the predicate (which is applied later)\n          var axis = ast[1],\n              nodeType = ast[2],\n              nodeTypeNum = nodeTypes[nodeType],\n              shouldLowerCase = true,  // TODO: give option\n              nodeName = ast[3] && shouldLowerCase ? ast[3].toLowerCase() : ast[3];\n          nodeName = nodeName === '*' ? null : nodeName;\n          if ('object' !== typeof ctx) return {nodes:[], pos:[]};\n          var nodeList = ctx.nodes.slice();  // TODO: is copy needed?\n          var r = axes[axis](nodeList  /*destructive!*/, nodeTypeNum, nodeName, shouldLowerCase);\n          return r;\n      }\n    }\n  };\n  var evaluate = xpath.evaluate = function evaluate(expr, doc, context) {\n    //var astFactory = new AstEvaluatorFactory(doc, context);\n    var stream = new Stream(expr);\n    var ast = parse(stream, astFactory);\n    var val = new Evaluator(doc).val(ast, {nodes: [context]});\n    return val;\n  }\n\n  /***************************************************************************\n   *                           DOM interface                                 *\n   ***************************************************************************/\n  var XPathException = xpath.XPathException = function XPathException(code, message) {\n    var e = new Error(message);\n    e.name = 'XPathException';\n    e.code = code;\n    return e;\n  }\n  XPathException.INVALID_EXPRESSION_ERR = 51;\n  XPathException.TYPE_ERR = 52;\n\n\n  var XPathEvaluator = xpath.XPathEvaluator = function XPathEvaluator() {}\n  XPathEvaluator.prototype = {\n    createExpression: function(expression, resolver) {\n      return new XPathExpression(expression, resolver);\n    },\n    createNSResolver: function(nodeResolver) {\n      // TODO\n    },\n    evaluate: function evaluate(expression, contextNode, resolver, type, result) {\n      var expr = new XPathExpression(expression, resolver);\n      return expr.evaluate(contextNode, type, result);\n    }\n  };\n\n\n  var XPathExpression = xpath.XPathExpression = function XPathExpression(expression, resolver, optDoc) {\n    var stream = new Stream(expression);\n    this._ast = parse(stream, astFactory);\n    this._doc = optDoc;\n  }\n  XPathExpression.prototype = {\n    evaluate: function evaluate(contextNode, type, result) {\n      if (null == contextNode.nodeType)\n        throw new Error('bad argument (expected context node): ' + contextNode);\n      var doc = contextNode.ownerDocument || contextNode;\n      if (null != this._doc && this._doc !== doc) {\n        throw new core.DOMException(\n            core.DOMException.WRONG_DOCUMENT_ERR,\n            'The document must be the same as the context node\\'s document.');\n      }\n      var evaluator = new Evaluator(doc);\n      var value = evaluator.val(this._ast, {nodes: [contextNode]});\n      if (XPathResult.NUMBER_TYPE === type)\n        value = fn.number(value);\n      else if (XPathResult.STRING_TYPE === type)\n        value = fn.string(value);\n      else if (XPathResult.BOOLEAN_TYPE === type)\n        value = fn['boolean'](value);\n      else if (XPathResult.ANY_TYPE !== type &&\n               XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== type &&\n               XPathResult.ORDERED_NODE_ITERATOR_TYPE !== type &&\n               XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== type &&\n               XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== type &&\n               XPathResult.ANY_UNORDERED_NODE_TYPE !== type &&\n               XPathResult.FIRST_ORDERED_NODE_TYPE !== type)\n        throw new core.DOMException(\n            core.DOMException.NOT_SUPPORTED_ERR,\n            'You must provide an XPath result type (0=any).');\n      else if (XPathResult.ANY_TYPE !== type &&\n               'object' !== typeof value)\n        throw new XPathException(\n            XPathException.TYPE_ERR,\n            'Value should be a node-set: ' + value);\n      return new XPathResult(doc, value, type);\n    }\n  }\n\n  var XPathResult = xpath.XPathResult = function XPathResult(doc, value, resultType) {\n    this._value = value;\n    this._resultType = resultType;\n    this._i = 0;\n\n    // TODO: we removed mutation events but didn't take care of this. No tests fail, so that's nice, but eventually we\n    // should fix this, preferably by entirely replacing our XPath implementation.\n    // this._invalidated = false;\n    // if (this.resultType === XPathResult.UNORDERED_NODE_ITERATOR_TYPE ||\n    //     this.resultType === XPathResult.ORDERED_NODE_ITERATOR_TYPE) {\n    //   doc.addEventListener('DOMSubtreeModified', invalidate, true);\n    //   var self = this;\n    //   function invalidate() {\n    //     self._invalidated = true;\n    //     doc.removeEventListener('DOMSubtreeModified', invalidate, true);\n    //   }\n    // }\n  }\n  XPathResult.ANY_TYPE = 0;\n  XPathResult.NUMBER_TYPE = 1;\n  XPathResult.STRING_TYPE = 2;\n  XPathResult.BOOLEAN_TYPE = 3;\n  XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;\n  XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;\n  XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;\n  XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;\n  XPathResult.ANY_UNORDERED_NODE_TYPE = 8;\n  XPathResult.FIRST_ORDERED_NODE_TYPE = 9;\n  var proto = {\n    // XPathResultType\n    get resultType() {\n      if (this._resultType) return this._resultType;\n      switch (typeof this._value) {\n        case 'number': return XPathResult.NUMBER_TYPE;\n        case 'string': return XPathResult.STRING_TYPE;\n        case 'boolean': return XPathResult.BOOLEAN_TYPE;\n        default: return XPathResult.UNORDERED_NODE_ITERATOR_TYPE;\n      }\n    },\n    get numberValue() {\n      if (XPathResult.NUMBER_TYPE !== this.resultType)\n        throw new XPathException(XPathException.TYPE_ERR,\n                                 'You should have asked for a NUMBER_TYPE.');\n      return this._value;\n    },\n    get stringValue() {\n      if (XPathResult.STRING_TYPE !== this.resultType)\n        throw new XPathException(XPathException.TYPE_ERR,\n                                 'You should have asked for a STRING_TYPE.');\n      return this._value;\n    },\n    get booleanValue() {\n      if (XPathResult.BOOLEAN_TYPE !== this.resultType)\n        throw new XPathException(XPathException.TYPE_ERR,\n                                 'You should have asked for a BOOLEAN_TYPE.');\n      return this._value;\n    },\n    get singleNodeValue() {\n      if (XPathResult.ANY_UNORDERED_NODE_TYPE !== this.resultType &&\n          XPathResult.FIRST_ORDERED_NODE_TYPE !== this.resultType)\n        throw new XPathException(\n            XPathException.TYPE_ERR,\n            'You should have asked for a FIRST_ORDERED_NODE_TYPE.');\n      return this._value.nodes[0] || null;\n    },\n    get invalidIteratorState() {\n      if (XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== this.resultType &&\n          XPathResult.ORDERED_NODE_ITERATOR_TYPE !== this.resultType)\n        return false;\n      return !!this._invalidated;\n    },\n    get snapshotLength() {\n      if (XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== this.resultType &&\n          XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== this.resultType)\n        throw new XPathException(\n            XPathException.TYPE_ERR,\n            'You should have asked for a ORDERED_NODE_SNAPSHOT_TYPE.');\n      return this._value.nodes.length;\n    },\n    iterateNext: function iterateNext() {\n      if (XPathResult.UNORDERED_NODE_ITERATOR_TYPE !== this.resultType &&\n          XPathResult.ORDERED_NODE_ITERATOR_TYPE !== this.resultType)\n        throw new XPathException(\n            XPathException.TYPE_ERR,\n            'You should have asked for a ORDERED_NODE_ITERATOR_TYPE.');\n      if (this.invalidIteratorState)\n        throw new core.DOMException(\n            core.DOMException.INVALID_STATE_ERR,\n            'The document has been mutated since the result was returned');\n      return this._value.nodes[this._i++] || null;\n    },\n    snapshotItem: function snapshotItem(index) {\n      if (XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE !== this.resultType &&\n          XPathResult.ORDERED_NODE_SNAPSHOT_TYPE !== this.resultType)\n        throw new XPathException(\n            XPathException.TYPE_ERR,\n            'You should have asked for a ORDERED_NODE_SNAPSHOT_TYPE.');\n      return this._value.nodes[index] || null;\n    }\n  };\n  // so you can access ANY_TYPE etc. from the instances:\n  XPathResult.prototype = Object.create(XPathResult,\n      Object.keys(proto).reduce(function (descriptors, name) {\n        descriptors[name] = Object.getOwnPropertyDescriptor(proto, name);\n        return descriptors;\n      }, {\n        constructor: {\n          value: XPathResult,\n          writable: true,\n          configurable: true\n        }\n      }));\n\n  core.XPathException = XPathException;\n  core.XPathExpression = XPathExpression;\n  core.XPathResult = XPathResult;\n  core.XPathEvaluator = XPathEvaluator;\n\n  core.Document.prototype.createExpression =\n    XPathEvaluator.prototype.createExpression;\n\n  core.Document.prototype.createNSResolver =\n      XPathEvaluator.prototype.createNSResolver;\n\n  core.Document.prototype.evaluate = XPathEvaluator.prototype.evaluate;\n\n  return xpath; // for tests\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}