{"ast":null,"code":"\"use strict\";\n\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\n\nconst {\n  clone\n} = require(\"../node\");\n\nconst NODE_TYPE = require(\"../node-type\");\n\nconst {\n  parseFragment\n} = require(\"../../browser/parser/index\");\n\nconst {\n  HTML_NS\n} = require(\"../helpers/namespaces\");\n\nconst {\n  domSymbolTree\n} = require(\"../helpers/internal-constants\");\n\nconst {\n  compareBoundaryPointsPosition\n} = require(\"./boundary-point\");\n\nconst {\n  nodeRoot,\n  nodeLength,\n  isInclusiveAncestor\n} = require(\"../helpers/node\");\n\nconst {\n  createElement\n} = require(\"../helpers/create-element\");\n\nconst AbstractRangeImpl = require(\"./AbstractRange-impl\").implementation;\n\nconst Range = require(\"../generated/Range\");\n\nconst DocumentFragment = require(\"../generated/DocumentFragment\");\n\nconst {\n  implForWrapper\n} = require(\"../generated/utils\");\n\nconst RANGE_COMPARISON_TYPE = {\n  START_TO_START: 0,\n  START_TO_END: 1,\n  END_TO_END: 2,\n  END_TO_START: 3\n};\n\nclass RangeImpl extends AbstractRangeImpl {\n  constructor(globalObject, args, privateData) {\n    super(globalObject, args, privateData);\n    const defaultBoundaryPoint = {\n      node: implForWrapper(globalObject._document),\n      offset: 0\n    };\n    const {\n      start = defaultBoundaryPoint,\n      end = defaultBoundaryPoint\n    } = privateData;\n\n    this._setLiveRangeStart(start.node, start.offset);\n\n    this._setLiveRangeEnd(end.node, end.offset);\n  } // https://dom.spec.whatwg.org/#dom-range-commonancestorcontainer\n\n\n  get commonAncestorContainer() {\n    const {\n      _start,\n      _end\n    } = this;\n\n    for (const container of domSymbolTree.ancestorsIterator(_start.node)) {\n      if (isInclusiveAncestor(container, _end.node)) {\n        return container;\n      }\n    }\n\n    return null;\n  } // https://dom.spec.whatwg.org/#dom-range-setstart\n\n\n  setStart(node, offset) {\n    setBoundaryPointStart(this, node, offset);\n  } // https://dom.spec.whatwg.org/#dom-range-setend\n\n\n  setEnd(node, offset) {\n    setBoundaryPointEnd(this, node, offset);\n  } // https://dom.spec.whatwg.org/#dom-range-setstartbefore\n\n\n  setStartBefore(node) {\n    const parent = domSymbolTree.parent(node);\n\n    if (!parent) {\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n    }\n\n    setBoundaryPointStart(this, parent, domSymbolTree.index(node));\n  } // https://dom.spec.whatwg.org/#dom-range-setstartafter\n\n\n  setStartAfter(node) {\n    const parent = domSymbolTree.parent(node);\n\n    if (!parent) {\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n    }\n\n    setBoundaryPointStart(this, parent, domSymbolTree.index(node) + 1);\n  } // https://dom.spec.whatwg.org/#dom-range-setendbefore\n\n\n  setEndBefore(node) {\n    const parent = domSymbolTree.parent(node);\n\n    if (!parent) {\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n    }\n\n    setBoundaryPointEnd(this, parent, domSymbolTree.index(node));\n  } // https://dom.spec.whatwg.org/#dom-range-setendafter\n\n\n  setEndAfter(node) {\n    const parent = domSymbolTree.parent(node);\n\n    if (!parent) {\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n    }\n\n    setBoundaryPointEnd(this, parent, domSymbolTree.index(node) + 1);\n  } // https://dom.spec.whatwg.org/#dom-range-collapse\n\n\n  collapse(toStart) {\n    if (toStart) {\n      this._setLiveRangeEnd(this._start.node, this._start.offset);\n    } else {\n      this._setLiveRangeStart(this._end.node, this._end.offset);\n    }\n  } // https://dom.spec.whatwg.org/#dom-range-selectnode\n\n\n  selectNode(node) {\n    selectNodeWithinRange(node, this);\n  } // https://dom.spec.whatwg.org/#dom-range-selectnodecontents\n\n\n  selectNodeContents(node) {\n    if (node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n      throw DOMException.create(this._globalObject, [\"DocumentType Node can't be used as boundary point.\", \"InvalidNodeTypeError\"]);\n    }\n\n    const length = nodeLength(node);\n\n    this._setLiveRangeStart(node, 0);\n\n    this._setLiveRangeEnd(node, length);\n  } // https://dom.spec.whatwg.org/#dom-range-compareboundarypoints\n\n\n  compareBoundaryPoints(how, sourceRange) {\n    if (how !== RANGE_COMPARISON_TYPE.START_TO_START && how !== RANGE_COMPARISON_TYPE.START_TO_END && how !== RANGE_COMPARISON_TYPE.END_TO_END && how !== RANGE_COMPARISON_TYPE.END_TO_START) {\n      const message = \"The comparison method provided must be one of 'START_TO_START', 'START_TO_END', 'END_TO_END', \" + \"or 'END_TO_START'.\";\n      throw DOMException.create(this._globalObject, [message, \"NotSupportedError\"]);\n    }\n\n    if (this._root !== sourceRange._root) {\n      throw DOMException.create(this._globalObject, [\"The two Ranges are not in the same tree.\", \"WrongDocumentError\"]);\n    }\n\n    let thisPoint, otherPoint;\n\n    if (how === RANGE_COMPARISON_TYPE.START_TO_START) {\n      thisPoint = this._start;\n      otherPoint = sourceRange._start;\n    } else if (how === RANGE_COMPARISON_TYPE.START_TO_END) {\n      thisPoint = this._end;\n      otherPoint = sourceRange._start;\n    } else if (how === RANGE_COMPARISON_TYPE.END_TO_END) {\n      thisPoint = this._end;\n      otherPoint = sourceRange._end;\n    } else {\n      thisPoint = this._start;\n      otherPoint = sourceRange._end;\n    }\n\n    return compareBoundaryPointsPosition(thisPoint, otherPoint);\n  } // https://dom.spec.whatwg.org/#dom-range-deletecontents\n\n\n  deleteContents() {\n    if (this.collapsed) {\n      return;\n    }\n\n    const {\n      _start: originalStart,\n      _end: originalEnd\n    } = this;\n\n    if (originalStart.node === originalEnd.node && (originalStart.node.nodeType === NODE_TYPE.TEXT_NODE || originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE)) {\n      originalStart.node.replaceData(originalStart.offset, originalEnd.offset - originalStart.offset, \"\");\n      return;\n    }\n\n    const nodesToRemove = [];\n    let currentNode = this._start.node;\n    const endNode = nextNodeDescendant(this._end.node);\n\n    while (currentNode && currentNode !== endNode) {\n      if (isContained(currentNode, this) && !isContained(domSymbolTree.parent(currentNode), this)) {\n        nodesToRemove.push(currentNode);\n      }\n\n      currentNode = domSymbolTree.following(currentNode);\n    }\n\n    let newNode, newOffset;\n\n    if (isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n      newNode = originalStart.node;\n      newOffset = originalStart.offset;\n    } else {\n      let referenceNode = originalStart.node;\n\n      while (referenceNode && !isInclusiveAncestor(domSymbolTree.parent(referenceNode), originalEnd.node)) {\n        referenceNode = domSymbolTree.parent(referenceNode);\n      }\n\n      newNode = domSymbolTree.parent(referenceNode);\n      newOffset = domSymbolTree.index(referenceNode) + 1;\n    }\n\n    if (originalStart.node.nodeType === NODE_TYPE.TEXT_NODE || originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE) {\n      originalStart.node.replaceData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset, \"\");\n    }\n\n    for (const node of nodesToRemove) {\n      const parent = domSymbolTree.parent(node);\n      parent.removeChild(node);\n    }\n\n    if (originalEnd.node.nodeType === NODE_TYPE.TEXT_NODE || originalEnd.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalEnd.node.nodeType === NODE_TYPE.COMMENT_NODE) {\n      originalEnd.node.replaceData(0, originalEnd.offset, \"\");\n    }\n\n    this._setLiveRangeStart(newNode, newOffset);\n\n    this._setLiveRangeEnd(newNode, newOffset);\n  } // https://dom.spec.whatwg.org/#dom-range-extractcontents\n\n\n  extractContents() {\n    return extractRange(this);\n  } // https://dom.spec.whatwg.org/#dom-range-clonecontents\n\n\n  cloneContents() {\n    return cloneRange(this);\n  } // https://dom.spec.whatwg.org/#dom-range-insertnode\n\n\n  insertNode(node) {\n    insertNodeInRange(node, this);\n  } // https://dom.spec.whatwg.org/#dom-range-surroundcontents\n\n\n  surroundContents(newParent) {\n    let node = this.commonAncestorContainer;\n    const endNode = nextNodeDescendant(node);\n\n    while (node !== endNode) {\n      if (node.nodeType !== NODE_TYPE.TEXT_NODE && isPartiallyContained(node, this)) {\n        throw DOMException.create(this._globalObject, [\"The Range has partially contains a non-Text node.\", \"InvalidStateError\"]);\n      }\n\n      node = domSymbolTree.following(node);\n    }\n\n    if (newParent.nodeType === NODE_TYPE.DOCUMENT_NODE || newParent.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE || newParent.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      throw DOMException.create(this._globalObject, [\"Invalid element type.\", \"InvalidNodeTypeError\"]);\n    }\n\n    const fragment = extractRange(this);\n\n    while (domSymbolTree.firstChild(newParent)) {\n      newParent.removeChild(domSymbolTree.firstChild(newParent));\n    }\n\n    insertNodeInRange(newParent, this);\n    newParent.appendChild(fragment);\n    selectNodeWithinRange(newParent, this);\n  } // https://dom.spec.whatwg.org/#dom-range-clonerange\n\n\n  cloneRange() {\n    const {\n      _start,\n      _end,\n      _globalObject\n    } = this;\n    return Range.createImpl(_globalObject, [], {\n      start: {\n        node: _start.node,\n        offset: _start.offset\n      },\n      end: {\n        node: _end.node,\n        offset: _end.offset\n      }\n    });\n  } // https://dom.spec.whatwg.org/#dom-range-detach\n\n\n  detach() {// Do nothing by spec!\n  } // https://dom.spec.whatwg.org/#dom-range-ispointinrange\n\n\n  isPointInRange(node, offset) {\n    if (nodeRoot(node) !== this._root) {\n      return false;\n    }\n\n    validateSetBoundaryPoint(node, offset);\n    const bp = {\n      node,\n      offset\n    };\n\n    if (compareBoundaryPointsPosition(bp, this._start) === -1 || compareBoundaryPointsPosition(bp, this._end) === 1) {\n      return false;\n    }\n\n    return true;\n  } // https://dom.spec.whatwg.org/#dom-range-comparepoint\n\n\n  comparePoint(node, offset) {\n    if (nodeRoot(node) !== this._root) {\n      throw DOMException.create(this._globalObject, [\"The given Node and the Range are not in the same tree.\", \"WrongDocumentError\"]);\n    }\n\n    validateSetBoundaryPoint(node, offset);\n    const bp = {\n      node,\n      offset\n    };\n\n    if (compareBoundaryPointsPosition(bp, this._start) === -1) {\n      return -1;\n    } else if (compareBoundaryPointsPosition(bp, this._end) === 1) {\n      return 1;\n    }\n\n    return 0;\n  } // https://dom.spec.whatwg.org/#dom-range-intersectsnode\n\n\n  intersectsNode(node) {\n    if (nodeRoot(node) !== this._root) {\n      return false;\n    }\n\n    const parent = domSymbolTree.parent(node);\n\n    if (!parent) {\n      return true;\n    }\n\n    const offset = domSymbolTree.index(node);\n    return compareBoundaryPointsPosition({\n      node: parent,\n      offset\n    }, this._end) === -1 && compareBoundaryPointsPosition({\n      node: parent,\n      offset: offset + 1\n    }, this._start) === 1;\n  } // https://dom.spec.whatwg.org/#dom-range-stringifier\n\n\n  toString() {\n    let s = \"\";\n    const {\n      _start,\n      _end\n    } = this;\n\n    if (_start.node === _end.node && _start.node.nodeType === NODE_TYPE.TEXT_NODE) {\n      return _start.node.data.slice(_start.offset, _end.offset);\n    }\n\n    if (_start.node.nodeType === NODE_TYPE.TEXT_NODE) {\n      s += _start.node.data.slice(_start.offset);\n    }\n\n    let currentNode = _start.node;\n    const endNode = nextNodeDescendant(_end.node);\n\n    while (currentNode && currentNode !== endNode) {\n      if (currentNode.nodeType === NODE_TYPE.TEXT_NODE && isContained(currentNode, this)) {\n        s += currentNode.data;\n      }\n\n      currentNode = domSymbolTree.following(currentNode);\n    }\n\n    if (_end.node.nodeType === NODE_TYPE.TEXT_NODE) {\n      s += _end.node.data.slice(0, _end.offset);\n    }\n\n    return s;\n  } // https://w3c.github.io/DOM-Parsing/#dom-range-createcontextualfragment\n\n\n  createContextualFragment(fragment) {\n    const {\n      node\n    } = this._start;\n    let element;\n\n    switch (node.nodeType) {\n      case NODE_TYPE.DOCUMENT_NODE:\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n        element = null;\n        break;\n\n      case NODE_TYPE.ELEMENT_NODE:\n        element = node;\n        break;\n\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.COMMENT_NODE:\n        element = node.parentElement;\n        break;\n\n      default:\n        throw new Error(\"Internal error: Invalid range start node\");\n    }\n\n    if (element === null || element._ownerDocument._parsingMode === \"html\" && element._localName === \"html\" && element._namespaceURI === HTML_NS) {\n      element = createElement(node._ownerDocument, \"body\", HTML_NS);\n    }\n\n    return parseFragment(fragment, element);\n  } // https://dom.spec.whatwg.org/#concept-range-root\n\n\n  get _root() {\n    return nodeRoot(this._start.node);\n  }\n\n  _setLiveRangeStart(node, offset) {\n    if (this._start && this._start.node !== node) {\n      this._start.node._referencedRanges.delete(this);\n    }\n\n    if (!node._referencedRanges.has(this)) {\n      node._referencedRanges.add(this);\n    }\n\n    this._start = {\n      node,\n      offset\n    };\n  }\n\n  _setLiveRangeEnd(node, offset) {\n    if (this._end && this._end.node !== node) {\n      this._end.node._referencedRanges.delete(this);\n    }\n\n    if (!node._referencedRanges.has(this)) {\n      node._referencedRanges.add(this);\n    }\n\n    this._end = {\n      node,\n      offset\n    };\n  }\n\n}\n\nfunction nextNodeDescendant(node) {\n  while (node && !domSymbolTree.nextSibling(node)) {\n    node = domSymbolTree.parent(node);\n  }\n\n  if (!node) {\n    return null;\n  }\n\n  return domSymbolTree.nextSibling(node);\n} // https://dom.spec.whatwg.org/#concept-range-bp-set\n\n\nfunction validateSetBoundaryPoint(node, offset) {\n  if (node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n    throw DOMException.create(node._globalObject, [\"DocumentType Node can't be used as boundary point.\", \"InvalidNodeTypeError\"]);\n  }\n\n  if (offset > nodeLength(node)) {\n    throw DOMException.create(node._globalObject, [\"Offset out of bound.\", \"IndexSizeError\"]);\n  }\n}\n\nfunction setBoundaryPointStart(range, node, offset) {\n  validateSetBoundaryPoint(node, offset);\n  const bp = {\n    node,\n    offset\n  };\n\n  if (nodeRoot(node) !== range._root || compareBoundaryPointsPosition(bp, range._end) === 1) {\n    range._setLiveRangeEnd(node, offset);\n  }\n\n  range._setLiveRangeStart(node, offset);\n}\n\nfunction setBoundaryPointEnd(range, node, offset) {\n  validateSetBoundaryPoint(node, offset);\n  const bp = {\n    node,\n    offset\n  };\n\n  if (nodeRoot(node) !== range._root || compareBoundaryPointsPosition(bp, range._start) === -1) {\n    range._setLiveRangeStart(node, offset);\n  }\n\n  range._setLiveRangeEnd(node, offset);\n} // https://dom.spec.whatwg.org/#concept-range-select\n\n\nfunction selectNodeWithinRange(node, range) {\n  const parent = domSymbolTree.parent(node);\n\n  if (!parent) {\n    throw DOMException.create(node._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n  }\n\n  const index = domSymbolTree.index(node);\n\n  range._setLiveRangeStart(parent, index);\n\n  range._setLiveRangeEnd(parent, index + 1);\n} // https://dom.spec.whatwg.org/#contained\n\n\nfunction isContained(node, range) {\n  const {\n    _start,\n    _end\n  } = range;\n  return compareBoundaryPointsPosition({\n    node,\n    offset: 0\n  }, _start) === 1 && compareBoundaryPointsPosition({\n    node,\n    offset: nodeLength(node)\n  }, _end) === -1;\n} // https://dom.spec.whatwg.org/#partially-contained\n\n\nfunction isPartiallyContained(node, range) {\n  const {\n    _start,\n    _end\n  } = range;\n  return isInclusiveAncestor(node, _start.node) && !isInclusiveAncestor(node, _end.node) || !isInclusiveAncestor(node, _start.node) && isInclusiveAncestor(node, _end.node);\n} // https://dom.spec.whatwg.org/#concept-range-insert\n\n\nfunction insertNodeInRange(node, range) {\n  const {\n    node: startNode,\n    offset: startOffset\n  } = range._start;\n\n  if (startNode.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || startNode.nodeType === NODE_TYPE.COMMENT_NODE || startNode.nodeType === NODE_TYPE.TEXT_NODE && !domSymbolTree.parent(startNode) || node === startNode) {\n    throw DOMException.create(node._globalObject, [\"Invalid start node.\", \"HierarchyRequestError\"]);\n  }\n\n  let referenceNode = startNode.nodeType === NODE_TYPE.TEXT_NODE ? startNode : domSymbolTree.childrenToArray(startNode)[startOffset] || null;\n  const parent = !referenceNode ? startNode : domSymbolTree.parent(referenceNode);\n\n  parent._preInsertValidity(node, referenceNode);\n\n  if (startNode.nodeType === NODE_TYPE.TEXT_NODE) {\n    referenceNode = startNode.splitText(startOffset);\n  }\n\n  if (node === referenceNode) {\n    referenceNode = domSymbolTree.nextSibling(referenceNode);\n  }\n\n  const nodeParent = domSymbolTree.parent(node);\n\n  if (nodeParent) {\n    nodeParent.removeChild(node);\n  }\n\n  let newOffset = !referenceNode ? nodeLength(parent) : domSymbolTree.index(referenceNode);\n  newOffset += node.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ? nodeLength(node) : 1;\n  parent.insertBefore(node, referenceNode);\n\n  if (range.collapsed) {\n    range._setLiveRangeEnd(parent, newOffset);\n  }\n} // https://dom.spec.whatwg.org/#concept-range-clone\n\n\nfunction cloneRange(range) {\n  const {\n    _start: originalStart,\n    _end: originalEnd,\n    _globalObject\n  } = range;\n  const fragment = DocumentFragment.createImpl(_globalObject, [], {\n    ownerDocument: originalStart.node._ownerDocument\n  });\n\n  if (range.collapsed) {\n    return fragment;\n  }\n\n  if (originalStart.node === originalEnd.node && (originalStart.node.nodeType === NODE_TYPE.TEXT_NODE || originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    const cloned = clone(originalStart.node);\n    cloned._data = cloned.substringData(originalStart.offset, originalEnd.offset - originalStart.offset);\n    fragment.appendChild(cloned);\n    return fragment;\n  }\n\n  let commonAncestor = originalStart.node;\n\n  while (!isInclusiveAncestor(commonAncestor, originalEnd.node)) {\n    commonAncestor = domSymbolTree.parent(commonAncestor);\n  }\n\n  let firstPartialContainedChild = null;\n\n  if (!isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n    let candidate = domSymbolTree.firstChild(commonAncestor);\n\n    while (!firstPartialContainedChild) {\n      if (isPartiallyContained(candidate, range)) {\n        firstPartialContainedChild = candidate;\n      }\n\n      candidate = domSymbolTree.nextSibling(candidate);\n    }\n  }\n\n  let lastPartiallyContainedChild = null;\n\n  if (!isInclusiveAncestor(originalEnd.node, originalStart.node)) {\n    let candidate = domSymbolTree.lastChild(commonAncestor);\n\n    while (!lastPartiallyContainedChild) {\n      if (isPartiallyContained(candidate, range)) {\n        lastPartiallyContainedChild = candidate;\n      }\n\n      candidate = domSymbolTree.previousSibling(candidate);\n    }\n  }\n\n  const containedChildren = domSymbolTree.childrenToArray(commonAncestor).filter(node => isContained(node, range));\n  const hasDoctypeChildren = containedChildren.some(node => node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE);\n\n  if (hasDoctypeChildren) {\n    throw DOMException.create(range._globalObject, [\"Invalid document type element.\", \"HierarchyRequestError\"]);\n  }\n\n  if (firstPartialContainedChild !== null && (firstPartialContainedChild.nodeType === NODE_TYPE.TEXT_NODE || firstPartialContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || firstPartialContainedChild.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    const cloned = clone(originalStart.node);\n    cloned._data = cloned.substringData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset);\n    fragment.appendChild(cloned);\n  } else if (firstPartialContainedChild !== null) {\n    const cloned = clone(firstPartialContainedChild);\n    fragment.appendChild(cloned);\n    const subrange = Range.createImpl(_globalObject, [], {\n      start: {\n        node: originalStart.node,\n        offset: originalStart.offset\n      },\n      end: {\n        node: firstPartialContainedChild,\n        offset: nodeLength(firstPartialContainedChild)\n      }\n    });\n    const subfragment = cloneRange(subrange);\n    cloned.appendChild(subfragment);\n  }\n\n  for (const containedChild of containedChildren) {\n    const cloned = clone(containedChild, undefined, true);\n    fragment.appendChild(cloned);\n  }\n\n  if (lastPartiallyContainedChild !== null && (lastPartiallyContainedChild.nodeType === NODE_TYPE.TEXT_NODE || lastPartiallyContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || lastPartiallyContainedChild.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    const cloned = clone(originalEnd.node);\n    cloned._data = cloned.substringData(0, originalEnd.offset);\n    fragment.appendChild(cloned);\n  } else if (lastPartiallyContainedChild !== null) {\n    const cloned = clone(lastPartiallyContainedChild);\n    fragment.appendChild(cloned);\n    const subrange = Range.createImpl(_globalObject, [], {\n      start: {\n        node: lastPartiallyContainedChild,\n        offset: 0\n      },\n      end: {\n        node: originalEnd.node,\n        offset: originalEnd.offset\n      }\n    });\n    const subfragment = cloneRange(subrange);\n    cloned.appendChild(subfragment);\n  }\n\n  return fragment;\n} // https://dom.spec.whatwg.org/#concept-range-extract\n\n\nfunction extractRange(range) {\n  const {\n    _start: originalStart,\n    _end: originalEnd,\n    _globalObject\n  } = range;\n  const fragment = DocumentFragment.createImpl(_globalObject, [], {\n    ownerDocument: originalStart.node._ownerDocument\n  });\n\n  if (range.collapsed) {\n    return fragment;\n  }\n\n  if (originalStart.node === originalEnd.node && (originalStart.node.nodeType === NODE_TYPE.TEXT_NODE || originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    const cloned = clone(originalStart.node);\n    cloned._data = cloned.substringData(originalStart.offset, originalEnd.offset - originalStart.offset);\n    fragment.appendChild(cloned);\n    originalStart.node.replaceData(originalStart.offset, originalEnd.offset - originalStart.offset, \"\");\n    return fragment;\n  }\n\n  let commonAncestor = originalStart.node;\n\n  while (!isInclusiveAncestor(commonAncestor, originalEnd.node)) {\n    commonAncestor = domSymbolTree.parent(commonAncestor);\n  }\n\n  let firstPartialContainedChild = null;\n\n  if (!isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n    let candidate = domSymbolTree.firstChild(commonAncestor);\n\n    while (!firstPartialContainedChild) {\n      if (isPartiallyContained(candidate, range)) {\n        firstPartialContainedChild = candidate;\n      }\n\n      candidate = domSymbolTree.nextSibling(candidate);\n    }\n  }\n\n  let lastPartiallyContainedChild = null;\n\n  if (!isInclusiveAncestor(originalEnd.node, originalStart.node)) {\n    let candidate = domSymbolTree.lastChild(commonAncestor);\n\n    while (!lastPartiallyContainedChild) {\n      if (isPartiallyContained(candidate, range)) {\n        lastPartiallyContainedChild = candidate;\n      }\n\n      candidate = domSymbolTree.previousSibling(candidate);\n    }\n  }\n\n  const containedChildren = domSymbolTree.childrenToArray(commonAncestor).filter(node => isContained(node, range));\n  const hasDoctypeChildren = containedChildren.some(node => node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE);\n\n  if (hasDoctypeChildren) {\n    throw DOMException.create(range._globalObject, [\"Invalid document type element.\", \"HierarchyRequestError\"]);\n  }\n\n  let newNode, newOffset;\n\n  if (isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n    newNode = originalStart.node;\n    newOffset = originalStart.offset;\n  } else {\n    let referenceNode = originalStart.node;\n\n    while (referenceNode && !isInclusiveAncestor(domSymbolTree.parent(referenceNode), originalEnd.node)) {\n      referenceNode = domSymbolTree.parent(referenceNode);\n    }\n\n    newNode = domSymbolTree.parent(referenceNode);\n    newOffset = domSymbolTree.index(referenceNode) + 1;\n  }\n\n  if (firstPartialContainedChild !== null && (firstPartialContainedChild.nodeType === NODE_TYPE.TEXT_NODE || firstPartialContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || firstPartialContainedChild.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    const cloned = clone(originalStart.node);\n    cloned._data = cloned.substringData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset);\n    fragment.appendChild(cloned);\n    originalStart.node.replaceData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset, \"\");\n  } else if (firstPartialContainedChild !== null) {\n    const cloned = clone(firstPartialContainedChild);\n    fragment.appendChild(cloned);\n    const subrange = Range.createImpl(_globalObject, [], {\n      start: {\n        node: originalStart.node,\n        offset: originalStart.offset\n      },\n      end: {\n        node: firstPartialContainedChild,\n        offset: nodeLength(firstPartialContainedChild)\n      }\n    });\n    const subfragment = extractRange(subrange);\n    cloned.appendChild(subfragment);\n  }\n\n  for (const containedChild of containedChildren) {\n    fragment.appendChild(containedChild);\n  }\n\n  if (lastPartiallyContainedChild !== null && (lastPartiallyContainedChild.nodeType === NODE_TYPE.TEXT_NODE || lastPartiallyContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || lastPartiallyContainedChild.nodeType === NODE_TYPE.COMMENT_NODE)) {\n    const cloned = clone(originalEnd.node);\n    cloned._data = cloned.substringData(0, originalEnd.offset);\n    fragment.appendChild(cloned);\n    originalEnd.node.replaceData(0, originalEnd.offset, \"\");\n  } else if (lastPartiallyContainedChild !== null) {\n    const cloned = clone(lastPartiallyContainedChild);\n    fragment.appendChild(cloned);\n    const subrange = Range.createImpl(_globalObject, [], {\n      start: {\n        node: lastPartiallyContainedChild,\n        offset: 0\n      },\n      end: {\n        node: originalEnd.node,\n        offset: originalEnd.offset\n      }\n    });\n    const subfragment = extractRange(subrange);\n    cloned.appendChild(subfragment);\n  }\n\n  range._setLiveRangeStart(newNode, newOffset);\n\n  range._setLiveRangeEnd(newNode, newOffset);\n\n  return fragment;\n}\n\nmodule.exports = {\n  implementation: RangeImpl,\n  setBoundaryPointStart,\n  setBoundaryPointEnd\n};","map":{"version":3,"names":["DOMException","require","clone","NODE_TYPE","parseFragment","HTML_NS","domSymbolTree","compareBoundaryPointsPosition","nodeRoot","nodeLength","isInclusiveAncestor","createElement","AbstractRangeImpl","implementation","Range","DocumentFragment","implForWrapper","RANGE_COMPARISON_TYPE","START_TO_START","START_TO_END","END_TO_END","END_TO_START","RangeImpl","constructor","globalObject","args","privateData","defaultBoundaryPoint","node","_document","offset","start","end","_setLiveRangeStart","_setLiveRangeEnd","commonAncestorContainer","_start","_end","container","ancestorsIterator","setStart","setBoundaryPointStart","setEnd","setBoundaryPointEnd","setStartBefore","parent","create","_globalObject","index","setStartAfter","setEndBefore","setEndAfter","collapse","toStart","selectNode","selectNodeWithinRange","selectNodeContents","nodeType","DOCUMENT_TYPE_NODE","length","compareBoundaryPoints","how","sourceRange","message","_root","thisPoint","otherPoint","deleteContents","collapsed","originalStart","originalEnd","TEXT_NODE","PROCESSING_INSTRUCTION_NODE","COMMENT_NODE","replaceData","nodesToRemove","currentNode","endNode","nextNodeDescendant","isContained","push","following","newNode","newOffset","referenceNode","removeChild","extractContents","extractRange","cloneContents","cloneRange","insertNode","insertNodeInRange","surroundContents","newParent","isPartiallyContained","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","fragment","firstChild","appendChild","createImpl","detach","isPointInRange","validateSetBoundaryPoint","bp","comparePoint","intersectsNode","toString","s","data","slice","createContextualFragment","element","ELEMENT_NODE","parentElement","Error","_ownerDocument","_parsingMode","_localName","_namespaceURI","_referencedRanges","delete","has","add","nextSibling","range","startNode","startOffset","childrenToArray","_preInsertValidity","splitText","nodeParent","insertBefore","ownerDocument","cloned","_data","substringData","commonAncestor","firstPartialContainedChild","candidate","lastPartiallyContainedChild","lastChild","previousSibling","containedChildren","filter","hasDoctypeChildren","some","subrange","subfragment","containedChild","undefined","module","exports"],"sources":["C:/Users/17033/balmco/node_modules/jsdom/lib/jsdom/living/range/Range-impl.js"],"sourcesContent":["\"use strict\";\n\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\n\nconst { clone } = require(\"../node\");\nconst NODE_TYPE = require(\"../node-type\");\nconst { parseFragment } = require(\"../../browser/parser/index\");\n\nconst { HTML_NS } = require(\"../helpers/namespaces\");\nconst { domSymbolTree } = require(\"../helpers/internal-constants\");\nconst { compareBoundaryPointsPosition } = require(\"./boundary-point\");\nconst { nodeRoot, nodeLength, isInclusiveAncestor } = require(\"../helpers/node\");\nconst { createElement } = require(\"../helpers/create-element\");\n\nconst AbstractRangeImpl = require(\"./AbstractRange-impl\").implementation;\n\nconst Range = require(\"../generated/Range\");\nconst DocumentFragment = require(\"../generated/DocumentFragment\");\nconst { implForWrapper } = require(\"../generated/utils\");\n\nconst RANGE_COMPARISON_TYPE = {\n  START_TO_START: 0,\n  START_TO_END: 1,\n  END_TO_END: 2,\n  END_TO_START: 3\n};\n\nclass RangeImpl extends AbstractRangeImpl {\n  constructor(globalObject, args, privateData) {\n    super(globalObject, args, privateData);\n\n    const defaultBoundaryPoint = {\n      node: implForWrapper(globalObject._document),\n      offset: 0\n    };\n\n    const {\n      start = defaultBoundaryPoint,\n      end = defaultBoundaryPoint\n    } = privateData;\n\n    this._setLiveRangeStart(start.node, start.offset);\n    this._setLiveRangeEnd(end.node, end.offset);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-commonancestorcontainer\n  get commonAncestorContainer() {\n    const { _start, _end } = this;\n\n    for (const container of domSymbolTree.ancestorsIterator(_start.node)) {\n      if (isInclusiveAncestor(container, _end.node)) {\n        return container;\n      }\n    }\n\n    return null;\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-setstart\n  setStart(node, offset) {\n    setBoundaryPointStart(this, node, offset);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-setend\n  setEnd(node, offset) {\n    setBoundaryPointEnd(this, node, offset);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-setstartbefore\n  setStartBefore(node) {\n    const parent = domSymbolTree.parent(node);\n\n    if (!parent) {\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n    }\n\n    setBoundaryPointStart(this, parent, domSymbolTree.index(node));\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-setstartafter\n  setStartAfter(node) {\n    const parent = domSymbolTree.parent(node);\n\n    if (!parent) {\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n    }\n\n    setBoundaryPointStart(this, parent, domSymbolTree.index(node) + 1);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-setendbefore\n  setEndBefore(node) {\n    const parent = domSymbolTree.parent(node);\n\n    if (!parent) {\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n    }\n\n    setBoundaryPointEnd(this, parent, domSymbolTree.index(node));\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-setendafter\n  setEndAfter(node) {\n    const parent = domSymbolTree.parent(node);\n\n    if (!parent) {\n      throw DOMException.create(this._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n    }\n\n    setBoundaryPointEnd(this, parent, domSymbolTree.index(node) + 1);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-collapse\n  collapse(toStart) {\n    if (toStart) {\n      this._setLiveRangeEnd(this._start.node, this._start.offset);\n    } else {\n      this._setLiveRangeStart(this._end.node, this._end.offset);\n    }\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-selectnode\n  selectNode(node) {\n    selectNodeWithinRange(node, this);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-selectnodecontents\n  selectNodeContents(node) {\n    if (node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n      throw DOMException.create(this._globalObject, [\n        \"DocumentType Node can't be used as boundary point.\",\n        \"InvalidNodeTypeError\"\n      ]);\n    }\n\n    const length = nodeLength(node);\n\n    this._setLiveRangeStart(node, 0);\n    this._setLiveRangeEnd(node, length);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-compareboundarypoints\n  compareBoundaryPoints(how, sourceRange) {\n    if (\n      how !== RANGE_COMPARISON_TYPE.START_TO_START &&\n      how !== RANGE_COMPARISON_TYPE.START_TO_END &&\n      how !== RANGE_COMPARISON_TYPE.END_TO_END &&\n      how !== RANGE_COMPARISON_TYPE.END_TO_START\n    ) {\n      const message = \"The comparison method provided must be one of 'START_TO_START', 'START_TO_END', 'END_TO_END', \" +\n                      \"or 'END_TO_START'.\";\n      throw DOMException.create(this._globalObject, [message, \"NotSupportedError\"]);\n    }\n\n    if (this._root !== sourceRange._root) {\n      throw DOMException.create(this._globalObject, [\"The two Ranges are not in the same tree.\", \"WrongDocumentError\"]);\n    }\n\n    let thisPoint, otherPoint;\n    if (how === RANGE_COMPARISON_TYPE.START_TO_START) {\n      thisPoint = this._start;\n      otherPoint = sourceRange._start;\n    } else if (how === RANGE_COMPARISON_TYPE.START_TO_END) {\n      thisPoint = this._end;\n      otherPoint = sourceRange._start;\n    } else if (how === RANGE_COMPARISON_TYPE.END_TO_END) {\n      thisPoint = this._end;\n      otherPoint = sourceRange._end;\n    } else {\n      thisPoint = this._start;\n      otherPoint = sourceRange._end;\n    }\n\n    return compareBoundaryPointsPosition(thisPoint, otherPoint);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-deletecontents\n  deleteContents() {\n    if (this.collapsed) {\n      return;\n    }\n\n    const { _start: originalStart, _end: originalEnd } = this;\n\n    if (\n      originalStart.node === originalEnd.node &&\n      (\n        originalStart.node.nodeType === NODE_TYPE.TEXT_NODE ||\n        originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\n        originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE\n      )\n    ) {\n      originalStart.node.replaceData(originalStart.offset, originalEnd.offset - originalStart.offset, \"\");\n      return;\n    }\n\n    const nodesToRemove = [];\n    let currentNode = this._start.node;\n    const endNode = nextNodeDescendant(this._end.node);\n    while (currentNode && currentNode !== endNode) {\n      if (\n        isContained(currentNode, this) &&\n        !isContained(domSymbolTree.parent(currentNode), this)\n      ) {\n        nodesToRemove.push(currentNode);\n      }\n\n      currentNode = domSymbolTree.following(currentNode);\n    }\n\n    let newNode, newOffset;\n    if (isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n      newNode = originalStart.node;\n      newOffset = originalStart.offset;\n    } else {\n      let referenceNode = originalStart.node;\n\n      while (\n        referenceNode &&\n        !isInclusiveAncestor(domSymbolTree.parent(referenceNode), originalEnd.node)\n      ) {\n        referenceNode = domSymbolTree.parent(referenceNode);\n      }\n\n      newNode = domSymbolTree.parent(referenceNode);\n      newOffset = domSymbolTree.index(referenceNode) + 1;\n    }\n\n    if (\n      originalStart.node.nodeType === NODE_TYPE.TEXT_NODE ||\n      originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\n      originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE\n    ) {\n      originalStart.node.replaceData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset, \"\");\n    }\n\n    for (const node of nodesToRemove) {\n      const parent = domSymbolTree.parent(node);\n      parent.removeChild(node);\n    }\n\n    if (\n      originalEnd.node.nodeType === NODE_TYPE.TEXT_NODE ||\n      originalEnd.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\n      originalEnd.node.nodeType === NODE_TYPE.COMMENT_NODE\n    ) {\n      originalEnd.node.replaceData(0, originalEnd.offset, \"\");\n    }\n\n    this._setLiveRangeStart(newNode, newOffset);\n    this._setLiveRangeEnd(newNode, newOffset);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-extractcontents\n  extractContents() {\n    return extractRange(this);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-clonecontents\n  cloneContents() {\n    return cloneRange(this);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-insertnode\n  insertNode(node) {\n    insertNodeInRange(node, this);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-surroundcontents\n  surroundContents(newParent) {\n    let node = this.commonAncestorContainer;\n    const endNode = nextNodeDescendant(node);\n    while (node !== endNode) {\n      if (node.nodeType !== NODE_TYPE.TEXT_NODE && isPartiallyContained(node, this)) {\n        throw DOMException.create(this._globalObject, [\n          \"The Range has partially contains a non-Text node.\",\n          \"InvalidStateError\"\n        ]);\n      }\n\n      node = domSymbolTree.following(node);\n    }\n\n    if (\n      newParent.nodeType === NODE_TYPE.DOCUMENT_NODE ||\n      newParent.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE ||\n      newParent.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE\n    ) {\n      throw DOMException.create(this._globalObject, [\"Invalid element type.\", \"InvalidNodeTypeError\"]);\n    }\n\n    const fragment = extractRange(this);\n\n    while (domSymbolTree.firstChild(newParent)) {\n      newParent.removeChild(domSymbolTree.firstChild(newParent));\n    }\n\n    insertNodeInRange(newParent, this);\n\n    newParent.appendChild(fragment);\n\n    selectNodeWithinRange(newParent, this);\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-clonerange\n  cloneRange() {\n    const { _start, _end, _globalObject } = this;\n\n    return Range.createImpl(_globalObject, [], {\n      start: { node: _start.node, offset: _start.offset },\n      end: { node: _end.node, offset: _end.offset }\n    });\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-detach\n  detach() {\n    // Do nothing by spec!\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-ispointinrange\n  isPointInRange(node, offset) {\n    if (nodeRoot(node) !== this._root) {\n      return false;\n    }\n\n    validateSetBoundaryPoint(node, offset);\n\n    const bp = { node, offset };\n\n    if (\n      compareBoundaryPointsPosition(bp, this._start) === -1 ||\n      compareBoundaryPointsPosition(bp, this._end) === 1\n    ) {\n      return false;\n    }\n\n    return true;\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-comparepoint\n  comparePoint(node, offset) {\n    if (nodeRoot(node) !== this._root) {\n      throw DOMException.create(this._globalObject, [\n        \"The given Node and the Range are not in the same tree.\",\n        \"WrongDocumentError\"\n      ]);\n    }\n\n    validateSetBoundaryPoint(node, offset);\n\n    const bp = { node, offset };\n    if (compareBoundaryPointsPosition(bp, this._start) === -1) {\n      return -1;\n    } else if (compareBoundaryPointsPosition(bp, this._end) === 1) {\n      return 1;\n    }\n\n    return 0;\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-intersectsnode\n  intersectsNode(node) {\n    if (nodeRoot(node) !== this._root) {\n      return false;\n    }\n\n    const parent = domSymbolTree.parent(node);\n    if (!parent) {\n      return true;\n    }\n\n    const offset = domSymbolTree.index(node);\n\n    return (\n      compareBoundaryPointsPosition({ node: parent, offset }, this._end) === -1 &&\n      compareBoundaryPointsPosition({ node: parent, offset: offset + 1 }, this._start) === 1\n    );\n  }\n\n  // https://dom.spec.whatwg.org/#dom-range-stringifier\n  toString() {\n    let s = \"\";\n    const { _start, _end } = this;\n\n    if (_start.node === _end.node && _start.node.nodeType === NODE_TYPE.TEXT_NODE) {\n      return _start.node.data.slice(_start.offset, _end.offset);\n    }\n\n    if (_start.node.nodeType === NODE_TYPE.TEXT_NODE) {\n      s += _start.node.data.slice(_start.offset);\n    }\n\n    let currentNode = _start.node;\n    const endNode = nextNodeDescendant(_end.node);\n    while (currentNode && currentNode !== endNode) {\n      if (currentNode.nodeType === NODE_TYPE.TEXT_NODE && isContained(currentNode, this)) {\n        s += currentNode.data;\n      }\n\n      currentNode = domSymbolTree.following(currentNode);\n    }\n\n    if (_end.node.nodeType === NODE_TYPE.TEXT_NODE) {\n      s += _end.node.data.slice(0, _end.offset);\n    }\n\n    return s;\n  }\n\n  // https://w3c.github.io/DOM-Parsing/#dom-range-createcontextualfragment\n  createContextualFragment(fragment) {\n    const { node } = this._start;\n\n    let element;\n    switch (node.nodeType) {\n      case NODE_TYPE.DOCUMENT_NODE:\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n        element = null;\n        break;\n\n      case NODE_TYPE.ELEMENT_NODE:\n        element = node;\n        break;\n\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.COMMENT_NODE:\n        element = node.parentElement;\n        break;\n\n      default:\n        throw new Error(\"Internal error: Invalid range start node\");\n    }\n\n    if (\n      element === null || (\n        element._ownerDocument._parsingMode === \"html\" &&\n        element._localName === \"html\" &&\n        element._namespaceURI === HTML_NS\n      )\n    ) {\n      element = createElement(node._ownerDocument, \"body\", HTML_NS);\n    }\n\n    return parseFragment(fragment, element);\n  }\n\n  // https://dom.spec.whatwg.org/#concept-range-root\n  get _root() {\n    return nodeRoot(this._start.node);\n  }\n\n  _setLiveRangeStart(node, offset) {\n    if (this._start && this._start.node !== node) {\n      this._start.node._referencedRanges.delete(this);\n    }\n\n    if (!node._referencedRanges.has(this)) {\n      node._referencedRanges.add(this);\n    }\n\n    this._start = {\n      node,\n      offset\n    };\n  }\n\n  _setLiveRangeEnd(node, offset) {\n    if (this._end && this._end.node !== node) {\n      this._end.node._referencedRanges.delete(this);\n    }\n\n    if (!node._referencedRanges.has(this)) {\n      node._referencedRanges.add(this);\n    }\n\n    this._end = {\n      node,\n      offset\n    };\n  }\n}\n\n\nfunction nextNodeDescendant(node) {\n  while (node && !domSymbolTree.nextSibling(node)) {\n    node = domSymbolTree.parent(node);\n  }\n\n  if (!node) {\n    return null;\n  }\n\n  return domSymbolTree.nextSibling(node);\n}\n\n// https://dom.spec.whatwg.org/#concept-range-bp-set\nfunction validateSetBoundaryPoint(node, offset) {\n  if (node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n    throw DOMException.create(node._globalObject, [\n      \"DocumentType Node can't be used as boundary point.\",\n      \"InvalidNodeTypeError\"\n    ]);\n  }\n\n  if (offset > nodeLength(node)) {\n    throw DOMException.create(node._globalObject, [\"Offset out of bound.\", \"IndexSizeError\"]);\n  }\n}\nfunction setBoundaryPointStart(range, node, offset) {\n  validateSetBoundaryPoint(node, offset);\n\n  const bp = { node, offset };\n  if (\n    nodeRoot(node) !== range._root ||\n    compareBoundaryPointsPosition(bp, range._end) === 1\n  ) {\n    range._setLiveRangeEnd(node, offset);\n  }\n\n  range._setLiveRangeStart(node, offset);\n}\nfunction setBoundaryPointEnd(range, node, offset) {\n  validateSetBoundaryPoint(node, offset);\n\n  const bp = { node, offset };\n  if (\n    nodeRoot(node) !== range._root ||\n    compareBoundaryPointsPosition(bp, range._start) === -1\n  ) {\n    range._setLiveRangeStart(node, offset);\n  }\n\n  range._setLiveRangeEnd(node, offset);\n}\n\n// https://dom.spec.whatwg.org/#concept-range-select\nfunction selectNodeWithinRange(node, range) {\n  const parent = domSymbolTree.parent(node);\n\n  if (!parent) {\n    throw DOMException.create(node._globalObject, [\"The given Node has no parent.\", \"InvalidNodeTypeError\"]);\n  }\n\n  const index = domSymbolTree.index(node);\n\n  range._setLiveRangeStart(parent, index);\n  range._setLiveRangeEnd(parent, index + 1);\n}\n\n// https://dom.spec.whatwg.org/#contained\nfunction isContained(node, range) {\n  const { _start, _end } = range;\n  return (\n    compareBoundaryPointsPosition({ node, offset: 0 }, _start) === 1 &&\n    compareBoundaryPointsPosition({ node, offset: nodeLength(node) }, _end) === -1\n  );\n}\n\n// https://dom.spec.whatwg.org/#partially-contained\nfunction isPartiallyContained(node, range) {\n  const { _start, _end } = range;\n  return (\n    (isInclusiveAncestor(node, _start.node) && !isInclusiveAncestor(node, _end.node)) ||\n    (!isInclusiveAncestor(node, _start.node) && isInclusiveAncestor(node, _end.node))\n  );\n}\n\n// https://dom.spec.whatwg.org/#concept-range-insert\nfunction insertNodeInRange(node, range) {\n  const { node: startNode, offset: startOffset } = range._start;\n\n  if (\n    startNode.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\n    startNode.nodeType === NODE_TYPE.COMMENT_NODE ||\n    (startNode.nodeType === NODE_TYPE.TEXT_NODE && !domSymbolTree.parent(startNode)) ||\n    node === startNode\n  ) {\n    throw DOMException.create(node._globalObject, [\"Invalid start node.\", \"HierarchyRequestError\"]);\n  }\n\n  let referenceNode = startNode.nodeType === NODE_TYPE.TEXT_NODE ?\n    startNode :\n    domSymbolTree.childrenToArray(startNode)[startOffset] || null;\n  const parent = !referenceNode ?\n    startNode :\n    domSymbolTree.parent(referenceNode);\n\n  parent._preInsertValidity(node, referenceNode);\n\n  if (startNode.nodeType === NODE_TYPE.TEXT_NODE) {\n    referenceNode = startNode.splitText(startOffset);\n  }\n\n  if (node === referenceNode) {\n    referenceNode = domSymbolTree.nextSibling(referenceNode);\n  }\n\n  const nodeParent = domSymbolTree.parent(node);\n  if (nodeParent) {\n    nodeParent.removeChild(node);\n  }\n\n  let newOffset = !referenceNode ? nodeLength(parent) : domSymbolTree.index(referenceNode);\n  newOffset += node.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ? nodeLength(node) : 1;\n\n  parent.insertBefore(node, referenceNode);\n\n  if (range.collapsed) {\n    range._setLiveRangeEnd(parent, newOffset);\n  }\n}\n\n// https://dom.spec.whatwg.org/#concept-range-clone\nfunction cloneRange(range) {\n  const { _start: originalStart, _end: originalEnd, _globalObject } = range;\n\n  const fragment = DocumentFragment.createImpl(_globalObject, [], {\n    ownerDocument: originalStart.node._ownerDocument\n  });\n\n  if (range.collapsed) {\n    return fragment;\n  }\n\n  if (\n    originalStart.node === originalEnd.node &&\n    (\n      originalStart.node.nodeType === NODE_TYPE.TEXT_NODE ||\n      originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\n      originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE\n    )\n  ) {\n    const cloned = clone(originalStart.node);\n    cloned._data = cloned.substringData(originalStart.offset, originalEnd.offset - originalStart.offset);\n\n    fragment.appendChild(cloned);\n\n    return fragment;\n  }\n\n  let commonAncestor = originalStart.node;\n  while (!isInclusiveAncestor(commonAncestor, originalEnd.node)) {\n    commonAncestor = domSymbolTree.parent(commonAncestor);\n  }\n\n  let firstPartialContainedChild = null;\n  if (!isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n    let candidate = domSymbolTree.firstChild(commonAncestor);\n    while (!firstPartialContainedChild) {\n      if (isPartiallyContained(candidate, range)) {\n        firstPartialContainedChild = candidate;\n      }\n\n      candidate = domSymbolTree.nextSibling(candidate);\n    }\n  }\n\n  let lastPartiallyContainedChild = null;\n  if (!isInclusiveAncestor(originalEnd.node, originalStart.node)) {\n    let candidate = domSymbolTree.lastChild(commonAncestor);\n    while (!lastPartiallyContainedChild) {\n      if (isPartiallyContained(candidate, range)) {\n        lastPartiallyContainedChild = candidate;\n      }\n\n      candidate = domSymbolTree.previousSibling(candidate);\n    }\n  }\n\n  const containedChildren = domSymbolTree.childrenToArray(commonAncestor)\n    .filter(node => isContained(node, range));\n\n  const hasDoctypeChildren = containedChildren.some(node => node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE);\n  if (hasDoctypeChildren) {\n    throw DOMException.create(range._globalObject, [\"Invalid document type element.\", \"HierarchyRequestError\"]);\n  }\n\n  if (\n    firstPartialContainedChild !== null &&\n    (\n      firstPartialContainedChild.nodeType === NODE_TYPE.TEXT_NODE ||\n      firstPartialContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\n      firstPartialContainedChild.nodeType === NODE_TYPE.COMMENT_NODE\n    )\n  ) {\n    const cloned = clone(originalStart.node);\n    cloned._data = cloned.substringData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset);\n\n    fragment.appendChild(cloned);\n  } else if (firstPartialContainedChild !== null) {\n    const cloned = clone(firstPartialContainedChild);\n    fragment.appendChild(cloned);\n\n    const subrange = Range.createImpl(_globalObject, [], {\n      start: { node: originalStart.node, offset: originalStart.offset },\n      end: { node: firstPartialContainedChild, offset: nodeLength(firstPartialContainedChild) }\n    });\n\n    const subfragment = cloneRange(subrange);\n    cloned.appendChild(subfragment);\n  }\n\n  for (const containedChild of containedChildren) {\n    const cloned = clone(containedChild, undefined, true);\n    fragment.appendChild(cloned);\n  }\n\n  if (\n    lastPartiallyContainedChild !== null &&\n    (\n      lastPartiallyContainedChild.nodeType === NODE_TYPE.TEXT_NODE ||\n      lastPartiallyContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\n      lastPartiallyContainedChild.nodeType === NODE_TYPE.COMMENT_NODE\n    )\n  ) {\n    const cloned = clone(originalEnd.node);\n    cloned._data = cloned.substringData(0, originalEnd.offset);\n\n    fragment.appendChild(cloned);\n  } else if (lastPartiallyContainedChild !== null) {\n    const cloned = clone(lastPartiallyContainedChild);\n    fragment.appendChild(cloned);\n\n    const subrange = Range.createImpl(_globalObject, [], {\n      start: { node: lastPartiallyContainedChild, offset: 0 },\n      end: { node: originalEnd.node, offset: originalEnd.offset }\n    });\n\n    const subfragment = cloneRange(subrange);\n    cloned.appendChild(subfragment);\n  }\n\n  return fragment;\n}\n\n// https://dom.spec.whatwg.org/#concept-range-extract\nfunction extractRange(range) {\n  const { _start: originalStart, _end: originalEnd, _globalObject } = range;\n\n  const fragment = DocumentFragment.createImpl(_globalObject, [], {\n    ownerDocument: originalStart.node._ownerDocument\n  });\n\n  if (range.collapsed) {\n    return fragment;\n  }\n\n  if (\n    originalStart.node === originalEnd.node &&\n    (\n      originalStart.node.nodeType === NODE_TYPE.TEXT_NODE ||\n      originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\n      originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE\n    )\n  ) {\n    const cloned = clone(originalStart.node);\n    cloned._data = cloned.substringData(originalStart.offset, originalEnd.offset - originalStart.offset);\n\n    fragment.appendChild(cloned);\n    originalStart.node.replaceData(originalStart.offset, originalEnd.offset - originalStart.offset, \"\");\n\n    return fragment;\n  }\n\n  let commonAncestor = originalStart.node;\n  while (!isInclusiveAncestor(commonAncestor, originalEnd.node)) {\n    commonAncestor = domSymbolTree.parent(commonAncestor);\n  }\n\n  let firstPartialContainedChild = null;\n  if (!isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n    let candidate = domSymbolTree.firstChild(commonAncestor);\n    while (!firstPartialContainedChild) {\n      if (isPartiallyContained(candidate, range)) {\n        firstPartialContainedChild = candidate;\n      }\n\n      candidate = domSymbolTree.nextSibling(candidate);\n    }\n  }\n\n  let lastPartiallyContainedChild = null;\n  if (!isInclusiveAncestor(originalEnd.node, originalStart.node)) {\n    let candidate = domSymbolTree.lastChild(commonAncestor);\n    while (!lastPartiallyContainedChild) {\n      if (isPartiallyContained(candidate, range)) {\n        lastPartiallyContainedChild = candidate;\n      }\n\n      candidate = domSymbolTree.previousSibling(candidate);\n    }\n  }\n\n  const containedChildren = domSymbolTree.childrenToArray(commonAncestor)\n    .filter(node => isContained(node, range));\n\n  const hasDoctypeChildren = containedChildren.some(node => node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE);\n  if (hasDoctypeChildren) {\n    throw DOMException.create(range._globalObject, [\"Invalid document type element.\", \"HierarchyRequestError\"]);\n  }\n\n  let newNode, newOffset;\n  if (isInclusiveAncestor(originalStart.node, originalEnd.node)) {\n    newNode = originalStart.node;\n    newOffset = originalStart.offset;\n  } else {\n    let referenceNode = originalStart.node;\n\n    while (\n      referenceNode &&\n      !isInclusiveAncestor(domSymbolTree.parent(referenceNode), originalEnd.node)\n    ) {\n      referenceNode = domSymbolTree.parent(referenceNode);\n    }\n\n    newNode = domSymbolTree.parent(referenceNode);\n    newOffset = domSymbolTree.index(referenceNode) + 1;\n  }\n\n  if (\n    firstPartialContainedChild !== null &&\n    (\n      firstPartialContainedChild.nodeType === NODE_TYPE.TEXT_NODE ||\n      firstPartialContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\n      firstPartialContainedChild.nodeType === NODE_TYPE.COMMENT_NODE\n    )\n  ) {\n    const cloned = clone(originalStart.node);\n    cloned._data = cloned.substringData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset);\n\n    fragment.appendChild(cloned);\n\n    originalStart.node.replaceData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset, \"\");\n  } else if (firstPartialContainedChild !== null) {\n    const cloned = clone(firstPartialContainedChild);\n    fragment.appendChild(cloned);\n\n    const subrange = Range.createImpl(_globalObject, [], {\n      start: { node: originalStart.node, offset: originalStart.offset },\n      end: { node: firstPartialContainedChild, offset: nodeLength(firstPartialContainedChild) }\n    });\n\n    const subfragment = extractRange(subrange);\n    cloned.appendChild(subfragment);\n  }\n\n  for (const containedChild of containedChildren) {\n    fragment.appendChild(containedChild);\n  }\n\n  if (\n    lastPartiallyContainedChild !== null &&\n    (\n      lastPartiallyContainedChild.nodeType === NODE_TYPE.TEXT_NODE ||\n      lastPartiallyContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE ||\n      lastPartiallyContainedChild.nodeType === NODE_TYPE.COMMENT_NODE\n    )\n  ) {\n    const cloned = clone(originalEnd.node);\n    cloned._data = cloned.substringData(0, originalEnd.offset);\n\n    fragment.appendChild(cloned);\n\n    originalEnd.node.replaceData(0, originalEnd.offset, \"\");\n  } else if (lastPartiallyContainedChild !== null) {\n    const cloned = clone(lastPartiallyContainedChild);\n    fragment.appendChild(cloned);\n\n    const subrange = Range.createImpl(_globalObject, [], {\n      start: { node: lastPartiallyContainedChild, offset: 0 },\n      end: { node: originalEnd.node, offset: originalEnd.offset }\n    });\n\n    const subfragment = extractRange(subrange);\n    cloned.appendChild(subfragment);\n  }\n\n  range._setLiveRangeStart(newNode, newOffset);\n  range._setLiveRangeEnd(newNode, newOffset);\n\n  return fragment;\n}\n\nmodule.exports = {\n  implementation: RangeImpl,\n\n  setBoundaryPointStart,\n  setBoundaryPointEnd\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}