{"ast":null,"code":"\"use strict\";\n\nconst NODE_TYPE = require(\"../node-type\");\n\nconst {\n  nodeRoot\n} = require(\"./node\");\n\nconst {\n  HTML_NS\n} = require(\"./namespaces\");\n\nconst {\n  domSymbolTree\n} = require(\"./internal-constants\");\n\nconst {\n  signalSlotList,\n  queueMutationObserverMicrotask\n} = require(\"./mutation-observers\"); // Valid host element for ShadowRoot.\n// Defined in: https://dom.spec.whatwg.org/#dom-element-attachshadow\n\n\nconst VALID_HOST_ELEMENT_NAME = new Set([\"article\", \"aside\", \"blockquote\", \"body\", \"div\", \"footer\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"header\", \"main\", \"nav\", \"p\", \"section\", \"span\"]);\n\nfunction isValidHostElementName(name) {\n  return VALID_HOST_ELEMENT_NAME.has(name);\n} // Use an approximation by checking the presence of nodeType instead of instead of using the isImpl from\n// \"../generated/Node\" to avoid introduction of circular dependencies.\n\n\nfunction isNode(nodeImpl) {\n  return Boolean(nodeImpl && \"nodeType\" in nodeImpl);\n} // Use an approximation by checking the value of nodeType and presence of nodeType host instead of instead\n// of using the isImpl from \"../generated/ShadowRoot\" to avoid introduction of circular dependencies.\n\n\nfunction isShadowRoot(nodeImpl) {\n  return Boolean(nodeImpl && nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE && \"host\" in nodeImpl);\n} // https://dom.spec.whatwg.org/#concept-slotable\n\n\nfunction isSlotable(nodeImpl) {\n  return nodeImpl && (nodeImpl.nodeType === NODE_TYPE.ELEMENT_NODE || nodeImpl.nodeType === NODE_TYPE.TEXT_NODE);\n}\n\nfunction isSlot(nodeImpl) {\n  return nodeImpl && nodeImpl.localName === \"slot\" && nodeImpl._namespaceURI === HTML_NS;\n} // https://dom.spec.whatwg.org/#concept-shadow-including-inclusive-ancestor\n\n\nfunction isShadowInclusiveAncestor(ancestor, node) {\n  while (isNode(node)) {\n    if (node === ancestor) {\n      return true;\n    }\n\n    if (isShadowRoot(node)) {\n      node = node.host;\n    } else {\n      node = domSymbolTree.parent(node);\n    }\n  }\n\n  return false;\n} // https://dom.spec.whatwg.org/#retarget\n\n\nfunction retarget(a, b) {\n  while (true) {\n    if (!isNode(a)) {\n      return a;\n    }\n\n    const aRoot = nodeRoot(a);\n\n    if (!isShadowRoot(aRoot) || isNode(b) && isShadowInclusiveAncestor(aRoot, b)) {\n      return a;\n    }\n\n    a = nodeRoot(a).host;\n  }\n} // https://dom.spec.whatwg.org/#get-the-parent\n\n\nfunction getEventTargetParent(eventTarget, event) {\n  // _getTheParent will be missing for Window, since it doesn't have an impl class and we don't want to pollute the\n  // user-visible global scope with a _getTheParent value. TODO: remove this entire function and use _getTheParent\n  // directly, once Window gets split into impl/wrapper.\n  return eventTarget._getTheParent ? eventTarget._getTheParent(event) : null;\n} // https://dom.spec.whatwg.org/#concept-shadow-including-root\n\n\nfunction shadowIncludingRoot(node) {\n  const root = nodeRoot(node);\n  return isShadowRoot(root) ? shadowIncludingRoot(root.host) : root;\n} // https://dom.spec.whatwg.org/#assign-a-slot\n\n\nfunction assignSlot(slotable) {\n  const slot = findSlot(slotable);\n\n  if (slot) {\n    assignSlotable(slot);\n  }\n} // https://dom.spec.whatwg.org/#assign-slotables\n\n\nfunction assignSlotable(slot) {\n  const slotables = findSlotable(slot);\n  let shouldFireSlotChange = false;\n\n  if (slotables.length !== slot._assignedNodes.length) {\n    shouldFireSlotChange = true;\n  } else {\n    for (let i = 0; i < slotables.length; i++) {\n      if (slotables[i] !== slot._assignedNodes[i]) {\n        shouldFireSlotChange = true;\n        break;\n      }\n    }\n  }\n\n  if (shouldFireSlotChange) {\n    signalSlotChange(slot);\n  }\n\n  slot._assignedNodes = slotables;\n\n  for (const slotable of slotables) {\n    slotable._assignedSlot = slot;\n  }\n} // https://dom.spec.whatwg.org/#assign-slotables-for-a-tree\n\n\nfunction assignSlotableForTree(root) {\n  for (const slot of domSymbolTree.treeIterator(root)) {\n    if (isSlot(slot)) {\n      assignSlotable(slot);\n    }\n  }\n} // https://dom.spec.whatwg.org/#find-slotables\n\n\nfunction findSlotable(slot) {\n  const result = [];\n  const root = nodeRoot(slot);\n\n  if (!isShadowRoot(root)) {\n    return result;\n  }\n\n  for (const slotable of domSymbolTree.treeIterator(root.host)) {\n    const foundSlot = findSlot(slotable);\n\n    if (foundSlot === slot) {\n      result.push(slotable);\n    }\n  }\n\n  return result;\n} // https://dom.spec.whatwg.org/#find-flattened-slotables\n\n\nfunction findFlattenedSlotables(slot) {\n  const result = [];\n  const root = nodeRoot(slot);\n\n  if (!isShadowRoot(root)) {\n    return result;\n  }\n\n  const slotables = findSlotable(slot);\n\n  if (slotables.length === 0) {\n    for (const child of domSymbolTree.childrenIterator(slot)) {\n      if (isSlotable(child)) {\n        slotables.push(child);\n      }\n    }\n  }\n\n  for (const node of slotables) {\n    if (isSlot(node) && isShadowRoot(nodeRoot(node))) {\n      const temporaryResult = findFlattenedSlotables(node);\n      result.push(...temporaryResult);\n    } else {\n      result.push(node);\n    }\n  }\n\n  return result;\n} // https://dom.spec.whatwg.org/#find-a-slot\n\n\nfunction findSlot(slotable, openFlag) {\n  const {\n    parentNode: parent\n  } = slotable;\n\n  if (!parent) {\n    return null;\n  }\n\n  const shadow = parent._shadowRoot;\n\n  if (!shadow || openFlag && shadow.mode !== \"open\") {\n    return null;\n  }\n\n  for (const child of domSymbolTree.treeIterator(shadow)) {\n    if (isSlot(child) && child.name === slotable._slotableName) {\n      return child;\n    }\n  }\n\n  return null;\n} // https://dom.spec.whatwg.org/#signal-a-slot-change\n\n\nfunction signalSlotChange(slot) {\n  if (!signalSlotList.some(entry => entry === slot)) {\n    signalSlotList.push(slot);\n  }\n\n  queueMutationObserverMicrotask();\n} // https://dom.spec.whatwg.org/#concept-shadow-including-descendant\n\n\nfunction* shadowIncludingInclusiveDescendantsIterator(node) {\n  yield node;\n\n  if (node._shadowRoot) {\n    yield* shadowIncludingInclusiveDescendantsIterator(node._shadowRoot);\n  }\n\n  for (const child of domSymbolTree.childrenIterator(node)) {\n    yield* shadowIncludingInclusiveDescendantsIterator(child);\n  }\n} // https://dom.spec.whatwg.org/#concept-shadow-including-descendant\n\n\nfunction* shadowIncludingDescendantsIterator(node) {\n  if (node._shadowRoot) {\n    yield* shadowIncludingInclusiveDescendantsIterator(node._shadowRoot);\n  }\n\n  for (const child of domSymbolTree.childrenIterator(node)) {\n    yield* shadowIncludingInclusiveDescendantsIterator(child);\n  }\n}\n\nmodule.exports = {\n  isValidHostElementName,\n  isNode,\n  isSlotable,\n  isSlot,\n  isShadowRoot,\n  isShadowInclusiveAncestor,\n  retarget,\n  getEventTargetParent,\n  shadowIncludingRoot,\n  assignSlot,\n  assignSlotable,\n  assignSlotableForTree,\n  findSlot,\n  findFlattenedSlotables,\n  signalSlotChange,\n  shadowIncludingInclusiveDescendantsIterator,\n  shadowIncludingDescendantsIterator\n};","map":{"version":3,"names":["NODE_TYPE","require","nodeRoot","HTML_NS","domSymbolTree","signalSlotList","queueMutationObserverMicrotask","VALID_HOST_ELEMENT_NAME","Set","isValidHostElementName","name","has","isNode","nodeImpl","Boolean","isShadowRoot","nodeType","DOCUMENT_FRAGMENT_NODE","isSlotable","ELEMENT_NODE","TEXT_NODE","isSlot","localName","_namespaceURI","isShadowInclusiveAncestor","ancestor","node","host","parent","retarget","a","b","aRoot","getEventTargetParent","eventTarget","event","_getTheParent","shadowIncludingRoot","root","assignSlot","slotable","slot","findSlot","assignSlotable","slotables","findSlotable","shouldFireSlotChange","length","_assignedNodes","i","signalSlotChange","_assignedSlot","assignSlotableForTree","treeIterator","result","foundSlot","push","findFlattenedSlotables","child","childrenIterator","temporaryResult","openFlag","parentNode","shadow","_shadowRoot","mode","_slotableName","some","entry","shadowIncludingInclusiveDescendantsIterator","shadowIncludingDescendantsIterator","module","exports"],"sources":["C:/Users/17033/balmco/node_modules/jsdom/lib/jsdom/living/helpers/shadow-dom.js"],"sourcesContent":["\"use strict\";\n\nconst NODE_TYPE = require(\"../node-type\");\n\nconst { nodeRoot } = require(\"./node\");\nconst { HTML_NS } = require(\"./namespaces\");\nconst { domSymbolTree } = require(\"./internal-constants\");\nconst { signalSlotList, queueMutationObserverMicrotask } = require(\"./mutation-observers\");\n\n// Valid host element for ShadowRoot.\n// Defined in: https://dom.spec.whatwg.org/#dom-element-attachshadow\nconst VALID_HOST_ELEMENT_NAME = new Set([\n  \"article\",\n  \"aside\",\n  \"blockquote\",\n  \"body\",\n  \"div\",\n  \"footer\",\n  \"h1\",\n  \"h2\",\n  \"h3\",\n  \"h4\",\n  \"h5\",\n  \"h6\",\n  \"header\",\n  \"main\",\n  \"nav\",\n  \"p\",\n  \"section\",\n  \"span\"\n]);\n\nfunction isValidHostElementName(name) {\n  return VALID_HOST_ELEMENT_NAME.has(name);\n}\n\n// Use an approximation by checking the presence of nodeType instead of instead of using the isImpl from\n// \"../generated/Node\" to avoid introduction of circular dependencies.\nfunction isNode(nodeImpl) {\n  return Boolean(nodeImpl && \"nodeType\" in nodeImpl);\n}\n\n// Use an approximation by checking the value of nodeType and presence of nodeType host instead of instead\n// of using the isImpl from \"../generated/ShadowRoot\" to avoid introduction of circular dependencies.\nfunction isShadowRoot(nodeImpl) {\n  return Boolean(nodeImpl && nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE && \"host\" in nodeImpl);\n}\n\n// https://dom.spec.whatwg.org/#concept-slotable\nfunction isSlotable(nodeImpl) {\n  return nodeImpl && (nodeImpl.nodeType === NODE_TYPE.ELEMENT_NODE || nodeImpl.nodeType === NODE_TYPE.TEXT_NODE);\n}\n\nfunction isSlot(nodeImpl) {\n  return nodeImpl && nodeImpl.localName === \"slot\" && nodeImpl._namespaceURI === HTML_NS;\n}\n\n// https://dom.spec.whatwg.org/#concept-shadow-including-inclusive-ancestor\nfunction isShadowInclusiveAncestor(ancestor, node) {\n  while (isNode(node)) {\n    if (node === ancestor) {\n      return true;\n    }\n\n    if (isShadowRoot(node)) {\n      node = node.host;\n    } else {\n      node = domSymbolTree.parent(node);\n    }\n  }\n\n  return false;\n}\n\n// https://dom.spec.whatwg.org/#retarget\nfunction retarget(a, b) {\n  while (true) {\n    if (!isNode(a)) {\n      return a;\n    }\n\n    const aRoot = nodeRoot(a);\n    if (\n      !isShadowRoot(aRoot) ||\n      (isNode(b) && isShadowInclusiveAncestor(aRoot, b))\n    ) {\n      return a;\n    }\n\n    a = nodeRoot(a).host;\n  }\n}\n\n// https://dom.spec.whatwg.org/#get-the-parent\nfunction getEventTargetParent(eventTarget, event) {\n  // _getTheParent will be missing for Window, since it doesn't have an impl class and we don't want to pollute the\n  // user-visible global scope with a _getTheParent value. TODO: remove this entire function and use _getTheParent\n  // directly, once Window gets split into impl/wrapper.\n  return eventTarget._getTheParent ? eventTarget._getTheParent(event) : null;\n}\n\n// https://dom.spec.whatwg.org/#concept-shadow-including-root\nfunction shadowIncludingRoot(node) {\n  const root = nodeRoot(node);\n  return isShadowRoot(root) ? shadowIncludingRoot(root.host) : root;\n}\n\n// https://dom.spec.whatwg.org/#assign-a-slot\nfunction assignSlot(slotable) {\n  const slot = findSlot(slotable);\n\n  if (slot) {\n    assignSlotable(slot);\n  }\n}\n\n// https://dom.spec.whatwg.org/#assign-slotables\nfunction assignSlotable(slot) {\n  const slotables = findSlotable(slot);\n\n  let shouldFireSlotChange = false;\n\n  if (slotables.length !== slot._assignedNodes.length) {\n    shouldFireSlotChange = true;\n  } else {\n    for (let i = 0; i < slotables.length; i++) {\n      if (slotables[i] !== slot._assignedNodes[i]) {\n        shouldFireSlotChange = true;\n        break;\n      }\n    }\n  }\n\n  if (shouldFireSlotChange) {\n    signalSlotChange(slot);\n  }\n\n  slot._assignedNodes = slotables;\n\n  for (const slotable of slotables) {\n    slotable._assignedSlot = slot;\n  }\n}\n\n// https://dom.spec.whatwg.org/#assign-slotables-for-a-tree\nfunction assignSlotableForTree(root) {\n  for (const slot of domSymbolTree.treeIterator(root)) {\n    if (isSlot(slot)) {\n      assignSlotable(slot);\n    }\n  }\n}\n\n// https://dom.spec.whatwg.org/#find-slotables\nfunction findSlotable(slot) {\n  const result = [];\n\n  const root = nodeRoot(slot);\n  if (!isShadowRoot(root)) {\n    return result;\n  }\n\n  for (const slotable of domSymbolTree.treeIterator(root.host)) {\n    const foundSlot = findSlot(slotable);\n\n    if (foundSlot === slot) {\n      result.push(slotable);\n    }\n  }\n\n  return result;\n}\n\n// https://dom.spec.whatwg.org/#find-flattened-slotables\nfunction findFlattenedSlotables(slot) {\n  const result = [];\n\n  const root = nodeRoot(slot);\n  if (!isShadowRoot(root)) {\n    return result;\n  }\n\n  const slotables = findSlotable(slot);\n\n  if (slotables.length === 0) {\n    for (const child of domSymbolTree.childrenIterator(slot)) {\n      if (isSlotable(child)) {\n        slotables.push(child);\n      }\n    }\n  }\n\n  for (const node of slotables) {\n    if (isSlot(node) && isShadowRoot(nodeRoot(node))) {\n      const temporaryResult = findFlattenedSlotables(node);\n      result.push(...temporaryResult);\n    } else {\n      result.push(node);\n    }\n  }\n\n  return result;\n}\n\n// https://dom.spec.whatwg.org/#find-a-slot\nfunction findSlot(slotable, openFlag) {\n  const { parentNode: parent } = slotable;\n\n  if (!parent) {\n    return null;\n  }\n\n  const shadow = parent._shadowRoot;\n\n  if (!shadow || (openFlag && shadow.mode !== \"open\")) {\n    return null;\n  }\n\n  for (const child of domSymbolTree.treeIterator(shadow)) {\n    if (isSlot(child) && child.name === slotable._slotableName) {\n      return child;\n    }\n  }\n\n  return null;\n}\n\n// https://dom.spec.whatwg.org/#signal-a-slot-change\nfunction signalSlotChange(slot) {\n  if (!signalSlotList.some(entry => entry === slot)) {\n    signalSlotList.push(slot);\n  }\n\n  queueMutationObserverMicrotask();\n}\n\n// https://dom.spec.whatwg.org/#concept-shadow-including-descendant\nfunction* shadowIncludingInclusiveDescendantsIterator(node) {\n  yield node;\n\n  if (node._shadowRoot) {\n    yield* shadowIncludingInclusiveDescendantsIterator(node._shadowRoot);\n  }\n\n  for (const child of domSymbolTree.childrenIterator(node)) {\n    yield* shadowIncludingInclusiveDescendantsIterator(child);\n  }\n}\n\n// https://dom.spec.whatwg.org/#concept-shadow-including-descendant\nfunction* shadowIncludingDescendantsIterator(node) {\n  if (node._shadowRoot) {\n    yield* shadowIncludingInclusiveDescendantsIterator(node._shadowRoot);\n  }\n\n  for (const child of domSymbolTree.childrenIterator(node)) {\n    yield* shadowIncludingInclusiveDescendantsIterator(child);\n  }\n}\n\nmodule.exports = {\n  isValidHostElementName,\n\n  isNode,\n  isSlotable,\n  isSlot,\n  isShadowRoot,\n\n  isShadowInclusiveAncestor,\n  retarget,\n  getEventTargetParent,\n  shadowIncludingRoot,\n\n  assignSlot,\n  assignSlotable,\n  assignSlotableForTree,\n\n  findSlot,\n  findFlattenedSlotables,\n\n  signalSlotChange,\n\n  shadowIncludingInclusiveDescendantsIterator,\n  shadowIncludingDescendantsIterator\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}