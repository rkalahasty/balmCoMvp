{"ast":null,"code":"\"use strict\";\n\nconst http = require(\"http\");\n\nconst https = require(\"https\");\n\nconst {\n  Writable\n} = require(\"stream\");\n\nconst zlib = require(\"zlib\");\n\nconst ver = process.version.replace(\"v\", \"\").split(\".\");\nconst majorNodeVersion = Number.parseInt(ver[0]);\n\nfunction abortRequest(clientRequest) {\n  // clientRequest.destroy breaks the test suite for versions 10 and 12,\n  // hence the version check\n  if (majorNodeVersion > 13) {\n    clientRequest.destroy();\n  } else {\n    clientRequest.abort();\n  }\n\n  clientRequest.removeAllListeners();\n  clientRequest.on(\"error\", () => {});\n}\n\nmodule.exports = class Request extends Writable {\n  constructor(url, clientOptions, requestOptions) {\n    super();\n    Object.assign(this, clientOptions);\n    this.currentURL = url;\n    this._requestOptions = requestOptions;\n    this.headers = requestOptions.headers;\n    this._ended = false;\n    this._redirectCount = 0;\n    this._requestBodyBuffers = [];\n    this._bufferIndex = 0;\n\n    this._performRequest();\n  }\n\n  abort() {\n    abortRequest(this._currentRequest);\n    this.emit(\"abort\");\n    this.removeAllListeners();\n  }\n\n  pipeRequest(form) {\n    form.pipe(this._currentRequest);\n  }\n\n  write(data, encoding) {\n    if (data.length > 0) {\n      this._requestBodyBuffers.push({\n        data,\n        encoding\n      });\n\n      this._currentRequest.write(data, encoding);\n    }\n  }\n\n  end() {\n    this.emit(\"request\", this._currentRequest);\n    this._ended = true;\n\n    this._currentRequest.end();\n  }\n\n  setHeader(name, value) {\n    this.headers[name] = value;\n\n    this._currentRequest.setHeader(name, value);\n  }\n\n  removeHeader(name) {\n    delete this.headers[name];\n\n    this._currentRequest.removeHeader(name);\n  } // Without this method, the test send-redirect-infinite-sync will halt the test suite\n  // TODO: investigate this further and ideally remove\n\n\n  toJSON() {\n    const {\n      method,\n      headers\n    } = this._requestOptions;\n    return {\n      uri: new URL(this.currentURL),\n      method,\n      headers\n    };\n  }\n\n  _writeNext(error) {\n    if (this._currentRequest) {\n      if (error) {\n        this.emit(\"error\", error);\n      } else if (this._bufferIndex < this._requestBodyBuffers.length) {\n        const buffer = this._requestBodyBuffers[this._bufferIndex++];\n\n        if (!this._currentRequest.writableEnded) {\n          this._currentRequest.write(buffer.data, buffer.encoding, this._writeNext.bind(this));\n        }\n      } else if (this._ended) {\n        this._currentRequest.end();\n      }\n    }\n  }\n\n  _performRequest() {\n    var _this = this;\n\n    const urlOptions = new URL(this.currentURL);\n    const scheme = urlOptions.protocol;\n    this._requestOptions.agent = this.agents[scheme.substring(0, scheme.length - 1)];\n    const {\n      request\n    } = scheme === \"https:\" ? https : http;\n    this._currentRequest = request(this.currentURL, this._requestOptions, response => {\n      this._processResponse(response);\n    });\n    let cookies;\n\n    if (this._redirectCount === 0) {\n      this.originalCookieHeader = this.getHeader(\"Cookie\");\n    }\n\n    if (this.cookieJar) {\n      cookies = this.cookieJar.getCookieStringSync(this.currentURL);\n    }\n\n    if (cookies && cookies.length) {\n      if (this.originalCookieHeader) {\n        this.setHeader(\"Cookie\", this.originalCookieHeader + \"; \" + cookies);\n      } else {\n        this.setHeader(\"Cookie\", cookies);\n      }\n    }\n\n    for (const event of [\"connect\", \"error\", \"socket\", \"timeout\"]) {\n      this._currentRequest.on(event, function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        _this.emit(event, ...args);\n      });\n    }\n\n    if (this._isRedirect) {\n      this._bufferIndex = 0;\n\n      this._writeNext();\n    }\n  }\n\n  _processResponse(response) {\n    const cookies = response.headers[\"set-cookie\"];\n\n    if (this.cookieJar && Array.isArray(cookies)) {\n      try {\n        cookies.forEach(cookie => {\n          this.cookieJar.setCookieSync(cookie, this.currentURL, {\n            ignoreError: true\n          });\n        });\n      } catch (e) {\n        this.emit(\"error\", e);\n      }\n    }\n\n    const {\n      statusCode\n    } = response;\n    const {\n      location\n    } = response.headers; // In Node v15, aborting a message with remaining data causes an error to be thrown,\n    // hence the version check\n\n    const catchResErrors = err => {\n      if (!(majorNodeVersion >= 15 && err.message === \"aborted\")) {\n        this.emit(\"error\", err);\n      }\n    };\n\n    response.on(\"error\", catchResErrors);\n    let redirectAddress = null;\n    let resendWithAuth = false;\n\n    if (typeof location === \"string\" && location.length && this.followRedirects && statusCode >= 300 && statusCode < 400) {\n      redirectAddress = location;\n    } else if (statusCode === 401 && /^Basic /i.test(response.headers[\"www-authenticate\"] || \"\") && this.user && this.user.length) {\n      this._requestOptions.auth = `${this.user}:${this.pass}`;\n      resendWithAuth = true;\n    }\n\n    if (redirectAddress || resendWithAuth) {\n      if (++this._redirectCount > 21) {\n        const redirectError = new Error(\"Maximum number of redirects exceeded\");\n        redirectError.code = \"ERR_TOO_MANY_REDIRECTS\";\n        this.emit(\"error\", redirectError);\n        return;\n      }\n\n      abortRequest(this._currentRequest);\n      response.destroy();\n      this._isRedirect = true;\n\n      if ((statusCode === 301 || statusCode === 302) && this._requestOptions.method === \"POST\" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._requestOptions.method)) {\n        this._requestOptions.method = \"GET\";\n        this._requestBodyBuffers = [];\n      }\n\n      let previousHostName = this._removeMatchingHeaders(/^host$/i);\n\n      if (!previousHostName) {\n        previousHostName = new URL(this.currentURL).hostname;\n      }\n\n      const previousURL = this.currentURL;\n\n      if (!resendWithAuth) {\n        const nextURL = redirectAddress.startsWith(\"https:\") ? new URL(redirectAddress) : new URL(redirectAddress, this.currentURL);\n\n        if (nextURL.hostname !== previousHostName) {\n          this._removeMatchingHeaders(/^authorization$/i);\n        }\n\n        this.currentURL = nextURL.toString();\n      }\n\n      this.headers.Referer = previousURL;\n      this.emit(\"redirect\", response, this.headers, this.currentURL);\n\n      try {\n        this._performRequest();\n      } catch (cause) {\n        this.emit(\"error\", cause);\n      }\n    } else {\n      let pipeline = response;\n      const acceptEncoding = this.headers[\"Accept-Encoding\"];\n      const requestCompressed = typeof acceptEncoding === \"string\" && (acceptEncoding.includes(\"gzip\") || acceptEncoding.includes(\"deflate\"));\n\n      if (requestCompressed && this._requestOptions.method !== \"HEAD\" && statusCode >= 200 && statusCode !== 204 && statusCode !== 304) {\n        const zlibOptions = {\n          flush: zlib.constants.Z_SYNC_FLUSH,\n          finishFlush: zlib.constants.Z_SYNC_FLUSH\n        };\n        const contentEncoding = (response.headers[\"content-encoding\"] || \"identity\").trim().toLowerCase();\n\n        if (contentEncoding === \"gzip\") {\n          pipeline = zlib.createGunzip(zlibOptions);\n          response.pipe(pipeline);\n        } else if (contentEncoding === \"deflate\") {\n          pipeline = zlib.createInflate(zlibOptions);\n          response.pipe(pipeline);\n        }\n      }\n\n      pipeline.removeAllListeners(\"error\");\n      this.emit(\"response\", response, this.currentURL);\n      pipeline.on(\"data\", bytes => this.emit(\"data\", bytes));\n      pipeline.once(\"end\", bytes => this.emit(\"end\", bytes));\n      pipeline.on(\"error\", catchResErrors);\n      pipeline.on(\"close\", () => this.emit(\"close\"));\n      this._requestBodyBuffers = [];\n    }\n  }\n\n  getHeader(key, value) {\n    if (this._currentRequest) {\n      return this._currentRequest.getHeader(key, value);\n    }\n\n    return null;\n  }\n\n  _removeMatchingHeaders(regex) {\n    let lastValue;\n\n    for (const header in this.headers) {\n      if (regex.test(header)) {\n        lastValue = this.headers[header];\n        delete this.headers[header];\n      }\n    }\n\n    return lastValue;\n  }\n\n};","map":{"version":3,"names":["http","require","https","Writable","zlib","ver","process","version","replace","split","majorNodeVersion","Number","parseInt","abortRequest","clientRequest","destroy","abort","removeAllListeners","on","module","exports","Request","constructor","url","clientOptions","requestOptions","Object","assign","currentURL","_requestOptions","headers","_ended","_redirectCount","_requestBodyBuffers","_bufferIndex","_performRequest","_currentRequest","emit","pipeRequest","form","pipe","write","data","encoding","length","push","end","setHeader","name","value","removeHeader","toJSON","method","uri","URL","_writeNext","error","buffer","writableEnded","bind","urlOptions","scheme","protocol","agent","agents","substring","request","response","_processResponse","cookies","originalCookieHeader","getHeader","cookieJar","getCookieStringSync","event","args","_isRedirect","Array","isArray","forEach","cookie","setCookieSync","ignoreError","e","statusCode","location","catchResErrors","err","message","redirectAddress","resendWithAuth","followRedirects","test","user","auth","pass","redirectError","Error","code","previousHostName","_removeMatchingHeaders","hostname","previousURL","nextURL","startsWith","toString","Referer","cause","pipeline","acceptEncoding","requestCompressed","includes","zlibOptions","flush","constants","Z_SYNC_FLUSH","finishFlush","contentEncoding","trim","toLowerCase","createGunzip","createInflate","bytes","once","key","regex","lastValue","header"],"sources":["C:/Users/17033/balmco/node_modules/jsdom/lib/jsdom/living/helpers/http-request.js"],"sourcesContent":["\"use strict\";\nconst http = require(\"http\");\nconst https = require(\"https\");\nconst { Writable } = require(\"stream\");\nconst zlib = require(\"zlib\");\n\nconst ver = process.version.replace(\"v\", \"\").split(\".\");\nconst majorNodeVersion = Number.parseInt(ver[0]);\n\nfunction abortRequest(clientRequest) {\n  // clientRequest.destroy breaks the test suite for versions 10 and 12,\n  // hence the version check\n  if (majorNodeVersion > 13) {\n    clientRequest.destroy();\n  } else {\n    clientRequest.abort();\n  }\n  clientRequest.removeAllListeners();\n  clientRequest.on(\"error\", () => {});\n}\n\nmodule.exports = class Request extends Writable {\n  constructor(url, clientOptions, requestOptions) {\n    super();\n    Object.assign(this, clientOptions);\n    this.currentURL = url;\n    this._requestOptions = requestOptions;\n    this.headers = requestOptions.headers;\n    this._ended = false;\n    this._redirectCount = 0;\n    this._requestBodyBuffers = [];\n    this._bufferIndex = 0;\n    this._performRequest();\n  }\n\n  abort() {\n    abortRequest(this._currentRequest);\n    this.emit(\"abort\");\n    this.removeAllListeners();\n  }\n\n  pipeRequest(form) {\n    form.pipe(this._currentRequest);\n  }\n\n  write(data, encoding) {\n    if (data.length > 0) {\n      this._requestBodyBuffers.push({ data, encoding });\n      this._currentRequest.write(data, encoding);\n    }\n  }\n\n  end() {\n    this.emit(\"request\", this._currentRequest);\n    this._ended = true;\n    this._currentRequest.end();\n  }\n\n  setHeader(name, value) {\n    this.headers[name] = value;\n    this._currentRequest.setHeader(name, value);\n  }\n\n  removeHeader(name) {\n    delete this.headers[name];\n    this._currentRequest.removeHeader(name);\n  }\n\n  // Without this method, the test send-redirect-infinite-sync will halt the test suite\n  // TODO: investigate this further and ideally remove\n  toJSON() {\n    const { method, headers } = this._requestOptions;\n    return { uri: new URL(this.currentURL), method, headers };\n  }\n\n  _writeNext(error) {\n    if (this._currentRequest) {\n      if (error) {\n        this.emit(\"error\", error);\n      } else if (this._bufferIndex < this._requestBodyBuffers.length) {\n        const buffer = this._requestBodyBuffers[this._bufferIndex++];\n        if (!this._currentRequest.writableEnded) {\n          this._currentRequest.write(\n            buffer.data,\n            buffer.encoding,\n            this._writeNext.bind(this)\n          );\n        }\n      } else if (this._ended) {\n        this._currentRequest.end();\n      }\n    }\n  }\n\n  _performRequest() {\n    const urlOptions = new URL(this.currentURL);\n    const scheme = urlOptions.protocol;\n    this._requestOptions.agent = this.agents[scheme.substring(0, scheme.length - 1)];\n    const { request } = scheme === \"https:\" ? https : http;\n    this._currentRequest = request(this.currentURL, this._requestOptions, response => {\n      this._processResponse(response);\n    });\n\n    let cookies;\n    if (this._redirectCount === 0) {\n      this.originalCookieHeader = this.getHeader(\"Cookie\");\n    }\n    if (this.cookieJar) {\n      cookies = this.cookieJar.getCookieStringSync(this.currentURL);\n    }\n    if (cookies && cookies.length) {\n      if (this.originalCookieHeader) {\n        this.setHeader(\"Cookie\", this.originalCookieHeader + \"; \" + cookies);\n      } else {\n        this.setHeader(\"Cookie\", cookies);\n      }\n    }\n\n    for (const event of [\"connect\", \"error\", \"socket\", \"timeout\"]) {\n      this._currentRequest.on(event, (...args) => {\n        this.emit(event, ...args);\n      });\n    }\n    if (this._isRedirect) {\n      this._bufferIndex = 0;\n      this._writeNext();\n    }\n  }\n\n  _processResponse(response) {\n    const cookies = response.headers[\"set-cookie\"];\n    if (this.cookieJar && Array.isArray(cookies)) {\n      try {\n        cookies.forEach(cookie => {\n          this.cookieJar.setCookieSync(cookie, this.currentURL, { ignoreError: true });\n        });\n      } catch (e) {\n        this.emit(\"error\", e);\n      }\n    }\n\n    const { statusCode } = response;\n    const { location } = response.headers;\n    // In Node v15, aborting a message with remaining data causes an error to be thrown,\n    // hence the version check\n    const catchResErrors = err => {\n      if (!(majorNodeVersion >= 15 && err.message === \"aborted\")) {\n        this.emit(\"error\", err);\n      }\n    };\n    response.on(\"error\", catchResErrors);\n    let redirectAddress = null;\n    let resendWithAuth = false;\n    if (typeof location === \"string\" &&\n      location.length &&\n      this.followRedirects &&\n      statusCode >= 300 &&\n      statusCode < 400) {\n      redirectAddress = location;\n    } else if (statusCode === 401 &&\n      /^Basic /i.test(response.headers[\"www-authenticate\"] || \"\") &&\n      (this.user && this.user.length)) {\n      this._requestOptions.auth = `${this.user}:${this.pass}`;\n      resendWithAuth = true;\n    }\n    if (redirectAddress || resendWithAuth) {\n      if (++this._redirectCount > 21) {\n        const redirectError = new Error(\"Maximum number of redirects exceeded\");\n        redirectError.code = \"ERR_TOO_MANY_REDIRECTS\";\n        this.emit(\"error\", redirectError);\n        return;\n      }\n      abortRequest(this._currentRequest);\n      response.destroy();\n      this._isRedirect = true;\n      if (((statusCode === 301 || statusCode === 302) && this._requestOptions.method === \"POST\") ||\n        (statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._requestOptions.method))) {\n        this._requestOptions.method = \"GET\";\n        this._requestBodyBuffers = [];\n      }\n      let previousHostName = this._removeMatchingHeaders(/^host$/i);\n      if (!previousHostName) {\n        previousHostName = new URL(this.currentURL).hostname;\n      }\n      const previousURL = this.currentURL;\n      if (!resendWithAuth) {\n        const nextURL = redirectAddress.startsWith(\"https:\") ?\n          new URL(redirectAddress) :\n          new URL(redirectAddress, this.currentURL);\n        if (nextURL.hostname !== previousHostName) {\n          this._removeMatchingHeaders(/^authorization$/i);\n        }\n        this.currentURL = nextURL.toString();\n      }\n      this.headers.Referer = previousURL;\n      this.emit(\"redirect\", response, this.headers, this.currentURL);\n      try {\n        this._performRequest();\n      } catch (cause) {\n        this.emit(\"error\", cause);\n      }\n    } else {\n      let pipeline = response;\n      const acceptEncoding = this.headers[\"Accept-Encoding\"];\n      const requestCompressed = typeof acceptEncoding === \"string\" &&\n        (acceptEncoding.includes(\"gzip\") || acceptEncoding.includes(\"deflate\"));\n      if (\n        requestCompressed &&\n        this._requestOptions.method !== \"HEAD\" &&\n        statusCode >= 200 &&\n        statusCode !== 204 &&\n        statusCode !== 304\n      ) {\n        const zlibOptions = {\n          flush: zlib.constants.Z_SYNC_FLUSH,\n          finishFlush: zlib.constants.Z_SYNC_FLUSH\n        };\n        const contentEncoding = (response.headers[\"content-encoding\"] || \"identity\").trim().toLowerCase();\n        if (contentEncoding === \"gzip\") {\n          pipeline = zlib.createGunzip(zlibOptions);\n          response.pipe(pipeline);\n        } else if (contentEncoding === \"deflate\") {\n          pipeline = zlib.createInflate(zlibOptions);\n          response.pipe(pipeline);\n        }\n      }\n      pipeline.removeAllListeners(\"error\");\n      this.emit(\"response\", response, this.currentURL);\n      pipeline.on(\"data\", bytes => this.emit(\"data\", bytes));\n      pipeline.once(\"end\", bytes => this.emit(\"end\", bytes));\n      pipeline.on(\"error\", catchResErrors);\n      pipeline.on(\"close\", () => this.emit(\"close\"));\n      this._requestBodyBuffers = [];\n    }\n  }\n\n  getHeader(key, value) {\n    if (this._currentRequest) {\n      return this._currentRequest.getHeader(key, value);\n    }\n    return null;\n  }\n\n  _removeMatchingHeaders(regex) {\n    let lastValue;\n    for (const header in this.headers) {\n      if (regex.test(header)) {\n        lastValue = this.headers[header];\n        delete this.headers[header];\n      }\n    }\n    return lastValue;\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}