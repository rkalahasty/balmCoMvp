{"ast":null,"code":"\"use strict\";\n\nconst whatwgURL = require(\"whatwg-url\");\n\nconst HashChangeEvent = require(\"../generated/HashChangeEvent.js\");\n\nconst PopStateEvent = require(\"../generated/PopStateEvent.js\");\n\nconst notImplemented = require(\"../../browser/not-implemented.js\");\n\nconst idlUtils = require(\"../generated/utils.js\");\n\nconst {\n  fireAnEvent\n} = require(\"../helpers/events\"); // https://html.spec.whatwg.org/#session-history\n\n\nclass SessionHistory {\n  constructor(initialEntry, window) {\n    this._window = window;\n    this._windowImpl = idlUtils.implForWrapper(window);\n    this._historyTraversalQueue = new Set();\n    this._entries = [initialEntry];\n    this._currentIndex = 0;\n  }\n\n  _queueHistoryTraversalTask(fn) {\n    const timeoutId = this._window.setTimeout(() => {\n      this._historyTraversalQueue.delete(timeoutId);\n\n      fn();\n    }, 0);\n\n    this._historyTraversalQueue.add(timeoutId);\n  }\n\n  clearHistoryTraversalTasks() {\n    for (const timeoutId of this._historyTraversalQueue) {\n      this._window.clearTimeout(timeoutId);\n    }\n\n    this._historyTraversalQueue.clear();\n  }\n\n  get length() {\n    return this._entries.length;\n  }\n\n  get currentEntry() {\n    return this._entries[this._currentIndex];\n  } // https://html.spec.whatwg.org/#dom-history-pushstate\n\n\n  removeAllEntriesAfterCurrentEntry() {\n    this._entries.splice(this._currentIndex + 1, Infinity);\n  } // https://html.spec.whatwg.org/#traverse-the-history-by-a-delta\n\n\n  traverseByDelta(delta) {\n    this._queueHistoryTraversalTask(() => {\n      const newIndex = this._currentIndex + delta;\n\n      if (newIndex < 0 || newIndex >= this.length) {\n        return;\n      }\n\n      const specifiedEntry = this._entries[newIndex]; // Not implemented: unload a document guard\n      // Not clear that this should be queued. html/browsers/history/the-history-interface/004.html can be fixed\n      // by removing the queue, but doing so breaks some tests in history.js that also pass in browsers.\n\n      this._queueHistoryTraversalTask(() => {\n        // If there is an ongoing attempt to navigate specified browsing context that has not yet matured,\n        // then cancel that attempt to navigate the browsing context.\n        // Doing this seems to break tests involving navigating via push/pop state and via fragments. I think this\n        // is because these navigations should already count as having \"matured\" because the document is not changing.\n        // this.clearHistoryTraversalTasks();\n        if (specifiedEntry.document !== this.currentEntry.document) {\n          // TODO: unload the active document with the recycle parameter set to false\n          notImplemented(\"Traversing history in a way that would change the window\", this._window);\n        }\n\n        this.traverseHistory(specifiedEntry);\n      });\n    });\n  } // https://html.spec.whatwg.org/#traverse-the-history\n\n\n  traverseHistory(specifiedEntry) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!specifiedEntry.document) {\n      // If entry no longer holds a Document object, then navigate the browsing context to entry's URL\n      // to perform an entry update of entry, and abort these steps\n      notImplemented(\"Traversing the history to an entry that no longer holds a Document object\", this._window);\n    } // Not spec compliant, just minimal. Lots of missing steps.\n\n\n    const nonBlockingEvents = Boolean(flags.nonBlockingEvents);\n    const document = idlUtils.implForWrapper(this._window._document);\n    const {\n      currentEntry\n    } = this; // If the current entry's title was not set by the pushState() or replaceState() methods, then set its title\n    // to the value returned by the document.title IDL attribute.\n\n    if (currentEntry.title === undefined) {\n      currentEntry.title = document.title;\n    }\n\n    if (specifiedEntry.document !== currentEntry.document) {\n      // If entry has a different Document object than the current entry, then...\n      notImplemented(\"Traversing the history to an entry with a different Document\", this._window);\n    }\n\n    document._URL = specifiedEntry.url;\n    const hashChanged = specifiedEntry.url.fragment !== currentEntry.url.fragment && specifiedEntry.document === currentEntry.document;\n    let oldURL, newURL;\n\n    if (hashChanged) {\n      oldURL = currentEntry.url;\n      newURL = specifiedEntry.url;\n    }\n\n    if (flags.replacement) {\n      // If the traversal was initiated with replacement enabled, remove the entry immediately before the\n      // specified entry in the session history.\n      this._entries.splice(this._entries.indexOf(specifiedEntry) - 1, 1);\n    }\n\n    this.updateCurrentEntry(specifiedEntry);\n    const state = specifiedEntry.stateObject; // TODO structured clone\n    // arguably it's a bit odd that the state and latestEntry do not belong to the SessionHistory\n    // but the spec gives them to \"History\" and \"Document\" respecively.\n\n    document._history._state = state;\n    const stateChanged = specifiedEntry.document._latestEntry !== specifiedEntry;\n    specifiedEntry.document._latestEntry = specifiedEntry;\n\n    const fireEvents = () => this._fireEvents(stateChanged, hashChanged, state, oldURL, newURL);\n\n    if (nonBlockingEvents) {\n      this._window.setTimeout(fireEvents, 0);\n    } else {\n      fireEvents();\n    }\n  }\n\n  _fireEvents(stateChanged, hashChanged, state, oldURL, newURL) {\n    if (stateChanged) {\n      fireAnEvent(\"popstate\", this._windowImpl, PopStateEvent, {\n        state\n      });\n    }\n\n    if (hashChanged) {\n      fireAnEvent(\"hashchange\", this._windowImpl, HashChangeEvent, {\n        oldURL: whatwgURL.serializeURL(oldURL),\n        newURL: whatwgURL.serializeURL(newURL)\n      });\n    }\n  }\n\n  addEntryAfterCurrentEntry(entry) {\n    this._entries.splice(this._currentIndex + 1, 0, entry);\n  }\n\n  updateCurrentEntry(entry) {\n    this._currentIndex = this._entries.indexOf(entry);\n  }\n\n}\n\nmodule.exports = SessionHistory;","map":{"version":3,"names":["whatwgURL","require","HashChangeEvent","PopStateEvent","notImplemented","idlUtils","fireAnEvent","SessionHistory","constructor","initialEntry","window","_window","_windowImpl","implForWrapper","_historyTraversalQueue","Set","_entries","_currentIndex","_queueHistoryTraversalTask","fn","timeoutId","setTimeout","delete","add","clearHistoryTraversalTasks","clearTimeout","clear","length","currentEntry","removeAllEntriesAfterCurrentEntry","splice","Infinity","traverseByDelta","delta","newIndex","specifiedEntry","document","traverseHistory","flags","nonBlockingEvents","Boolean","_document","title","undefined","_URL","url","hashChanged","fragment","oldURL","newURL","replacement","indexOf","updateCurrentEntry","state","stateObject","_history","_state","stateChanged","_latestEntry","fireEvents","_fireEvents","serializeURL","addEntryAfterCurrentEntry","entry","module","exports"],"sources":["C:/Users/17033/balmco/node_modules/jsdom/lib/jsdom/living/window/SessionHistory.js"],"sourcesContent":["\"use strict\";\nconst whatwgURL = require(\"whatwg-url\");\nconst HashChangeEvent = require(\"../generated/HashChangeEvent.js\");\nconst PopStateEvent = require(\"../generated/PopStateEvent.js\");\nconst notImplemented = require(\"../../browser/not-implemented.js\");\nconst idlUtils = require(\"../generated/utils.js\");\nconst { fireAnEvent } = require(\"../helpers/events\");\n\n// https://html.spec.whatwg.org/#session-history\nclass SessionHistory {\n  constructor(initialEntry, window) {\n    this._window = window;\n    this._windowImpl = idlUtils.implForWrapper(window);\n    this._historyTraversalQueue = new Set();\n    this._entries = [initialEntry];\n    this._currentIndex = 0;\n  }\n\n  _queueHistoryTraversalTask(fn) {\n    const timeoutId = this._window.setTimeout(() => {\n      this._historyTraversalQueue.delete(timeoutId);\n      fn();\n    }, 0);\n\n    this._historyTraversalQueue.add(timeoutId);\n  }\n\n  clearHistoryTraversalTasks() {\n    for (const timeoutId of this._historyTraversalQueue) {\n      this._window.clearTimeout(timeoutId);\n    }\n    this._historyTraversalQueue.clear();\n  }\n\n  get length() {\n    return this._entries.length;\n  }\n\n  get currentEntry() {\n    return this._entries[this._currentIndex];\n  }\n\n  // https://html.spec.whatwg.org/#dom-history-pushstate\n  removeAllEntriesAfterCurrentEntry() {\n    this._entries.splice(this._currentIndex + 1, Infinity);\n  }\n\n  // https://html.spec.whatwg.org/#traverse-the-history-by-a-delta\n  traverseByDelta(delta) {\n    this._queueHistoryTraversalTask(() => {\n      const newIndex = this._currentIndex + delta;\n      if (newIndex < 0 || newIndex >= this.length) {\n        return;\n      }\n\n      const specifiedEntry = this._entries[newIndex];\n\n      // Not implemented: unload a document guard\n\n      // Not clear that this should be queued. html/browsers/history/the-history-interface/004.html can be fixed\n      // by removing the queue, but doing so breaks some tests in history.js that also pass in browsers.\n      this._queueHistoryTraversalTask(() => {\n        // If there is an ongoing attempt to navigate specified browsing context that has not yet matured,\n        // then cancel that attempt to navigate the browsing context.\n\n        // Doing this seems to break tests involving navigating via push/pop state and via fragments. I think this\n        // is because these navigations should already count as having \"matured\" because the document is not changing.\n\n        // this.clearHistoryTraversalTasks();\n\n        if (specifiedEntry.document !== this.currentEntry.document) {\n          // TODO: unload the active document with the recycle parameter set to false\n          notImplemented(\"Traversing history in a way that would change the window\", this._window);\n        }\n        this.traverseHistory(specifiedEntry);\n      });\n    });\n  }\n\n  // https://html.spec.whatwg.org/#traverse-the-history\n  traverseHistory(specifiedEntry, flags = {}) {\n    if (!specifiedEntry.document) {\n      // If entry no longer holds a Document object, then navigate the browsing context to entry's URL\n      // to perform an entry update of entry, and abort these steps\n      notImplemented(\"Traversing the history to an entry that no longer holds a Document object\", this._window);\n    }\n    // Not spec compliant, just minimal. Lots of missing steps.\n\n    const nonBlockingEvents = Boolean(flags.nonBlockingEvents);\n\n    const document = idlUtils.implForWrapper(this._window._document);\n\n    const { currentEntry } = this;\n\n    // If the current entry's title was not set by the pushState() or replaceState() methods, then set its title\n    // to the value returned by the document.title IDL attribute.\n    if (currentEntry.title === undefined) {\n      currentEntry.title = document.title;\n    }\n\n\n    if (specifiedEntry.document !== currentEntry.document) {\n      // If entry has a different Document object than the current entry, then...\n      notImplemented(\"Traversing the history to an entry with a different Document\", this._window);\n    }\n\n    document._URL = specifiedEntry.url;\n\n    const hashChanged =\n      specifiedEntry.url.fragment !== currentEntry.url.fragment && specifiedEntry.document === currentEntry.document;\n    let oldURL, newURL;\n    if (hashChanged) {\n      oldURL = currentEntry.url;\n      newURL = specifiedEntry.url;\n    }\n\n    if (flags.replacement) {\n      // If the traversal was initiated with replacement enabled, remove the entry immediately before the\n      // specified entry in the session history.\n      this._entries.splice(this._entries.indexOf(specifiedEntry) - 1, 1);\n    }\n\n    this.updateCurrentEntry(specifiedEntry);\n\n    const state = specifiedEntry.stateObject; // TODO structured clone\n\n    // arguably it's a bit odd that the state and latestEntry do not belong to the SessionHistory\n    // but the spec gives them to \"History\" and \"Document\" respecively.\n    document._history._state = state;\n    const stateChanged = specifiedEntry.document._latestEntry !== specifiedEntry;\n    specifiedEntry.document._latestEntry = specifiedEntry;\n\n    const fireEvents = () => this._fireEvents(stateChanged, hashChanged, state, oldURL, newURL);\n\n    if (nonBlockingEvents) {\n      this._window.setTimeout(fireEvents, 0);\n    } else {\n      fireEvents();\n    }\n  }\n\n  _fireEvents(stateChanged, hashChanged, state, oldURL, newURL) {\n    if (stateChanged) {\n      fireAnEvent(\"popstate\", this._windowImpl, PopStateEvent, { state });\n    }\n\n    if (hashChanged) {\n      fireAnEvent(\"hashchange\", this._windowImpl, HashChangeEvent, {\n        oldURL: whatwgURL.serializeURL(oldURL),\n        newURL: whatwgURL.serializeURL(newURL)\n      });\n    }\n  }\n\n  addEntryAfterCurrentEntry(entry) {\n    this._entries.splice(this._currentIndex + 1, 0, entry);\n  }\n\n  updateCurrentEntry(entry) {\n    this._currentIndex = this._entries.indexOf(entry);\n  }\n}\nmodule.exports = SessionHistory;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}